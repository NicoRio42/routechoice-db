// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Table event {
  id integer [primary key]
  name varchar [not null]
  start_date timestamp [not null]
  finish_date timestamp [not null]
  publish_date timestamp [not null]
}

Table live_event {
  id integer [primary key]
  fk_event integer [not null]
	live_provider varchar [not null]
	url varchar [not null]
  is_primary boolean [not null]
}

Ref: live_event.fk_event < event.id [delete: cascade, update: no action]

Table tag {
  id integer [primary key]
  name varchar [not null]
  color varchar [not null]
}

Table asso_event_tag {
  id_event integer [not null]
  id_tag integer [not null]

  indexes {
    (id_event, id_tag) [pk]
  }
}

Ref: event.id < asso_event_tag.id_event [delete: cascade, update: no action]
Ref: tag.id < asso_event_tag.id_tag [delete: cascade, update: no action]

Table leg {
  id integer [primary key]
  fk_event integer [not null]
  fk_start_control_point integer [not null]
  fk_finish_control_point integer [not null]
}

Ref: leg.fk_event > event.id [delete: cascade, update: no action]
Ref: leg.fk_start_control_point > control_point.id [delete: cascade, update: no action]
Ref: leg.fk_finish_control_point > control_point.id [delete: cascade, update: no action]

Table control_point {
  id integer [primary key]
  longitude integer [not null]
  latitude integer [not null]
}

Table routechoice {
  id integer [primary key]
  name varchar [not null]
  color varchar [not null]
  fk_leg integer [not null]
  longitudes varchar [not null]
  latitudes varchar [not null]
  length integer [not null]
}

Ref: routechoice.fk_leg > leg.id [delete: cascade, update: no action]

Table runner {
  id integer [primary key]
  tracking_device_id varchar [not null]
  fk_event integer [not null]
  fk_user integer [unique]
  status varchar [not null]
  first_name varchar [not null]
  last_name varchar [not null]
  start_time timestamp [not null]
  time integer
  rank integer
  time_behind integer
  total_time_lost integer [not null]
  time_offset integer [not null]
}

Ref: runner.fk_user > auth_user.id [delete: cascade, update: no action]
Ref: runner.fk_event > event.id [delete: cascade, update: no action]

Table runner_leg {
  id integer [primary key]
  fk_detected_routechoice integer
  fk_manual_routechoice integer
  fk_leg integer [not null]
  fk_runner integer [not null]
  time_overall integer [not null]
  time integer [not null]
  rank_split integer [not null]
  time_behind_split integer [not null]
  rank_overall integer
  time_behind_boverall integer
  time_behind_superman integer
  is_mistake boolean [not null, default: false]
  time_loss integer [not null]
  routechoice_time_loss integer [not null]
}

Ref: runner_leg.fk_runner > runner.id [delete: cascade, update: no action]
Ref: runner_leg.fk_leg > leg.id [delete: cascade, update: no action]
Ref: runner_leg.fk_detected_routechoice > routechoice.id [delete: cascade, update: no action]
Ref: runner_leg.fk_manual_routechoice > routechoice.id [delete: cascade, update: no action]

Table auth_user {
  id integer [primary key]
  name vachar [not null]
  email vachar [not null]
  emailverified boolean [not null, default: false]
  role varchar [not null, default: 'default']
}

Table auth_session {
  id integer [primary key]
  user_id integer [not null]
  active_expires timestamp [not null]
  idle_expires timestamp [not null]
}

Ref: auth_session.user_id > auth_user.id [delete: cascade, update: no action]

Table auth_key {
  id integer [primary key]
  user_id integer [not null]
  primary_key integer  [not null]
  hashed_password vachar
  expires timestamp
}

Ref: auth_key.user_id > auth_user.id [delete: cascade, update: no action]
