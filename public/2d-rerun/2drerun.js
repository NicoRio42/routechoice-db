var tmptmp;
var tmptmp2;
var tmptmp4;
var rtime = new Date(1, 1, 2000, 12, 0, 0);
var timeout = false;
var delta = 250;
var loaddata;
var okprint = 0;
if (typeof ismapantcourse === "undefined") {
  ismapantcourse = 0;
}
if (typeof xclight === "undefined") {
  xclight = 0;
}
(function happyJS(j) {
  function g(m) {
    return "".trim ? m.val().trim() : j.trim(m.val());
  }
  j.fn.isHappy = function f(p) {
    var v = [],
      E;
    var D = false;
    function o(F) {
      return !!(F && F.constructor && F.call && F.apply);
    }
    function z(F) {
      var G = (p.classes && p.classes.message) || "unhappyMessage";
      return j(
        '<span id="' +
          F.id +
          '" class="' +
          G +
          '" role="alert">' +
          F.message +
          "</span>"
      );
    }
    function q(F) {
      if (o(p.errorTemplate)) {
        return p.errorTemplate(F);
      }
      return z(F);
    }
    function u() {
      var G, F;
      var H = false;
      for (G = 0, F = v.length; G < F; G += 1) {
        if (!v[G].testValid(true)) {
          H = true;
        }
      }
      if (H) {
        if (o(p.unHappy)) {
          p.unHappy();
        }
        return false;
      } else {
        if (p.testMode) {
          if (o(p.happy)) {
            p.happy();
          }
          if (window.console) {
            console.warn("would have submitted");
          }
          return false;
        }
      }
      if (o(p.happy)) {
        p.happy();
      }
    }
    function B() {
      D = false;
    }
    function m() {
      D = true;
      j(window).bind("mouseup", B);
    }
    function A(I, F) {
      var K = j(F);
      var G = { message: I.message || "", id: F.slice(1) + "_unhappy" };
      var M = j(G.id).length > 0 ? j(G.id) : q(G);
      var H = function H() {
        if (!D) {
          K.testValid();
        } else {
          j(window).bind("mouseup", K.testValid.bind(this));
        }
      };
      v.push(K);
      K.testValid = function J(T) {
        var O, R, X;
        var N = j(this);
        var Q = (I.errorTarget && j(I.errorTarget)) || N;
        var U = false;
        var S = !!N.get(0).attributes.getNamedItem("required") || I.required;
        var W = K.attr("type") === "password";
        var Y = o(I.arg) ? I.arg() : I.arg;
        var V = (p.classes && p.classes.field) || "unhappy";
        if (N.length > 1) {
          O = [];
          N.each(function (Z, aa) {
            O.push(j(aa).val());
          });
          O = O.join(",");
        } else {
          if (o(I.clean)) {
            O = I.clean(N.val());
          } else {
            if ((!W && typeof I.trim === "undefined") || I.trim) {
              O = g(N);
            } else {
              O = N.val();
            }
          }
          N.val(O);
        }
        R = (O.length > 0 || S === "sometimes") && o(I.test);
        if (T === true && S === true && O.length === 0) {
          U = true;
        } else {
          if (R) {
            U = !I.test(O, Y);
          }
        }
        if (U) {
          Q.addClass(V).after(M);
          return false;
        } else {
          X = M.get(0);
          if (X.parentNode) {
            X.parentNode.removeChild(X);
          }
          Q.removeClass(V);
          return true;
        }
      };
      K.bind(I.when || p.when || "blur", H);
    }
    for (E in p.fields) {
      A(p.fields[E], E);
    }
    j(p.submitButton || this).bind("mousedown", m);
    if (p.submitButton) {
      j(p.submitButton).click(u);
    } else {
      this.bind("submit", u);
    }
    return this;
  };
})(this.jQuery || this.Zepto);
var happy = {
  date: function (f) {
    return /^(?:0[1-9]|1[0-2])\/(?:0[1-9]|[12][0-9]|3[01])\/(?:\d{4})/.test(f);
  },
  pace: function (f) {
    return /^\d\d:\d\d$/.test(f);
  },
  email: function (f) {
    return /^(?:\w+\.?\+?)*\w+@(?:\w+\.)+\w+$/.test(f);
  },
  equal: function (g, f) {
    return g == f;
  },
};
var takentxtypos = new Array();
var chartdata = null;
var tmpdata;
var help = new Array();
help.showvariants_button =
  "Show distinct routechoices. Default: Distinct routechoices are defined by at least 25% of the route being more than 50 meters apart. You can change this in the settings with keyboard press 2.";
help.autoanalysis_button =
  "Calculate autOanalysis for two different routes. Default: Same routechoices are defined by 10 meters difference. Max length of parts with equal routes is set to 30 seconds. You can change this in the settings with keyboard press 2.";
if (typeof xc == "undefined") {
  xc = 0;
}
if (typeof privatemaps == "undefined") {
  privatemaps = 0;
}
window.requestAnimFrame = (function () {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (g, f) {
      window.setTimeout(g, 1000 / 60);
    }
  );
})();
function Canvas(g) {
  var f = this;
  this.tmp = null;
  this.id = g;
  this.canvaselement = document.getElementById(g);
  this.context = null;
  this.width = null;
  this.height = null;
  this.zoomfactor = 1;
  this.cx = null;
  this.cy = null;
  this.ZoomInProgress = 0;
  this.PanInProgress = 0;
  this.MoveInProgress = 0;
  this.font = "sans-serif";
  this.markertextoffset_x = 16;
  this.markertextoffset_y = 16;
  this.outlinetxtsize = 20;
  this.outlinefont = "sans-serif";
  this.mousemovessinceclick = 0;
  this.markertexttype = 1;
  this.outerborder = 30;
  this.viewportw = null;
  this.viewporth = null;
  this.use_rotate = 0;
  this.mouse_rotate = 0;
  this.rotate_angle = 0;
  this.register_clicks = -1;
  this.use_translated_coordinates = 1;
  this.starttime_mousemove = null;
  this.distance_px_mousemove = 0;
  this.dragged = null;
  this.dragStart = null;
  this.dragStart_down = null;
  this.dragged_x = null;
  this.dragged_y = null;
  this.drawpoint_lastx = 0;
  this.drawpoint_lasty = 0;
  this.drawpoint_lasttime = 0;
  this.initialize = function (m, j, p, o) {
    this.context = this.canvaselement.getContext("2d");
    context = this.context;
    if (!context.setLineDash) {
      context.setLineDash = function () {};
    }
    this.width = m;
    this.height = j;
    this.viewportw = m;
    this.viewporth = j;
    this.canvaselement.width = m;
    this.canvaselement.height = j;
    this.cx = p / 2;
    this.cy = o / 2;
    this.zoomfactor = 1;
    this.setFont(this.font, 18, 1, "000000", 1);
    this.writeText("Loading map - please wait!", 50, 50);
    this.setLineStyle("FF0000", 0.75, 5);
    this.add_zoom_and_rotate();
  };
  this.erase = function () {
    this.context.clearRect(0, 0, this.width, this.height);
  };
  this.onmousedown = function (j, o, m) {};
  this.onmouseup = function (m, p, o, j) {};
  this.onmousemove = function (j, q, o, m, p) {};
  this.onmouseclick = function (j, o, m) {};
  this.erase_all = function () {
    if (f.use_rotate) {
      var j = this.width;
      if (this.height > j) {
        j = this.height;
      }
      this.context.clearRect(-2 * j, -2 * j, 4 * j, 4 * j);
    } else {
      this.context.clearRect(0, 0, this.width, this.height);
    }
  };
  this.drawImage = function (m, v, u, z, o, B, A, j, q, p) {
    this.context.globalAlpha = p;
    this.context.drawImage(m, v, u, z, o, B, A, j, q);
    this.context.globalAlpha = 1;
  };
  this.drawImage_map = function (m, v, u, z, o, B, A, j, q, p) {
    if (mapviewer.settings.sketchmode) {
      mapviewer.sketchmode_draw(m, v, u, z, o, B, A, j, q, p);
    } else {
      f.drawImage(m, v, u, z, o, B, A, j, q, p);
    }
  };
  this.drawPrintBox = function () {
    var I = mapviewer.settings.printbox;
    var j = I;
    var H = mapviewer.canvas.rotate_angle;
    var z = I[2] - I[0];
    var D = I[3] - I[1];
    var J = I[0];
    var q = I[1];
    var F = J + z * Math.cos(H);
    var p = q - z * Math.sin(H);
    var B = J + D * Math.sin(H);
    var m = q + D * Math.cos(H);
    var E = B + z * Math.cos(H);
    var o = m - z * Math.sin(H);
    var u = "";
    if (mapviewer.settings.hidecourse) {
      u = "1:" + mapviewer.settings.printscale;
    } else {
      if (mapviewer.settings.courselength > 0) {
        u = u + mapviewer.settings.courselength + " m    ";
      }
      u = u + "1:" + mapviewer.settings.printscale;
      if ($("#infotxt").val()) {
        u = $("#infotxt").val() + "     " + u;
      }
    }
    var G = mapviewer.settings.printboxcolor;
    var K = Math.abs(mapviewer.settings.infotxtfontsize);
    if (mapviewer.settings.infotxtfontsize < 0) {
      mapviewer.canvas.setFont(mapviewer.canvas.font, K, 0, "ffffff", 0.7);
      var v = mapviewer.canvas.context.measureText(u).width * 1.1;
      var A =
        mapviewer.canvas.context.measureText(u).actualBoundingBoxAscent * 1.1;
      A = A * 1.9;
      v = v * 1.25;
      mapviewer.canvas.context.strokeStyle = "rgba(255,255,255,0)";
      mapviewer.canvas.drawRectanglefilledRot(
        J,
        q,
        J + A * Math.sin(H) + v * Math.cos(H),
        q + A * Math.cos(H) - v * Math.sin(H)
      );
    }
    mapviewer.canvas.setLineStyle(
      "ffffff",
      1,
      26 * mapviewer.canvas.zoomfactor,
      "000000",
      1
    );
    mapviewer.canvas.drawLine(J, q, F, p);
    mapviewer.canvas.drawLine(J, q, B, m);
    mapviewer.canvas.drawLine(B, m, E, o);
    mapviewer.canvas.drawLine(E, o, F, p);
    mapviewer.canvas.setLineStyle(
      mapviewer.settings.printboxcolor,
      1,
      mapviewer.settings.printboxlinewidth * mapviewer.canvas.zoomfactor,
      "000000",
      1
    );
    mapviewer.canvas.drawLine(J, q, F, p);
    mapviewer.canvas.drawLine(J, q, B, m);
    mapviewer.canvas.drawLine(B, m, E, o);
    mapviewer.canvas.drawLine(E, o, F, p);
    mapviewer.settings.printbox_rotated = [J, q, F, p, E, o, B, m];
    if (mapviewer.settings.infotxtfontsize) {
      mapviewer.canvas.writeTextOutlined(
        J + K,
        q + K * 1.3,
        G,
        u,
        K * mapviewer.canvas.zoomfactor,
        null,
        null,
        "ffffff",
        "left",
        null,
        1
      );
    }
  };
  this.drawNorthLines = function () {
    var G = mapviewer.map.utm_coords.split("|");
    var v = 500;
    var m = parseInt(G[0]);
    var z = parseInt(G[1]);
    var I = parseInt(G[2]);
    var p = parseInt(G[3]);
    var q = mapviewer.map.proj;
    var j = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
    mapviewer.canvas.setLineStyle(
      "000000",
      1,
      mapviewer.settings.northlineswidth,
      "000000",
      1
    );
    for (var o = m + v; o <= I + v; o = o + v) {
      var E = z;
      var B = proj4(q, j, [o, z]);
      var F = B[0];
      var A = B[1];
      var D = F;
      var u = A - 0.2;
      var J = mapviewer.map.toxy(A, F);
      var H = mapviewer.map.toxy(u, D);
      mapviewer.canvas.drawLine(J.x, J.y, H.x, H.y);
    }
  };
  this.orientnorth = function () {
    var F = mapviewer.map.utm_coords.split("|");
    var v = 500;
    var m = parseInt(F[0]);
    var p = parseInt(F[1]);
    var I = parseInt(F[2]);
    var j = parseInt(F[3]);
    var J = mapviewer.map.proj;
    var z = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
    mapviewer.canvas.setLineStyle("000000", 1, 1, "000000", 1);
    var o = m;
    var A = p;
    var E = proj4(J, z, [o, p]);
    var M = E[0];
    var u = E[1];
    var K = M;
    var q = u - 0.2;
    var D = mapviewer.map.toxy(u, M);
    var B = mapviewer.map.toxy(q, K);
    if (mapviewer.canvas.rotate_angle != 0) {
      var G = mapviewer.canvas.rotate_angle;
      mapviewer.canvas.context.rotate(-G);
    }
    var H = mapviewer.canvas.mouse_rotate;
    mapviewer.canvas.use_rotate = 1;
    mapviewer.canvas.context.rotate(Math.atan(B.x / B.y));
    mapviewer.request_redraw();
  };
  this.drawLine = function (m, q, j, p) {
    var o = this.context;
    if (f.use_translated_coordinates) {
      m = f.width / 2 + (m - f.cx) * f.zoomfactor;
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      q = f.height / 2 + (q - f.cy) * f.zoomfactor;
      p = f.height / 2 + (p - f.cy) * f.zoomfactor;
    }
    o.beginPath();
    o.moveTo(m, q);
    o.lineTo(j, p);
    o.lineJoin = "round";
    o.stroke();
  };
  this.drawXimage = function () {
    f = mapviewer.canvas;
    var B = mapviewer.settings.Ximagepos;
    if (B.length) {
      var p = mapviewer.canvas.rotate_angle;
      var o = B[0];
      var v = B[1];
      var m = B[2];
      var u = B[3];
      if (m > o) {
        var z = mapviewer.settings.ximage.width;
        var q = ((m - o) / z) * f.zoomfactor;
        var j = f.context;
        var A = f.rotate_angle;
        m = j.itransformedPoint_rot(o, v).x;
        u = j.itransformedPoint_rot(o, v).y;
        if (f.use_rotate) {
          j.rotate(-A);
        }
        j.drawImage(
          mapviewer.settings.ximage,
          m,
          u,
          mapviewer.settings.ximage.width * q,
          mapviewer.settings.ximage.height * q
        );
        if (f.use_rotate) {
          j.rotate(A);
        }
      }
    }
  };
  this.drawRectangle = function (m, q, j, p) {
    var o = this.context;
    if (f.use_translated_coordinates) {
      m = f.width / 2 + (m - f.cx) * f.zoomfactor;
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      q = f.height / 2 + (q - f.cy) * f.zoomfactor;
      p = f.height / 2 + (p - f.cy) * f.zoomfactor;
    }
    o.rect(m, q, j - m, p - q);
    o.stroke();
  };
  this.drawRectanglefilled = function (m, q, j, p) {
    var o = this.context;
    if (f.use_translated_coordinates) {
      m = f.width / 2 + (m - f.cx) * f.zoomfactor;
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      q = f.height / 2 + (q - f.cy) * f.zoomfactor;
      p = f.height / 2 + (p - f.cy) * f.zoomfactor;
    }
    o.fillRect(m, q, j - m, p - q);
  };
  this.drawRectangleRot = function (m, q, j, p) {
    if (f.use_translated_coordinates) {
      x1t = f.context.itransformedPoint_rot(m, q).x;
      y1t = f.context.itransformedPoint_rot(m, q).y;
      x2t = f.context.itransformedPoint_rot(j, p).x;
      y2t = f.context.itransformedPoint_rot(j, p).y;
      x1tt = f.context.transformedPoint(x1t, y1t).x;
      y1tt = f.context.transformedPoint(x1t, y1t).y;
      x2tt = f.context.transformedPoint(x1t, y2t).x;
      y2tt = f.context.transformedPoint(x1t, y2t).y;
      x3tt = f.context.transformedPoint(x2t, y2t).x;
      y3tt = f.context.transformedPoint(x2t, y2t).y;
      x4tt = f.context.transformedPoint(x2t, y1t).x;
      y4tt = f.context.transformedPoint(x2t, y1t).y;
    } else {
      x1tt = m;
      y1tt = q;
      x2tt = j;
      y2tt = q;
      x3tt = j;
      y3tt = p;
      x4tt = m;
      y4tt = p;
    }
    var o = f.use_translated_coordinates;
    f.use_translated_coordinates = 1;
    var u = "";
    u += x1tt + "," + y1tt + " ";
    u += x2tt + "," + y2tt + " ";
    u += x3tt + "," + y3tt + " ";
    u += x4tt + "," + y4tt + " ";
    u += x1tt + "," + y1tt + " ";
    f.drawPoly(u);
    f.use_translated_coordinates = o;
  };
  this.drawRectanglefilledRot = function (m, q, j, p) {
    if (f.use_translated_coordinates) {
      x1t = f.context.itransformedPoint_rot(m, q).x;
      y1t = f.context.itransformedPoint_rot(m, q).y;
      x2t = f.context.itransformedPoint_rot(j, p).x;
      y2t = f.context.itransformedPoint_rot(j, p).y;
      x1tt = f.context.transformedPoint(x1t, y1t).x;
      y1tt = f.context.transformedPoint(x1t, y1t).y;
      x2tt = f.context.transformedPoint(x1t, y2t).x;
      y2tt = f.context.transformedPoint(x1t, y2t).y;
      x3tt = f.context.transformedPoint(x2t, y2t).x;
      y3tt = f.context.transformedPoint(x2t, y2t).y;
      x4tt = f.context.transformedPoint(x2t, y1t).x;
      y4tt = f.context.transformedPoint(x2t, y1t).y;
    } else {
      x1tt = m;
      y1tt = q;
      x2tt = j;
      y2tt = q;
      x3tt = j;
      y3tt = p;
      x4tt = m;
      y4tt = p;
    }
    var o = f.use_translated_coordinates;
    f.use_translated_coordinates = 1;
    var u = "";
    u += x1tt + "," + y1tt + " ";
    u += x2tt + "," + y2tt + " ";
    u += x3tt + "," + y3tt + " ";
    u += x4tt + "," + y4tt + " ";
    u += x1tt + "," + y1tt + " ";
    f.drawPoly(u);
    f.context.fill();
    f.use_translated_coordinates = o;
  };
  this.drawPolyCircle = function (p) {
    this.drawPoly(p);
    var o = this.context;
    var j = p.split(" ");
    for (var m = 0; m < j.length; m++) {
      var q = j[m].split(",");
      f.drawCircle(q[0], q[1], 4);
    }
  };
  this.drawPoly = function (j) {
    var o = this.context;
    var D = j.split(" ");
    var m = 0;
    if (!mapviewer.settings.makeprettylines) {
      for (var v = 0; v < D.length; v++) {
        var I = D[v].split(",");
        if (f.use_translated_coordinates) {
          I[0] = f.width / 2 + (I[0] - f.cx) * f.zoomfactor;
          I[1] = f.height / 2 + (I[1] - f.cy) * f.zoomfactor;
        }
        if (
          (I[0] > -f.outerborder &&
            I[1] > -f.outerborder &&
            I[0] < f.width + f.outerborder &&
            I[1] < f.height + f.outerborder) ||
          f.use_rotate
        ) {
          if (m == 0) {
            o.beginPath();
            o.moveTo(I[0], I[1]);
            m++;
          } else {
            o.lineTo(I[0], I[1]);
            m++;
          }
        } else {
          if (m > 1) {
            o.lineJoin = "round";
            o.stroke();
          }
          m = 0;
        }
      }
    } else {
      var u = 0;
      var p = 0;
      var q = 0;
      var A = new Array();
      var F = null;
      var E = null;
      var B = null;
      var H;
      var G = 0;
      for (var v = 0; v < D.length; v++) {
        I = D[v].split(",");
        G = 0;
        H = null;
        if (m == 0) {
          o.beginPath();
          u = I[0];
          p = I[1];
          if (f.use_translated_coordinates) {
            I[0] = f.width / 2 + (I[0] - f.cx) * f.zoomfactor;
            I[1] = f.height / 2 + (I[1] - f.cy) * f.zoomfactor;
          }
          o.moveTo(I[0], I[1]);
          m++;
          q = 0;
        } else {
          var z = Math.sqrt((I[0] - u) * (I[0] - u) + (I[1] - p) * (I[1] - p));
          u = I[0];
          p = I[1];
          if (q == 0) {
            F = I;
            if (z > mapviewer.settings.minbezierlength) {
              G = 1;
            }
          } else {
            if (z <= mapviewer.settings.minbezierlength && q == 1) {
              E = I;
            } else {
              if (z <= mapviewer.settings.minbezierlength && q == 2) {
                B = I;
                G = 1;
              } else {
                G = 1;
                H = I;
              }
            }
          }
          q++;
          if (G) {
            if (F) {
              F[0] = f.width / 2 + (F[0] - f.cx) * f.zoomfactor;
              F[1] = f.height / 2 + (F[1] - f.cy) * f.zoomfactor;
            }
            if (E) {
              E[0] = f.width / 2 + (E[0] - f.cx) * f.zoomfactor;
              E[1] = f.height / 2 + (E[1] - f.cy) * f.zoomfactor;
            }
            if (B) {
              B[0] = f.width / 2 + (B[0] - f.cx) * f.zoomfactor;
              B[1] = f.height / 2 + (B[1] - f.cy) * f.zoomfactor;
            }
            if (F && E && B) {
              o.bezierCurveTo(F[0], F[1], E[0], E[1], B[0], B[1]);
              m = m + 3;
            } else {
              if (F && E) {
                o.quadraticCurveTo(F[0], F[1], E[0], E[1]);
                m = m + 2;
              } else {
                if (F) {
                  o.lineTo(F[0], F[1]);
                  m++;
                }
              }
            }
            if (q == 3 || q == 1) {
              q = 0;
            }
            F = null;
            E = null;
            B = null;
            if (H) {
              F = H;
              q = 1;
            }
          }
        }
      }
    }
    if (m > 1) {
      o.lineJoin = "round";
      o.stroke();
    }
  };
  this.drawPolyCol = function (m, v) {
    var p = this.context;
    var z = m.split(" ");
    var j = v.split(" ");
    var o = 0;
    var q = "";
    for (var u = 0; u < z.length; u++) {
      var B = z[u].split(",");
      var A = j[u];
      if (f.use_translated_coordinates) {
        B[0] = f.width / 2 + (B[0] - f.cx) * f.zoomfactor;
        B[1] = f.height / 2 + (B[1] - f.cy) * f.zoomfactor;
      }
      if (
        (B[0] > -f.outerborder &&
          B[1] > -f.outerborder &&
          B[0] < f.width + f.outerborder &&
          B[1] < f.height + f.outerborder) ||
        f.use_rotate
      ) {
        if (o == 0) {
          p.strokeStyle = A;
          p.beginPath();
          p.moveTo(B[0], B[1]);
          o++;
        } else {
          if (A != q) {
            p.lineTo(B[0], B[1]);
            p.lineJoin = "round";
            p.stroke();
            o = 0;
            p.beginPath();
            p.moveTo(B[0], B[1]);
            p.strokeStyle = A;
          } else {
            p.lineTo(B[0], B[1]);
          }
          o++;
        }
      } else {
        if (o > 1) {
          p.lineJoin = "round";
          p.stroke();
        }
        o = 0;
      }
    }
    if (o > 1) {
      p.lineJoin = "round";
      p.stroke();
    }
  };
  this.drawPolyColWidth = function (m, z, u) {
    var p = this.context;
    var A = m.split(" ");
    var j = z.split(" ");
    var F = u.split(" ");
    var o = 0;
    var q = "";
    for (var v = 0; v < A.length; v++) {
      var E = A[v].split(",");
      var D = j[v];
      var B = F[v];
      if (f.use_translated_coordinates) {
        E[0] = f.width / 2 + (E[0] - f.cx) * f.zoomfactor;
        E[1] = f.height / 2 + (E[1] - f.cy) * f.zoomfactor;
      }
      if (
        (E[0] > -f.outerborder &&
          E[1] > -f.outerborder &&
          E[0] < f.width + f.outerborder &&
          E[1] < f.height + f.outerborder) ||
        f.use_rotate
      ) {
        if (o == 0) {
          p.strokeStyle = D;
          p.lineWidth = B;
          p.beginPath();
          p.moveTo(E[0], E[1]);
          o++;
        } else {
          if (D != q) {
            p.lineTo(E[0], E[1]);
            p.lineJoin = "round";
            p.stroke();
            o = 0;
            p.beginPath();
            p.moveTo(E[0], E[1]);
            p.strokeStyle = D;
            p.lineWidth = B;
          } else {
            p.lineTo(E[0], E[1]);
          }
          o++;
        }
      } else {
        if (o > 1) {
          p.lineJoin = "round";
          p.stroke();
        }
        o = 0;
      }
    }
    if (o > 1) {
      p.lineJoin = "round";
      p.stroke();
    }
  };
  this.drawPolys = function (A) {
    var u = this.context;
    var o = 0;
    u.beginPath();
    var v = A.split("|");
    for (var q = 0; q < v.length; q++) {
      var j = v[q];
      var B = j.split(" ");
      var m = 0;
      for (var z = 0; z < B.length; z++) {
        var D = B[z].split(",");
        if (f.use_translated_coordinates) {
          D[0] = f.width / 2 + (D[0] - f.cx) * f.zoomfactor;
          D[1] = f.height / 2 + (D[1] - f.cy) * f.zoomfactor;
        }
        if (
          (D[0] > -f.outerborder &&
            D[1] > -f.outerborder &&
            D[0] < f.width + f.outerborder &&
            D[1] < f.height + f.outerborder) ||
          f.use_rotate
        ) {
          if (m == 0) {
            u.moveTo(D[0], D[1]);
            m++;
          } else {
            u.lineTo(D[0], D[1]);
            m++;
          }
        } else {
          if (m > 1) {
            o = o + m;
          }
          m = 0;
        }
      }
      if (m > 1) {
        o = o + m;
      }
      m = 0;
    }
    if (o > 1) {
      u.lineJoin = "round";
      u.stroke();
    }
  };
  this.drawColorBox = function (v, q, m, F, u, p) {
    var o = v;
    var D = m;
    var B = q;
    var z = F;
    this.setLineStyle("000000", 1, 1, u, 1);
    if (f.use_translated_coordinates) {
      var j = o + D;
      var A = B + z;
      o = f.width / 2 + (o - f.cx) * f.zoomfactor;
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      B = f.height / 2 + (B - f.cy) * f.zoomfactor;
      A = f.height / 2 + (A - f.cy) * f.zoomfactor;
      D = j - o;
      z = A - B;
    }
    var E = f.rotate_angle;
    if (f.use_rotate && !p) {
      context.rotate(-E);
    }
    context.fillRect(o, B, D, z);
    context.strokeRect(o, B, D, z);
    if (f.use_rotate && !p) {
      context.rotate(E);
    }
  };
  this.drawWhiteBackgroundBox = function (o, q, m, p, j) {
    context.fillStyle = "rgba(255,255,255," + j + ")";
    var u = f.rotate_angle;
    if (f.use_rotate) {
      context.rotate(-u);
    }
    context.fillRect(o, q, m, p);
    if (f.use_rotate) {
      context.rotate(u);
    }
  };
  this.drawCircle = function (q, o, j, p) {
    var m = this.context;
    m.beginPath();
    if (f.use_translated_coordinates) {
      q = f.width / 2 + (q - f.cx) * f.zoomfactor;
      o = f.height / 2 + (o - f.cy) * f.zoomfactor;
      j = j * f.zoomfactor;
    }
    if (
      (q > -f.outerborder &&
        o > -f.outerborder &&
        q < f.width + f.outerborder &&
        o < f.height + f.outerborder) ||
      f.use_rotate
    ) {
      m.arc(q, o, j, 0, Math.PI * 2, true);
      m.closePath();
      if (p) {
        m.fill();
      }
      m.stroke();
    }
  };
  this.drawPac = function (v, u, z, q, A) {
    if (q == null) {
      q = -90;
    }
    var m = this.context;
    m.beginPath();
    if (f.use_translated_coordinates) {
      v = f.width / 2 + (v - f.cx) * f.zoomfactor;
      u = f.height / 2 + (u - f.cy) * f.zoomfactor;
      z = z * f.zoomfactor;
    }
    if (
      (v > -f.outerborder &&
        u > -f.outerborder &&
        v < f.width + f.outerborder &&
        u < f.height + f.outerborder) ||
      f.use_rotate
    ) {
      var o = new Date().getTime();
      var p = Array(
        10,
        20,
        30,
        40,
        50,
        60,
        70,
        80,
        90,
        100,
        110,
        120,
        130,
        140,
        150,
        160,
        150,
        140,
        130,
        120,
        110,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20
      );
      var j = Math.floor((o / 1000 - Math.floor(o / 1000)) * p.length);
      var A = p[j];
      da = Math.PI / 2 - ((A / 2) * Math.PI) / 180;
      m.arc(
        v,
        u,
        z,
        0 + (q / 180) * Math.PI - da,
        Math.PI + (q / 180) * Math.PI + da,
        false
      );
      m.stroke();
    }
  };
  this.drawMarker = function (p, o, j) {
    var m = this.context;
    if (f.use_translated_coordinates) {
      p = f.width / 2 + (p - f.cx) * f.zoomfactor;
      o = f.height / 2 + (o - f.cy) * f.zoomfactor;
    }
    if (
      (p > -f.outerborder &&
        o > -f.outerborder &&
        p < f.width + f.outerborder &&
        o < f.height + f.outerborder) ||
      f.use_rotate
    ) {
      m.beginPath();
      m.arc(p, o, j, 0, Math.PI * 2, true);
      m.closePath();
      m.fill();
      m.stroke();
    }
  };
  this.drawTriangle = function (o, p, j, m) {
    if (f.use_translated_coordinates) {
      var o = f.width / 2 + (o - f.cx) * f.zoomfactor;
      var p = f.height / 2 + (p - f.cy) * f.zoomfactor;
      j = j * f.zoomfactor;
    }
    dx = j * 1 * 1.1;
    dy = j * 0.866 * 1.1;
    x1 = o * 1 - dx;
    y1 = p * 1 - dy;
    x2 = o * 1 + dx;
    y2 = p * 1 - dy;
    x3 = o;
    y3 = p * 1 + dy;
    m = (-m * 3.1415926) / 180;
    rx1 = Math.cos(m) * (x1 * 1 - o) - Math.sin(m) * (y1 * 1 - p) + o * 1;
    ry1 = Math.sin(m) * (x1 * 1 - o) + Math.cos(m) * (y1 * 1 - p) + p * 1;
    rx2 = Math.cos(m) * (x2 * 1 - o) - Math.sin(m) * (y2 * 1 - p) + o * 1;
    ry2 = Math.sin(m) * (x2 * 1 - o) + Math.cos(m) * (y2 * 1 - p) + p * 1;
    rx3 = Math.cos(m) * (x3 * 1 - o) - Math.sin(m) * (y3 * 1 - p) + o * 1;
    ry3 = Math.sin(m) * (x3 * 1 - o) + Math.cos(m) * (y3 * 1 - p) + p * 1;
    context.beginPath();
    context.moveTo(rx1, ry1);
    context.lineTo(rx2, ry2);
    context.lineTo(rx3, ry3);
    context.lineTo(rx1, ry1);
    context.closePath();
    context.stroke();
  };
  this.drawArrow = function (o, p, j, m) {
    if (f.use_translated_coordinates) {
      var o = f.width / 2 + (o - f.cx) * f.zoomfactor;
      var p = f.height / 2 + (p - f.cy) * f.zoomfactor;
      j = j * f.zoomfactor;
    }
    dx = j * 1 * 1.1;
    dy = j * 0.866 * 1.1;
    x1 = o * 1 - dx;
    y1 = p * 1 - dy;
    x2 = o * 1 + dx;
    y2 = p * 1 - dy;
    x3 = o;
    y3 = p * 1 + dy;
    m = (-m * 3.1415926) / 180;
    rx1 = Math.cos(m) * (x1 * 1 - o) - Math.sin(m) * (y1 * 1 - p) + o * 1;
    ry1 = Math.sin(m) * (x1 * 1 - o) + Math.cos(m) * (y1 * 1 - p) + p * 1;
    rx2 = Math.cos(m) * (x2 * 1 - o) - Math.sin(m) * (y2 * 1 - p) + o * 1;
    ry2 = Math.sin(m) * (x2 * 1 - o) + Math.cos(m) * (y2 * 1 - p) + p * 1;
    rx3 = Math.cos(m) * (x3 * 1 - o) - Math.sin(m) * (y3 * 1 - p) + o * 1;
    ry3 = Math.sin(m) * (x3 * 1 - o) + Math.cos(m) * (y3 * 1 - p) + p * 1;
    context.beginPath();
    context.moveTo(rx1, ry1);
    context.lineTo(rx3, ry3);
    context.lineTo(rx2, ry2);
    context.stroke();
  };
  this.find_viewxy_from_canvasxy = function (j, q) {
    var p = f.width / 2 + (j - f.cx) * f.zoomfactor;
    var o = f.height / 2 + (q - f.cy) * f.zoomfactor;
    var m = new Object();
    m.x = p;
    m.y = o;
    return m;
  };
  this.tmp_move_mapxy_to_center = function (D, v) {
    if (f.use_rotate) {
      move_x = f.width / 2;
      move_y = f.height / 2;
      var o = f.rotate_angle;
      var A = f.width / 2;
      var z = f.height / 2;
      var m = A * Math.cos(o) + z * Math.sin(o);
      var B = -A * Math.sin(o) + z * Math.cos(o);
      var j = f.cx + (1 / f.zoomfactor) * (m - f.width / 2);
      var u = f.cy + (1 / f.zoomfactor) * (B - f.height / 2);
      var q = D;
      var p = v;
      var m = move_x * Math.cos(o) + move_y * Math.sin(o);
      var B = -move_x * Math.sin(o) + move_y * Math.cos(o);
      var j = f.cx + (1 / f.zoomfactor) * (m - f.width / 2);
      var u = f.cy + (1 / f.zoomfactor) * (B - f.height / 2);
      f.cx = f.cx - j;
      f.cy = f.cy - u;
      mx = q * Math.cos(o) - p * Math.sin(o);
      my = q * Math.sin(o) + p * Math.cos(o);
      f.context.translate(-mx * f.zoomfactor, -my * f.zoomfactor);
    }
  };
  this.find_mapcenter_xy = function () {
    var p = f.rotate_angle;
    var A = f.width / 2;
    var v = f.height / 2;
    var o = A * Math.cos(p) + v * Math.sin(p);
    var B = -A * Math.sin(p) + v * Math.cos(p);
    var m = f.cx + (1 / f.zoomfactor) * (o - f.width / 2);
    var z = f.cy + (1 / f.zoomfactor) * (B - f.height / 2);
    var u = m;
    var q = z;
    var j = new Object();
    j.x = u;
    j.y = q;
    return j;
  };
  this.screenxy_to_mapxy_withrotate = function (A, v) {
    var p = f.rotate_angle;
    var o = A * Math.cos(p) + v * Math.sin(p);
    var B = -A * Math.sin(p) + v * Math.cos(p);
    var m = f.cx + (1 / f.zoomfactor) * (o - f.width / 2);
    var z = f.cy + (1 / f.zoomfactor) * (B - f.height / 2);
    var u = m;
    var q = z;
    var j = new Object();
    j.x = u;
    j.y = q;
    return j;
  };
  this.move_canvasxy_to_origin = function (H, B) {
    if (f.use_rotate) {
      move_x = f.width / 2;
      move_y = f.height / 2;
      var o = f.width;
      if (mapviewer.settings.menu_isvisible) {
        o = o - $("#" + mapviewer.menudiv).width();
      }
      var G = f.height;
      var p = f.rotate_angle;
      var F = f.width / 2;
      var D = f.height / 2;
      var m = F * Math.cos(p) + D * Math.sin(p);
      var E = -F * Math.sin(p) + D * Math.cos(p);
      var j = f.cx + (1 / f.zoomfactor) * (m - f.width / 2);
      var A = f.cy + (1 / f.zoomfactor) * (E - f.height / 2);
      var u = H + f.width / 2 / f.zoomfactor;
      var q = B + f.height / 2 / f.zoomfactor;
      var m = move_x * Math.cos(p) + move_y * Math.sin(p);
      var E = -move_x * Math.sin(p) + move_y * Math.cos(p);
      var j = f.cx + (1 / f.zoomfactor) * (m - f.width / 2);
      var A = f.cy + (1 / f.zoomfactor) * (E - f.height / 2);
      f.cx = f.cx - j;
      f.cy = f.cy - A;
      mx = u * Math.cos(p) - q * Math.sin(p);
      my = u * Math.sin(p) + q * Math.cos(p);
      f.context.translate(-mx * f.zoomfactor, -my * f.zoomfactor);
    } else {
      var z = -(f.width / 2 + (H - f.cx) * f.zoomfactor);
      var v = -(f.height / 2 + (B - f.cy) * f.zoomfactor);
      this.context.translate(z, v);
    }
  };
  this.fillRect = function (m, p, j, o) {
    if (f.use_translated_coordinates) {
      m = f.width / 2 + (m - f.cx) * f.zoomfactor;
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      p = f.height / 2 + (p - f.cy) * f.zoomfactor;
      o = f.height / 2 + (o - f.cy) * f.zoomfactor;
    }
    this.context.fillRect(m, p, j, o);
  };
  this.writeText = function (m, j, o) {
    if (f.use_translated_coordinates) {
      j = f.width / 2 + (j - f.cx) * f.zoomfactor;
      o = f.height / 2 + (o - f.cy) * f.zoomfactor;
    }
    if (
      (j > -f.outerborder &&
        o > -f.outerborder &&
        j < f.width + f.outerborder &&
        o < f.height + f.outerborder) ||
      f.use_rotate
    ) {
      this.context.strokeText(m, j, o);
    }
  };
  this.writeTextabs = function (m, j, o) {
    f.use_translated_coordinates = 0;
    this.writeTextOutlined(j, o, "#f00", m);
    f.use_translated_coordinates = 1;
  };
  this.setFont = function (q, D, B, u, v, o) {
    var m;
    if (!o) {
      m = this.context;
    } else {
      m = o;
    }
    var p = "";
    if (B) {
      p = p + "bold ";
    }
    p = p + D + "px ";
    p = p + q;
    this.context.font = p;
    var j = parseInt(u.substr(0, 2), 16);
    var z = parseInt(u.substr(2, 2), 16);
    var A = parseInt(u.substr(4, 2), 16);
    m.fillStyle = "rgba(" + j + "," + z + "," + A + "," + v + ")";
    m.strokeStyle = "rgba(1,1,1,1)";
  };
  this.setLineStyle = function (u, v, B, q, m, p) {
    var o;
    if (!p) {
      o = this.context;
    } else {
      o = p;
    }
    if (!u) {
      u = "777777";
    }
    var j = parseInt(u.substr(0, 2), 16);
    var z = parseInt(u.substr(2, 2), 16);
    var A = parseInt(u.substr(4, 2), 16);
    o.strokeStyle = "rgba(" + j + "," + z + "," + A + "," + v + ")";
    if (q) {
      var j = parseInt(q.substr(0, 2), 16);
      var z = parseInt(q.substr(2, 2), 16);
      var A = parseInt(q.substr(4, 2), 16);
      o.fillStyle = "rgba(" + j + "," + z + "," + A + "," + m + ")";
    } else {
      o.fillStyle = "rgba(0,0,0,1)";
    }
    o.lineWidth = B;
  };
  this.add_zoom_and_rotate = function () {
    if (typeof Hammer === "undefined") {
    } else {
      this.hammertime = new Hammer.Manager(this.canvaselement);
      var u = new Hammer.Pinch();
      var q = new Hammer.Press();
      var j = new Hammer.Tap();
      this.hammertime.add([u, j, q]);
      this.hammertime.on("pinchstart pinchend pinchmove", function (v) {
        if (v.type == "pinchstart") {
          f.ZoomInProgress = 1;
          f.prevScale = 1;
          window.startRotation = v.rotation;
          window.startScale = v.scale;
          f.request_redraw();
        }
        if (v.type == "pinchend") {
          f.ZoomInProgress = 0;
          f.request_redraw();
        }
        if (v.type == "pinchmove") {
          f.ZoomInProgress = 1;
          dozoom = v.scale / f.prevScale;
          f.prevScale = v.scale;
          f.zoom(dozoom * 1, "touch");
        }
      });
      this.hammertime.on("tap", function (v) {
        if (!f.register_clicks) {
          f.register_clicks = 0;
          f.click(v);
        }
      });
    }
    this.trackTransforms();
    var p = this.canvaselement.width / 2,
      o = this.canvaselement.height / 2;
    bindEvent(
      this.canvaselement,
      "touchstart",
      function (v) {
        v = v.targetTouches[0];
        f.mousedown(v, "touch");
      },
      false
    );
    bindEvent(
      this.canvaselement,
      "touchmove",
      function (v) {
        v = v.targetTouches[0];
        f.mousemove(v, "touch");
      },
      false
    );
    bindEvent(
      this.canvaselement,
      "touchend",
      function (v) {
        v = v.targetTouches[0];
        if (!v) {
          v = new Object();
        }
        f.mouseup_canvas(v);
      },
      false
    );
    bindEvent(this.canvaselement, "click", function (v) {
      if (f.register_clicks != 0) {
        f.click(v);
      }
      f.register_clicks = 1;
    });
    bindEvent(
      this.canvaselement,
      "mousedown",
      function (v) {
        f.mousedown(v, "mouse");
      },
      false
    );
    bindEvent(
      document,
      "mousemove",
      function (v) {
        f.mousemove(v, "mouse");
      },
      false
    );
    bindEvent(document, "mouseup", function (v) {
      f.mouseup_doc(v);
    });
    bindEvent(
      this.canvaselement,
      "mouseup",
      function (v) {
        f.mouseup_canvas(v);
      },
      false
    );
    this.click = function (A) {
      document.body.style.mozUserSelect =
        document.body.style.webkitUserSelect =
        document.body.style.userSelect =
          "none";
      if (!f.dragged) {
        var B = f.context.transformedPoint(p, o);
        var v = B.x;
        var D = B.y;
        var z = 0;
        if (A.shiftKey) {
          z = 1;
        }
        if (A.ctrlKey || A.metaKey) {
          z = 2;
        }
        if (A.altKey) {
          z = 3;
        }
        if (f.shift_mode) {
          z = 1;
        } else {
          if (f.ctrl_mode) {
            z = 2;
          } else {
            if (f.alt_mode) {
              z = 3;
            }
          }
        }
        f.onmouseclick(v, D, z);
      } else {
        var B = f.context.transformedPoint(p, o);
        var v = B.x;
        var D = B.y;
      }
    };
    this.mousedown = function (A, B) {
      document.body.style.mozUserSelect =
        document.body.style.webkitUserSelect =
        document.body.style.userSelect =
          "none";
      f.starttime_mousemove = new Date().getTime();
      f.distance_px_mousemove = 0;
      f.mousemovessinceclick = 0;
      f.PanInProgress = 1;
      if (B == "mouse") {
        p = A.offsetX || A.pageX - f.canvaselement.offsetLeft;
        o = A.offsetY || A.pageY - f.canvaselement.offsetTop;
      } else {
        if (B == "touch") {
          p = A.offsetX || A.pageX - f.canvaselement.offsetLeft;
          o = A.offsetY || A.pageY - f.canvaselement.offsetTop;
        }
      }
      f.dragStart = new Object();
      f.dragStart.x = p;
      f.dragStart.y = o;
      f.dragStart_down = f.dragStart;
      var z = 0;
      if (A.shiftKey) {
        z = 1;
      }
      if (A.ctrlKey || A.metaKey) {
        z = 2;
      }
      if (A.altKey) {
        z = 3;
      }
      if (A.altKey && A.shiftKey) {
        z = 4;
      }
      if (A.altKey && (A.ctrlKey || A.metaKey)) {
        z = 5;
      }
      if (f.shift_mode) {
        z = 1;
      } else {
        if (f.ctrl_mode) {
          z = 2;
        } else {
          if (f.alt_mode) {
            z = 3;
          }
        }
      }
      if (mapviewer.waitfordrag == 1) {
        var D = f.context.transformedPoint(
          A.pageX - f.canvaselement.offsetLeft,
          A.pageY - f.canvaselement.offsetTop
        );
        var v = D.x;
        var E = D.y;
        f.onmousedown(v, E, z);
        mapviewer.waitfordrag_dragging = 1;
        return;
      }
      if (z == 1 && mapviewer.settings.sketchmode) {
        mapviewer.settings.is_sketching = 1;
        mapviewer.updateinfobottomdiv();
      }
      if (mapviewer.settings.is_sketching) {
        mapviewer.settings.is_sketching_mousedown = 1;
        var D = f.context.transformedPoint(
          A.pageX - f.canvaselement.offsetLeft,
          A.pageY - f.canvaselement.offsetTop
        );
        mapviewer.sketchmode_drawpt(D);
        f.request_redraw();
        f.onmousedown(v, E, z);
        return;
      }
      if (mapviewer.settings.calibrationmode) {
        z = 1;
      }
      if (z) {
        var D = f.context.transformedPoint(
          A.pageX - f.canvaselement.offsetLeft,
          A.pageY - f.canvaselement.offsetTop
        );
        var v = D.x;
        var E = D.y;
        f.onmousedown(v, E, z);
      }
      f.dragged = false;
    };
    this.mousemove = function (G, B) {
      var A = 5;
      var F = 100;
      var z = new Date().getTime();
      f.mousemovessinceclick++;
      if (f.mousemovessinceclick > 1) {
        if (B == "mouse") {
          p = G.clientX - f.canvaselement.offsetLeft;
          o = G.clientY - f.canvaselement.offsetTop;
        } else {
          if (B == "touch") {
            p = G.offsetX || G.pageX - f.canvaselement.offsetLeft;
            o = G.offsetY || G.pageY - f.canvaselement.offsetTop;
          }
        }
        if (mapviewer.waitfordrag == 1) {
          if (mapviewer.waitfordrag_dragging) {
            var J = f.context.transformedPoint(p, o);
            var E = J.x;
            var D = J.y;
            mapviewer.waitfordrag_dragpoint = J;
            mapviewer.request_redraw();
          }
          return;
        }
        if (mapviewer.settings.is_sketching) {
          if (mapviewer.settings.is_sketching_mousedown) {
            var J = f.context.transformedPoint(
              G.pageX - f.canvaselement.offsetLeft,
              G.pageY - f.canvaselement.offsetTop
            );
            mapviewer.sketchmode_drawpt(J);
            f.request_redraw();
          }
          return;
        }
        f.dragged = true;
        if (f.dragStart) {
          var J = new Object();
          J.x = p;
          J.y = o;
          var v = 0;
          if (G.shiftKey) {
            v = 1;
          }
          if (G.ctrlKey || G.metaKey) {
            v = 2;
          }
          if (G.altKey) {
            v = 3;
          }
          if (G.altKey && G.shiftKey) {
            v = 4;
          }
          if (G.altKey && (G.ctrlKey || G.metaKey)) {
            v = 5;
          }
          if (f.shift_mode) {
            v = 1;
          } else {
            if (f.ctrl_mode) {
              v = 2;
            } else {
              if (f.alt_mode) {
                v = 3;
              }
            }
          }
          if (mapviewer.settings.calibrationmode) {
            if (
              mapviewer.calpoint_onmousedown.distance <=
              mapviewer.settings.calradius
            ) {
              v = 1;
            }
          }
          if (v) {
            var I = J.x - f.dragStart.x;
            var H = J.y - f.dragStart.y;
            var E = J.x;
            var D = J.y;
            f.PanInProgress = 1;
            f.request_redraw();
            f.onmousemove(E, D, I, H, v);
          } else {
            if (B == "mouse") {
              var I = J.x - f.dragStart_down.x;
              var H = J.y - f.dragStart_down.y;
              f.dragged_x = I;
              f.dragged_y = H;
              f.distance_px_mousemove = Math.sqrt(I * I + H * H);
              if (f.use_rotate) {
                f.context.translate(J.x - f.dragStart.x, J.y - f.dragStart.y);
              } else {
                f.context.translate(J.x - f.dragStart.x, J.y - f.dragStart.y);
              }
              f.dragStart = J;
              f.PanInProgress = 1;
            } else {
              if (B == "touch") {
                f.context.translate(J.x - f.dragStart.x, J.y - f.dragStart.y);
                f.dragStart = J;
              }
            }
            f.request_redraw();
          }
        }
      }
    };
    this.mouseup_doc = function (A) {
      if (A.target.id != "map" && f.PanInProgress) {
        f.dragStart = null;
        f.PanInProgress = 0;
        var z = 0;
        if (A.shiftKey) {
          z = 1;
        }
        if (A.ctrlKey || A.metaKey) {
          z = 2;
        }
        if (A.altKey) {
          z = 3;
        }
        if (A.altKey && A.shiftKey) {
          z = 4;
        }
        if (A.altKey && (A.ctrlKey || A.metaKey)) {
          z = 5;
        }
        if (f.shift_mode) {
          z = 1;
        } else {
          if (f.ctrl_mode) {
            z = 2;
          } else {
            if (f.alt_mode) {
              z = 3;
            }
          }
        }
        var B = f.context.transformedPoint(p, o);
        var v = B.x;
        var D = B.y;
        f.onmouseup(v, D, z, f.dragged);
        f.request_redraw();
      }
    };
    this.mouseup_canvas = function (A) {
      f.dragStart = null;
      f.PanInProgress = 0;
      if (!f.dragged) {
      } else {
      }
      var z = 0;
      if (A.shiftKey) {
        z = 1;
      }
      if (A.ctrlKey || A.metaKey) {
        z = 2;
      }
      if (A.altKey) {
        z = 3;
      }
      if (A.altKey && A.shiftKey) {
        z = 4;
      }
      if (A.altKey && (A.ctrlKey || A.metaKey)) {
        z = 5;
      }
      if (f.shift_mode) {
        z = 1;
      } else {
        if (f.ctrl_mode) {
          z = 2;
        } else {
          if (f.alt_mode) {
            z = 3;
          }
        }
      }
      var B = f.context.transformedPoint(p, o);
      var v = B.x;
      var D = B.y;
      f.onmouseup(v, D, z, f.dragged);
      f.request_redraw();
    };
    this.zoom = function (O, F) {
      var N = 1.1;
      var G = Math.pow(N, O);
      if (f.use_rotate) {
        var H;
        var E;
        if (F == "key") {
          H = f.width / 2;
          E = f.height / 2;
        } else {
          var R = p - f.width / 2;
          var Q = o - f.height / 2;
          H = f.width / 2 + R * (1 - G);
          E = f.height / 2 + Q * (1 - G);
        }
        var A = f.rotate_angle;
        var M = f.width / 2;
        var J = f.height / 2;
        var z = M * Math.cos(A) + J * Math.sin(A);
        var K = -M * Math.sin(A) + J * Math.cos(A);
        var v = f.cx + (1 / f.zoomfactor) * (z - f.width / 2);
        var I = f.cy + (1 / f.zoomfactor) * (K - f.height / 2);
        var D = v;
        var B = I;
        f.context.scale(G, G);
        var z = H * Math.cos(A) + E * Math.sin(A);
        var K = -H * Math.sin(A) + E * Math.cos(A);
        var v = f.cx + (1 / f.zoomfactor) * (z - f.width / 2);
        var I = f.cy + (1 / f.zoomfactor) * (K - f.height / 2);
        f.cx = f.cx - v;
        f.cy = f.cy - I;
        mx = D * Math.cos(A) - B * Math.sin(A);
        my = D * Math.sin(A) + B * Math.cos(A);
        f.context.translate(-mx * f.zoomfactor, -my * f.zoomfactor);
      } else {
        if (F == "key") {
          f.context.scale(G, G);
        } else {
          if (F == "touch") {
            G = O;
          }
          f.cx = f.cx + (p - f.width / 2) / f.zoomfactor;
          f.cy = f.cy + (o - f.height / 2) / f.zoomfactor;
          f.context.scale(G, G);
          f.cx = f.cx - (p - f.width / 2) / f.zoomfactor;
          f.cy = f.cy - (o - f.height / 2) / f.zoomfactor;
        }
      }
      f.request_redraw();
    };
    var m = function (v) {
      if (v.shiftKey > 0) {
        var z = v.wheelDelta ? v.wheelDelta / 4000 : v.detail ? -v.detail : 0;
        f.context.rotate(z);
      } else {
        var z = v.wheelDelta ? v.wheelDelta / 40 : v.detail ? -v.detail : 0;
        if (z) {
          f.zoom(z, "wheel");
        }
      }
      if (isinternetexplorer) {
        return false;
      } else {
        return v.preventDefault() && false;
      }
    };
    bindEvent(this.canvaselement, "DOMMouseScroll", m, false);
    bindEvent(this.canvaselement, "mousewheel", m, false);
  };
  this.handleScrollExt = function (j) {
    handleScroll(j);
  };
  this.trackTransforms = function () {
    var o = this.context;
    var j = o.scale;
    o.scale = function (u, q) {
      f.zoomfactor = f.zoomfactor * u;
    };
    var m = o.rotate;
    o.rotate = function (q) {
      f.rotate_angle = f.rotate_angle + q;
      return m.call(o, q);
    };
    var p = o.translate;
    o.translate = function (u, q) {
      if (f.use_rotate) {
        var v = f.rotate_angle;
        f.cx =
          f.cx -
          (u / f.zoomfactor) * Math.cos(f.rotate_angle) -
          (q / f.zoomfactor) * Math.sin(f.rotate_angle);
        f.cy =
          f.cy +
          (u / f.zoomfactor) * Math.sin(f.rotate_angle) -
          (q / f.zoomfactor) * Math.cos(f.rotate_angle);
      } else {
        f.cx = f.cx - u / f.zoomfactor;
        f.cy = f.cy - q / f.zoomfactor;
      }
    };
    o.itransformedPoint = function (q, v) {
      var u = new Object();
      if (0) {
        u.x =
          f.width / 2 +
          (q - f.cx) * f.zoomfactor * Math.cos(f.rotate_angle) +
          (v - f.cy) * f.zoomfactor * Math.sin(f.rotate_angle);
        u.y =
          -((q - f.cx) * f.zoomfactor) * Math.sin(f.rotate_angle) +
          f.height / 2 +
          (v - f.cy) * f.zoomfactor * Math.cos(f.rotate_angle);
      } else {
        u.x = f.width / 2 + (q - f.cx) * f.zoomfactor;
        u.y = f.height / 2 + (v - f.cy) * f.zoomfactor;
      }
      return u;
    };
    o.itransformedPoint_rot = function (F, A) {
      var G = new Object();
      if (f.use_rotate) {
        var D = F;
        var B = A;
        var v = -f.rotate_angle;
        var u = f.width / 2 + (D - f.cx) * f.zoomfactor;
        var E = f.height / 2 + (B - f.cy) * f.zoomfactor;
        var q = u * Math.cos(v) + E * Math.sin(v);
        var z = -u * Math.sin(v) + E * Math.cos(v);
        G.x = q;
        G.y = z;
      } else {
        G.x = f.width / 2 + (F - f.cx) * f.zoomfactor;
        G.y = f.height / 2 + (A - f.cy) * f.zoomfactor;
      }
      return G;
    };
    o.transformedPoint = function (F, A) {
      var G = new Object();
      if (f.use_rotate) {
        var D = f.width / 2;
        var B = f.height / 2;
        var v = f.rotate_angle;
        var u = D * Math.cos(v) + B * Math.sin(v);
        var E = -D * Math.sin(v) + B * Math.cos(v);
        var q = f.cx + (1 / f.zoomfactor) * (u - f.width / 2);
        var z = f.cy + (1 / f.zoomfactor) * (E - f.height / 2);
        var D = F;
        var B = A;
        var v = f.rotate_angle;
        var u = D * Math.cos(v) + B * Math.sin(v);
        var E = -D * Math.sin(v) + B * Math.cos(v);
        var q = f.cx + (1 / f.zoomfactor) * (u - f.width / 2);
        var z = f.cy + (1 / f.zoomfactor) * (E - f.height / 2);
        G.x = q;
        G.y = z;
      } else {
        G.x = f.cx + (1 / f.zoomfactor) * (F - f.width / 2);
        G.y = f.cy + (1 / f.zoomfactor) * (A - f.height / 2);
      }
      return G;
    };
  };
  this.writeTextOutlined = function (v, q, E, z, M, I, j, F, o, B, u) {
    if (!B) {
      B = 1;
    }
    var D = 0;
    if (!j) {
      j = 0;
    }
    if (!u) {
      u = 0;
    }
    var m;
    if (!I) {
      m = this.context;
    } else {
      m = I;
    }
    if (o) {
      var H = o;
      m.textAlign = o;
    }
    var N = mapviewer.canvas.rotate_angle;
    if (mapviewer.canvas.use_rotate && mapviewer.settings.showtextrotated) {
      if (!M) {
        M = this.outlinetxtsize;
      }
      font = this.outlinefont;
      var J = "";
      if (u) {
        J = J + "bold ";
      }
      J = J + M + "px ";
      J = J + font;
      m.font = J;
      var A = parseInt(E.substr(0, 2), 16);
      var G = parseInt(E.substr(2, 2), 16);
      var K = parseInt(E.substr(4, 2), 16);
      m.fillStyle = "rgba(" + A + "," + G + "," + K + "," + B + ")";
      if (!F) {
        m.strokeStyle = "#000";
      } else {
        m.strokeStyle = "#" + F;
      }
      m.shadowColor = "#fff";
      m.shadowOffsetX = 2;
      m.shadowOffsetY = 2;
      m.shadowBlur = 10;
      m.lineWidth = 2;
      mapviewer.canvas.context.rotate(-N + j);
      theta = -N + j;
      if (f.use_translated_coordinates) {
        sx1 = f.width / 2 + (v - f.cx) * f.zoomfactor;
        sy1 = f.height / 2 + (q - f.cy) * f.zoomfactor;
        sx2 = sx1 * Math.cos(theta) + sy1 * Math.sin(theta);
        sy2 = -(sx1 * Math.sin(theta)) + sy1 * Math.cos(theta);
      } else {
        sx2 = v;
        sy2 = q;
      }
      v = sx2;
      q = sy2;
      m.strokeText(z, v, q);
      m.fillText(z, v, q);
      txtdim = m.measureText(z);
      D = txtdim.width;
      mapviewer.canvas.context.rotate(N - j);
      m.shadowOffsetX = 0;
      m.shadowOffsetY = 0;
      m.shadowBlur = 0;
    } else {
      if (f.use_translated_coordinates) {
        v = f.width / 2 + (v - f.cx) * f.zoomfactor;
        q = f.height / 2 + (q - f.cy) * f.zoomfactor;
      }
      if (
        (v > -f.outerborder &&
          q > -f.outerborder &&
          v < f.width + f.outerborder &&
          q < f.height + f.outerborder) ||
        f.use_rotate
      ) {
        if (!M) {
          M = this.outlinetxtsize;
        }
        font = this.outlinefont;
        var J = "";
        if (u) {
          J = J + "bold ";
        }
        J = J + M + "px ";
        J = J + font;
        m.font = J;
        var A = parseInt(E.substr(0, 2), 16);
        var G = parseInt(E.substr(2, 2), 16);
        var K = parseInt(E.substr(4, 2), 16);
        if (f.markertexttype == 0) {
          m.fillStyle = "#000";
          m.strokeStyle = "rgba(" + A + "," + G + "," + K + "," + B + ")";
          m.lineWidth = 2;
          m.strokeText(z, v, q);
          m.fillText(z, v, q);
          txtdim = m.measureText(z);
          D = txtdim.width;
        } else {
          if (f.markertexttype == 1) {
            m.fillStyle = "rgba(" + A + "," + G + "," + K + "," + B + ")";
            if (!F) {
              m.strokeStyle = "#000";
            } else {
              var p = parseInt(F.substr(4, 2), 16);
              m.strokeStyle = "#" + F;
            }
            m.shadowColor = "#fff";
            m.shadowOffsetX = 2;
            m.shadowOffsetY = 2;
            m.shadowBlur = 10;
            m.lineWidth = 2;
            var N = mapviewer.canvas.rotate_angle;
            if (
              mapviewer.canvas.use_rotate &&
              mapviewer.settings.showtextrotated
            ) {
              mapviewer.canvas.context.rotate(-N - j);
              f.move_canvasxy_to_origin(v, q);
              v = 0;
              q = 0;
            }
            m.strokeText(z, v, q);
            m.fillText(z, v, q);
            txtdim = m.measureText(z);
            D = txtdim.width;
            if (
              mapviewer.canvas.use_rotate &&
              mapviewer.settings.showtextrotated
            ) {
              mapviewer.canvas.context.rotate(N + j);
            }
            m.shadowOffsetX = 0;
            m.shadowOffsetY = 0;
            m.shadowBlur = 0;
          }
        }
      }
    }
    if (o) {
      m.textAlign = H;
    }
    return D;
  };
  this.saveDataURL = function (j, m, p) {
    var A = "txt";
    if (!m) {
      if (0) {
        var z = f.canvaselement.toDataURL("image/png");
        var v = new Image();
        v.src = z;
        mapviewer.canvas.context.fillStyle = "rgba(255,255,255,1)";
        mapviewer.canvas.context.fillRect(
          -2 * mapviewer.canvas.width,
          -2 * mapviewer.canvas.height,
          4 * mapviewer.canvas.width,
          4 * mapviewer.canvas.height
        );
        mapviewer.canvas.context.globalAlpha = 1;
        mapviewer.canvas.context.drawImage(v, 0, 0);
      }
      A = mapviewer.settings.printscreentype;
      if (A == "jpg") {
        A = "jpeg";
      }
      m = f.canvaselement.toDataURL("image/" + A);
    }
    var q = "fname=" + j + "&type=" + A + "&dataURL=" + encodeURIComponent(m);
    var o = "";
    if (mapviewer.settings.enableprintscreen >= 2) {
      o = "http://localhost/ge/2d/";
    }
    if (p || mapviewer.settings.enableprintscreen >= 3) {
      var u = new XMLHttpRequest();
      u.open("POST", o + "savedata.php", true);
      u.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      u.send(q);
    } else {
      m = m.replace("image/" + A, "image/octet-stream");
      downloadImg(m, j + "." + mapviewer.settings.printscreentype);
    }
  };
}
function Mapp() {
  var f = this;
  this.calstring_points = null;
  this.c1 = null;
  this.c2 = null;
  this.c3 = null;
  this.c4 = null;
  this.c5 = null;
  this.c6 = null;
  this.c1inv = null;
  this.c2inv = null;
  this.c3inv = null;
  this.c4inv = null;
  this.c5inv = null;
  this.c6inv = null;
  this.mapobject = null;
  this.width = null;
  this.height = null;
  this.calstring = null;
  this.loaded = 0;
  this.id = null;
  this.name = null;
  this.markerRadius = 5;
  this.loadmap = function (u, m, g, o, j, q, p) {
    this.id = q;
    this.mapobject = new Image();
    this.width = m;
    this.height = g;
    this.calstring = o;
    this.url = u;
    this.name = p;
    this.mapobject.onerror = function () {
      alert("Error: Could not load map! 2DRerun will not work as intended!");
      f.width = null;
      f.height = null;
    };
    this.mapobject.onload = function () {
      if (f.width == null && f.height == null) {
        f.width = f.mapobject.width;
        f.height = f.mapobject.height;
        if (f.width) {
          m = f.width;
        }
        if (f.height) {
          g = f.height;
        }
        mapviewer.canvas.cx = f.width / 2;
        mapviewer.canvas.cy = f.height / 2;
      }
      if (j == "qr") {
        f.width = f.mapobject.width;
        f.height = f.mapobject.height;
        if (f.width) {
          m = f.width;
        }
        if (f.height) {
          g = f.height;
        }
        f.initcalibration_gedata(o, m, g);
      } else {
        f.initcalibration(o);
      }
      f.loaded = 1;
      f.onmapload();
    };
    if (
      mapviewer.settings.enableprintscreen &&
      u != "dep/blank1600.gif" &&
      u != "/images/blank1600.gif"
    ) {
      // MODIF
      // this.mapobject.src = "loadmap.php?url=" + u;
      this.mapobject.src = u;
    } else {
      this.mapobject.src = u;
    }
  };
  this.onmapload = function () {
    alert("Map loaded");
  };
  this.toxy = function (o, j) {
    var g = this.c1 * j + this.c2 * o + this.c3;
    var p = this.c4 * j + this.c5 * o + this.c6;
    var m = new Point(g, p);
    return m;
  };
  this.tolatlng = function (g, p) {
    var j = this.c1inv * g + this.c2inv * p + this.c3inv;
    var m = this.c4inv * g + this.c5inv * p + this.c6inv;
    var o = new LatLng(m, j);
    return o;
  };
  this.initcalibration = function (z) {
    var v = z.split("|");
    this.calstring_points = z;
    var p = parseFloat(v[0]);
    var I = parseFloat(v[1]);
    var m = parseFloat(v[4]);
    var G = parseFloat(v[5]);
    var g = parseFloat(v[8]);
    var D = parseFloat(v[9]);
    var u = parseFloat(v[2]);
    var J = parseFloat(v[3]);
    var o = parseFloat(v[6]);
    var H = parseFloat(v[7]);
    var j = parseFloat(v[10]);
    var F = parseFloat(v[11]);
    if (p == J && I == u && m == H && G == o && g == F && D == j) {
      mapviewer.dummycalibration = 1;
      J = J * 100000;
      u = u * 100000;
      H = H * 100000;
      o = o * 100000;
      F = F * 100000;
      j = j * 100000;
    }
    var q = $M([
      [p, 0, I, 0, 1, 0],
      [0, p, 0, I, 0, 1],
      [m, 0, G, 0, 1, 0],
      [0, m, 0, G, 0, 1],
      [g, 0, D, 0, 1, 0],
      [0, g, 0, D, 0, 1],
    ]);
    var E = $V([u, J, o, H, j, F]);
    var B = q.inverse();
    c = B.x(E);
    this.c1 = c.elements[0];
    this.c2 = c.elements[2];
    this.c3 = c.elements[4];
    this.c4 = c.elements[1];
    this.c5 = c.elements[3];
    this.c6 = c.elements[5];
    var q = $M([
      [u, 0, J, 0, 1, 0],
      [0, u, 0, J, 0, 1],
      [o, 0, H, 0, 1, 0],
      [0, o, 0, H, 0, 1],
      [j, 0, F, 0, 1, 0],
      [0, j, 0, F, 0, 1],
    ]);
    var E = $V([p, I, m, G, g, D]);
    var B = q.inverse();
    c = B.x(E);
    this.c1inv = c.elements[0];
    this.c2inv = c.elements[2];
    this.c3inv = c.elements[4];
    this.c4inv = c.elements[1];
    this.c5inv = c.elements[3];
    this.c6inv = c.elements[5];
  };
  this.initcalibration_gedata = function (j, m, g) {
    el = calstring.split(";");
    n = parseFloat(el[0]);
    s = parseFloat(el[1]);
    e = parseFloat(el[2]);
    w = parseFloat(el[3]);
    r = parseFloat(el[4]);
    a = (e + w) / 2;
    b = (n + s) / 2;
    squish = Math.cos(deg2rad(b));
    x = (squish * (e - w)) / 2;
    y = (n - s) / 2;
    nex = a + (x * Math.cos(deg2rad(r)) - y * Math.sin(deg2rad(r))) / squish;
    ney = b + x * Math.sin(deg2rad(r)) + y * Math.cos(deg2rad(r));
    nwx = a - (x * Math.cos(deg2rad(r)) + y * Math.sin(deg2rad(r))) / squish;
    nwy = b - x * Math.sin(deg2rad(r)) + y * Math.cos(deg2rad(r));
    swx = a - (x * Math.cos(deg2rad(r)) - y * Math.sin(deg2rad(r))) / squish;
    swy = b - x * Math.sin(deg2rad(r)) - y * Math.cos(deg2rad(r));
    sex = a + (x * Math.cos(deg2rad(r)) + y * Math.sin(deg2rad(r))) / squish;
    sey = b + x * Math.sin(deg2rad(r)) - y * Math.cos(deg2rad(r));
    this.calstring_points =
      nwx +
      "|" +
      nwy +
      "|1|1|" +
      nex +
      "|" +
      ney +
      "|" +
      m +
      "|1|" +
      swx +
      "|" +
      swy +
      "|1|" +
      g;
    this.initcalibration(this.calstring_points);
  };
}
function Point(f, g) {
  this.x = f;
  this.y = g;
}
function LatLng(g, f) {
  this.lat = g;
  this.lng = f;
}
function Routepart(j, o, g, f) {
  var m = this;
  this.rnr = j;
  this.start = o;
  this.end = g;
  this.txt = f;
}
function Route(f, j, D, S, F, K, R, H, u, A, N) {
  var G = this;
  this.zerotime = -1;
  this.time = null;
  this.segmenttime = 0;
  this.middleval = 0.5;
  this.segmentlength = 0;
  this.segmentpace = 0;
  this.indexnumber = H;
  this.id = u;
  if (!A) {
    A = mapviewer.routes.length + 1;
  }
  this.md5 = A;
  this.mapreading = N;
  this.manualsplits = 0;
  this.splits = new Array();
  this.Pointinfo_from = null;
  this.Pointinfo_to = null;
  this.legendoffset_x = 0;
  this.legendoffset_y = 0;
  this.legendoffset_basex = 0;
  this.legendoffset_basey = 0;
  this.legendpos_x = 0;
  this.legendpos_y = 0;
  this.cutstart = null;
  this.cutend = null;
  this.timetolappos = null;
  this.datafields = new Array();
  this.variants = new Array();
  var g = f.split(";");
  var I = j.split(";");
  var E = D.split(";");
  var o = new Array();
  var p = new Array();
  var O = new Array();
  var q = new Array();
  var B = new Array();
  var v = new Array();
  var Q = new Array();
  var m = new Array();
  this.segmenttime_in = -1;
  this.segmenttime_out = -1;
  this.modifyroute_stablepoints = new Array();
  this.lapdata = new Array();
  this.lapdata_failed = new Array();
  var T = new Array(
    "008000",
    "40A000",
    "80C000",
    "C0E000",
    "FFFF00",
    "FFC000",
    "FF8000",
    "FF4000",
    "FF0000"
  );
  this.clearlatlng = function () {
    this.zerotime = -3;
    this.segmenttime = 0;
    this.segmentlength = 0;
    this.segmentpace = 0;
    this.indexnumber = H;
    this.id = u;
    this.md5 = A;
    this.latarray = new Array();
    this.lngarray = new Array();
    this.timearray = new Array();
    this.segmenttime_in = -1;
    this.segmenttime_out = -1;
  };
  this.addlatlngs = function (aa) {
    var ab = -1;
    if (this.latarray.length > 0) {
      ab = this.timearray[this.timearray.length - 1];
      prevlat = this.latarray[this.latarray.length - 1];
      prevlng = this.lngarray[this.lngarray.length - 1];
    }
    for (count = 0; count < aa.length; count++) {
      lat = parseFloat(aa[count].lat);
      lng = parseFloat(aa[count].lng);
      time = parseInt(aa[count].time);
      if (time < 707055816) {
        time = time + 1136070000;
      }
      if (ab == -1) {
        ab = time - 1;
        prevlat = lat;
        prevlng = lng;
        this.zerotime = time;
      }
      dt = time - ab;
      var ac = 0;
      if (getURLParameter("overridetime")) {
        ac = 1;
      }
      if (dt > 3600 * 8 && !ac) {
        console.log("Liveproblems");
        if (!mapviewer.liveproblems) {
          alert(
            "More than 8 hours gap! Can not process this live event! There will be trouble!"
          );
          mapviewer.liveproblems = 1;
        }
        console.log("dt too large");
        ab = time - 1;
      }
      var Z = lat - prevlat;
      var W = lng - prevlng;
      for (var V = ab + 1; V <= time; V++) {
        var Y = prevlat + (Z * (V - ab)) / dt;
        var X = prevlng + (W * (V - ab)) / dt;
        this.latarray.push(Y);
        this.lngarray.push(X);
        this.timearray.push(V);
      }
      ab = time;
      prevlat = lat;
      prevlng = lng;
    }
  };
  this.addfield_startstopval = function (V, W) {
    this[V] = W;
    this.datafields[V] = 1;
  };
  this.dochangenameinfo = function () {
    var Y = $("#changeinfo_lapstart").val();
    var W = $("#changeinfo_name").val();
    var X = $("#changeinfo_color").val().substr(1);
    var V = $("#changeinfo_maxpulse").val();
    if (Y != -1) {
      this.setlapstart(Y, mapviewer.playtime);
      mapviewer.request_redraw();
    }
    this.runnername_short = W;
    this.runnername = this.runnername_short;
    this.color = X;
    this.orgcolor = X;
    this.maxpulse = V;
    mapviewer.request_redraw();
    mapviewer.update_routediv(false);
    return false;
  };
  this.setpos = function (W, V) {
    this.offset = W - V + this.zerotime;
  };
  this.setlapstart = function (V, W) {
    if (this.lapdata.length) {
      if (this.lapdata.length > V) {
        this.setpos(this.lapdata[V].starttime, W);
      } else {
        this.setpos(this.lapdata[this.lapdata.length - 1].starttime, W);
      }
    }
  };
  this.addfield_interp = function (ab, Z, V) {
    var ad = -1;
    var W = V.split(";");
    var ac = Z.split(";");
    var Y = new Array();
    for (var aa = 0; aa < ac.length; aa++) {
      val = parseFloat(ac[aa]);
      time = parseInt(W[aa]);
      if (ad == -1) {
        ad = time - 1;
        prevval = val;
      }
      dt = time - ad;
      var ag = 0;
      if (getURLParameter("overridetime")) {
        ag = 1;
      }
      if (dt > 3600 * 8 && !ag) {
        ad = time - 1;
      }
      var X = val - prevval;
      for (var ae = ad + 1; ae <= time; ae++) {
        var af = prevval + (X * (ae - ad)) / dt;
        Y.push(af);
      }
      ad = time;
      prevval = val;
    }
    this[ab] = Y;
    this.datafields[ab] = 1;
    if (ab == "pulse") {
      if (!this.maxpulse) {
        this.maxpulse = Y.max();
      }
    }
  };
  this.calc_inout_time = function (X, ab) {
    if (X < -1e50 || X > 1e50 || ab < -1e50 || ab > 1e50) {
      this.segmenttime_in = 0;
      this.segmenttime_out = 0;
      return;
    }
    var aa = mapviewer.settings.calc_inout_ringrad;
    var W = 0;
    var ac = this.latarray[X];
    var Z = this.lngarray[X];
    for (var Y = X; Y < this.latarray.length; Y++) {
      var ad = calcdistance(this.latarray[Y], this.lngarray[Y], ac, Z);
      if (ad >= aa) {
        W = Y - X;
        Y = this.latarray.length + 1;
      }
    }
    if (ad < aa) {
      W = -1;
    }
    var af = 0;
    var ae = this.latarray[ab];
    var V = this.lngarray[ab];
    for (var Y = ab; Y >= 0; Y--) {
      var ad = calcdistance(this.latarray[Y], this.lngarray[Y], ae, V);
      if (ad >= aa) {
        af = ab - Y;
        Y = -1;
      }
    }
    if (ad < aa) {
      W = -1;
    }
    this.segmenttime_in = af;
    this.segmenttime_out = W;
  };
  this.interpolatelatlngtime = function () {
    var Y = -1;
    var aa = -1;
    var ab = -1;
    for (count = 0; count < o.length; count++) {
      lat = o[count];
      lng = p[count];
      time = O[count];
      if (Y == -1) {
        Y = time - 1;
        aa = lat;
        ab = lng;
        this.zerotime = time;
      }
      dt = time - Y;
      var ad = 0;
      if (getURLParameter("overridetime")) {
        ad = 1;
      }
      if (dt > 3600 * 8 && !ad) {
        Y = time - 1;
      }
      var W = lat - aa;
      var X = lng - ab;
      for (var ac = Y + 1; ac <= time; ac++) {
        var Z = aa + (W * (ac - Y)) / dt;
        var V = ab + (X * (ac - Y)) / dt;
        q.push(Z);
        B.push(V);
        v.push(ac);
      }
      Y = time;
      aa = lat;
      ab = lng;
    }
  };
  this.gettime_lap = function (X, Z) {
    var Y;
    if (Z == Math.floor(Z)) {
      Y = G.lapdata[X].times[Math.floor(Z)];
    } else {
      var W = Math.floor(Z);
      var V = Math.ceil(Z);
      thispos_1 = G.lapdata[X].times[W];
      thispos_2 = G.lapdata[X].times[V];
      Y = thispos_1 + ((thispos_2 - thispos_1) / (V - W)) * (Z - W);
    }
    return Y;
  };
  this.getpos_lap = function (X, Z) {
    var Y;
    if (Z == Math.floor(Z)) {
      Y = G.lapdata[X].timetopos[Z];
    } else {
      var W = Math.floor(Z);
      var V = Math.ceil(Z);
      thispos_1 = G.lapdata[X].timetopos[W];
      thispos_2 = G.lapdata[X].timetopos[V];
      Y = thispos_1 + ((thispos_2 - thispos_1) / (V - W)) * (Z - W);
    }
    return Y;
  };
  this.lapanimation_add = function () {
    G.lapanim = 1;
    for (var W = 0; W < G.lapdata.length; W++) {
      var X = G.runnername;
      if (G.lapdata.length > 1) {
        X = X + " - " + (W + 1);
      }
      G.lapdata[W].lapanim = 1;
      var V = G.indexnumber + "-" + W;
      var Y = G.lapdata[W].time;
      $("#runnercanvas").append(
        '<div style="margin-top:8px;width:100%;border-bottom:1px solid #888;position:relative;opacity:1" id="canvas-' +
          V +
          '"> <div id="runner-' +
          V +
          '" style="width:35px;height:30px;position:relative;opacity:0.5"><div style="position:absolute;right:0;top:0;"><img src="images/run.gif"></div><div style="position:absolute;left:0;bottom:0;font-size:10px;color:#ff0000;" id="info-' +
          V +
          '">+0</div></div> </div> <div style="width:100%;position:relative;height:4px;" id="canvas-marker-' +
          V +
          '"></div>'
      );
      $("#canvas-" + V).append(
        '<div id="runnername-' +
          V +
          '" style="top:0px;font-size:10px;position:absolute;left:0px">' +
          X +
          " (" +
          tominsec(Y) +
          ') <a href="javascript:void(0);" onclick="removerunner(' +
          V +
          ')"><img style="border=0px" src="images/delete.png"></a></div>'
      );
    }
  };
  this.lapanimation_topos = function (V, W) {
    mapviewer.lapanimation_runnertopos(G.indexnumber + "-" + V, W);
  };
  this.findTimeIndex = function (Y) {
    var V = null;
    var X = this.zerotime;
    var W = this.zerotime + this.latarray.length;
    if (Y >= X && Y <= W) {
      V = Y - X;
    } else {
      if (Y < X) {
        V = -Infinity;
      } else {
        if (Y > X) {
          V = Infinity;
        }
      }
    }
    return V;
  };
  this.findclosestpoint_segment = function (Y, Z, ab, ac) {
    var aa = 1e99;
    var ad = -1;
    for (var V = ab; V <= ac; V++) {
      var X = calcdistance(G.latarray[V], G.lngarray[V], Y, Z);
      if (X < aa) {
        aa = X;
        ad = V;
      }
    }
    var W = new Object();
    W.val = aa;
    W.ind = ad;
    if (G.pulse) {
      W.hr = G.pulse[ad];
    }
    return W;
  };
  this.findclosestpoint = function (af, ap, aa, ae) {
    var al = this.latarray;
    var ah = this.lngarray;
    var aj;
    var X;
    var an = 1e99;
    var ai = -1;
    var ab;
    if (aa == "completeroute") {
      aj = 0;
      X = al.length;
    } else {
      if (aa == "shownsegment") {
        aj = 0;
        X = al.length;
      } else {
        if (aa == "shownsegment2") {
          X = G.currenttime(ae);
          aj = X - G.taillength;
          if (aj > al.length) {
            aj = al.length;
          }
          if (aj < 0) {
            aj = 0;
          }
        }
      }
    }
    usesplitlaps = mapviewer.settings.usesplitlaps;
    splitlaps_outside_distance = mapviewer.settings.splitlaps_outside_distance;
    splitlaps_inside_distance = mapviewer.settings.splitlaps_inside_distance;
    searchslowest = 0;
    searchslowestseconds = 10;
    if (usesplitlaps) {
      var ak = new Object();
      ak.splits = new Array();
      var V = 0;
      var ao = splitlaps_inside_distance;
      var ac = splitlaps_outside_distance;
      var W = 0;
      var Z = 1e99;
      var am = -1;
      for (var Y = Math.round(aj); Y < Math.round(X); Y++) {
        ab = calcdistance(al[Y], ah[Y], af, ap);
        if (ab < an) {
          an = ab;
          ai = Y;
        }
        if (ab < Z) {
          Z = ab;
          am = Y;
        }
        if (ab <= ao && W == 0) {
          W = 1;
        }
        if (Y == Math.round(X) - 1) {
          ab = ac + 1;
        }
        if (ab >= ac && W == 1) {
          V++;
          if (searchslowest) {
            thisshortestdist = 1e99;
            orgdist = 0;
            for (
              var ag = am - searchslowestseconds + 1;
              ag <= am + searchslowestseconds;
              ag++
            ) {
              if (ag >= 2 && ag <= this.timearray.length - 2) {
                ab = calcdistance(
                  al[ag - 2],
                  ah[ag - 2],
                  al[ag + 2],
                  ah[ag + 2]
                );
                if (ab < thisshortestdist) {
                  thisshortestdist = ab;
                  newsplitdistind = ag;
                }
              }
            }
          }
          var ad = new LatLng(al[am], ah[am]);
          ak.splits[V - 1] = new Object();
          ak.splits[V - 1].P = ad;
          ak.splits[V - 1].time = this.timearray[am];
          ak.splits[V - 1].index = am;
          ak.splits[V - 1].mindist = Z;
          if (searchslowest) {
            ak.splits[V - 1].indexslowest = newsplitdistind;
          }
          W = 0;
          Z = 1e99;
          am = -1;
        }
      }
      ak.distance = calcdistance(al[ai], ah[ai], af, ap);
      var ad = new LatLng(al[ai], ah[ai]);
      ak.P = ad;
      ak.time = this.timearray[ai];
      ak.index = ai;
    } else {
      for (var Y = Math.round(aj); Y < Math.round(X); Y++) {
        ab = (al[Y] - af) * (al[Y] - af) + (ah[Y] - ap) * (ah[Y] - ap);
        if (ab < an) {
          an = ab;
          ai = Y;
        }
      }
      var ak = new Object();
      ak.distance = calcdistance(al[ai], ah[ai], af, ap);
      var ad = new LatLng(al[ai], ah[ai]);
      ak.P = ad;
      ak.time = this.timearray[ai];
      ak.index = ai;
    }
    return ak;
  };
  this.poslatlng = function (X) {
    var V = parseInt(X - G.zerotime + G.offset);
    if (V < 0) {
      V = 0;
    }
    var W = new Object();
    W.lat = G.latarray[V];
    W.lng = G.lngarray[V];
    return W;
  };
  this.currenttime = function (V) {
    return V - G.zerotime + G.offset;
  };
  this.drawRoute = function (av, aa, aq, ag, aV) {
    var aj = null;
    var aL = this;
    if (this.taillength > 0 && aV == 0) {
      ag = this.taillength;
    }
    if (this.taillength < 0) {
      ag = -1;
    }
    var ac = aq - ag;
    var ao = "";
    nodata = false;
    var Y = 1;
    var ai = aL.findTimeIndex(aq + aL.offset);
    var ar = aL.findTimeIndex(ac + aL.offset);
    if (isFinite(ai) && !isFinite(ar)) {
      ar = 0;
    }
    if (isFinite(ar) && !isFinite(ai)) {
      ai = aL.latarray.length - 1;
      nodata = true;
    }
    if (ai == -Infinity) {
      nodata = true;
      ai = 0;
      ar = ai;
    }
    if (ai == Infinity) {
      nodata = true;
      ai = aL.latarray.length - 1;
    }
    if (ar == -Infinity) {
      ar = 0;
    }
    if (ar > ai) {
      ar = ai;
      nodata = true;
    }
    if (ar == undefined || isNaN(ar)) {
      ar = ai;
    }
    if (mapviewer.settings.colormode == mapviewer.settings.modes.colorbypace) {
      if (!this.pace.length) {
        var Z = mapviewer.settings.pacecoloring.dt;
        var au = null;
        var ak = null;
        for (var aQ = 0; aQ <= this.latarray.length; aQ = aQ + Z) {
          thislat = G.latarray[aQ];
          thislng = G.lngarray[aQ];
          if (au || ak) {
            var aO = calcdistance(au, ak, thislat, thislng);
            var al = ((Z / aO) * 1000) / 60;
            for (var af = 0; af <= Z; af++) {
              this.pace[aQ - af] = al;
            }
          }
          au = thislat;
          ak = thislng;
        }
      }
    }
    if (
      this.highlight ||
      mapviewer.settings.mapreadingmode ||
      mapviewer.settings.drawsmoothlines ||
      mapviewer.settings.showdrawdots ||
      mapviewer.settings.coursedefinition_mode ||
      mapviewer.settings.replayleg
    ) {
      Y = 1;
    } else {
      if (ai - ar > 61) {
        Y = 2;
      }
      if (ai - ar > 121) {
        Y = 3;
      }
      if (ai - ar > 181) {
        Y = 5;
      }
    }
    if (
      mapviewer.settings.corridoranalysis == 1 &&
      mapviewer.settings.otechanalysis == 1
    ) {
      Y = 2;
    }
    var aM = null;
    var aJ = null;
    var an = null;
    var am = null;
    var aU = null;
    var aS = null;
    if (ai > parseInt(ai) && ai < aL.latarray.length) {
      Z = ai - parseInt(ai);
      ai = parseInt(ai);
      var ab = interpolate(
        aL.latarray[ai],
        aL.lngarray[ai],
        aL.latarray[ai + 1],
        aL.lngarray[ai + 1],
        Z
      );
      P = av.toxy(ab.xn, ab.yn);
      aU = P.x;
      aS = P.y;
      ao += aU + "," + aS + " ";
      aM = aU;
      aJ = aS;
    }
    var ay = ar;
    ar = parseInt(ar + 1);
    for (var aQ = ai; aQ >= ar + 1; aQ = aQ - Y) {
      ax = aL.latarray[aQ];
      at = aL.lngarray[aQ];
      P = av.toxy(ax, at);
      aU = P.x;
      aS = P.y;
      ao += aU + "," + aS + " ";
      if (aM == null) {
        aM = aU;
        aJ = aS;
      }
    }
    if (aU && aS) {
      an = aU;
      am = aS;
    }
    if (ay != parseInt(ay) && ay > 0) {
      Z = ay - parseInt(ay);
      ay = parseInt(ay);
      var ab = interpolate(
        aL.latarray[ay],
        aL.lngarray[ay],
        aL.latarray[ay + 1],
        aL.lngarray[ay + 1],
        Z
      );
      P = av.toxy(ab.xn, ab.yn);
      aU = P.x;
      aS = P.y;
      ao += aU + "," + aS + " ";
      an = aU;
      am = aS;
    }
    ao = ao.replace(/\s+$/, "");
    if (ao) {
      if (
        mapviewer.settings.colormode == mapviewer.settings.modes.colorbypace
      ) {
        var aB = mapviewer.settings.pacecoloring.minpace;
        var aH = mapviewer.settings.pacecoloring.maxpace;
        colstr = "";
        widthstr = "";
        var ah;
        var aP;
        var aE = parseInt(this.color.substr(0, 2), 16);
        var aN = parseInt(this.color.substr(2, 2), 16);
        var aR = parseInt(this.color.substr(4, 2), 16);
        var W = mapviewer.settings.routeopacity;
        for (var aQ = ai; aQ >= ar + 1; aQ = aQ - Y) {
          Q = aL.pace[aQ];
          if (
            mapviewer.settings.pacecoloring.type <= 1 ||
            mapviewer.settings.pacecoloring.type == 6
          ) {
            ah = this.getcolor(Q, aB, aH);
          } else {
            if (mapviewer.settings.pacecoloring.type == 5) {
              ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
              aP = this.getwidth(Q, aB, aH);
              maxwidth = mapviewer.settings.routewidth * 2;
              if (aP > maxwidth) {
                aP = maxwidth;
              }
            } else {
              if (mapviewer.settings.pacecoloring.type >= 3) {
                if (mapviewer.settings.pacecoloring.type == 3) {
                  thistransp = W;
                } else {
                  thistransp = 0;
                }
                if (Q <= aB) {
                  ah = "rgba(0,180,0," + thistransp + ")";
                } else {
                  if (Q <= aH) {
                    if (mapviewer.settings.pacecoloring.type == 4) {
                      ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
                    } else {
                      ah = "rgba(255,180,0," + W + ")";
                    }
                  } else {
                    ah = "rgba(255,0,0," + thistransp + ")";
                  }
                }
              } else {
                if (Q >= aH || Q <= aB) {
                  ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
                } else {
                  ah = "rgba(" + aE + "," + aN + "," + aR + ",0)";
                }
              }
            }
          }
          colstr = colstr + ah + " ";
          widthstr = widthstr + aP + " ";
        }
        if (mapviewer.settings.pacecoloring.type == 5) {
          aa.drawPolyColWidth(ao, colstr, widthstr);
        } else {
          aa.drawPolyCol(ao, colstr);
        }
        context.strokeStyle = "#" + this.color;
        if (
          mapviewer.settings.pacecoloring.type >= 1 &&
          mapviewer.settings.pacecoloring.type != 6
        ) {
          aa.setLineStyle(
            this.color,
            1,
            mapviewer.settings.pacecoloring.thinlinewidth
          );
          aa.drawPoly(ao);
        }
      } else {
        if (
          mapviewer.settings.corridoranalysis == 1 &&
          mapviewer.settings.otechanalysis == 1 &&
          aL.offset_route
        ) {
          colstr = "";
          var aE = parseInt(this.color.substr(0, 2), 16);
          var aN = parseInt(this.color.substr(2, 2), 16);
          var aR = parseInt(this.color.substr(4, 2), 16);
          var W = mapviewer.settings.routeopacity;
          for (var aQ = ai; aQ >= ar + 1; aQ = aQ - Y) {
            var aC = aL.offset_route[aQ];
            if (aC > mapviewer.settings.corridorwidth / 2) {
              ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
            } else {
              if (isNaN(aC)) {
                ah = "rgba(" + 150 + "," + 150 + "," + 150 + "," + W + ")";
              } else {
                ah = "rgba(" + aE + "," + aN + "," + aR + ",0)";
              }
            }
            colstr = colstr + ah + " ";
          }
          aa.drawPolyCol(ao, colstr);
          context.strokeStyle = "#" + this.color;
          aa.setLineStyle(
            this.color,
            1,
            mapviewer.settings.pacecoloring.thinlinewidth
          );
          aa.drawPoly(ao);
        } else {
          if (
            mapviewer.settings.compassanalysis == 1 &&
            mapviewer.settings.otechanalysis == 1 &&
            aL.offset_compass_within
          ) {
            colstr = "";
            var aE = parseInt(this.color.substr(0, 2), 16);
            var aN = parseInt(this.color.substr(2, 2), 16);
            var aR = parseInt(this.color.substr(4, 2), 16);
            var W = mapviewer.settings.routeopacity;
            for (var aQ = ai; aQ >= ar + 1; aQ = aQ - Y) {
              var aK = aL.offset_compass_within[aQ];
              if (aK == 0) {
                ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
              } else {
                if (isNaN(aK)) {
                  ah = "rgba(" + 150 + "," + 150 + "," + 150 + "," + W + ")";
                } else {
                  ah = "rgba(" + aE + "," + aN + "," + aR + ",0)";
                }
              }
              colstr = colstr + ah + " ";
            }
            aa.drawPolyCol(ao, colstr);
            context.strokeStyle = "#" + this.color;
            aa.setLineStyle(
              this.color,
              1,
              mapviewer.settings.pacecoloring.thinlinewidth
            );
            aa.drawPoly(ao);
          } else {
            if (
              mapviewer.settings.colormode ==
              mapviewer.settings.modes.colorbypulse
            ) {
              if (aL.pulse) {
                colstr = "";
                var aE = parseInt(this.color.substr(0, 2), 16);
                var aN = parseInt(this.color.substr(2, 2), 16);
                var aR = parseInt(this.color.substr(4, 2), 16);
                var W = mapviewer.settings.routeopacity;
                var aF = mapviewer.settings.pulsecoloring.minpulse;
                var aT = mapviewer.settings.pulsecoloring.maxpulse;
                for (var aQ = ai; aQ >= ar + 1; aQ = aQ - Y) {
                  var ae = (aL.pulse[aQ] / aL.maxpulse) * 100;
                  if (
                    mapviewer.settings.pacecoloring.type <= 1 ||
                    mapviewer.settings.pacecoloring.type == 6
                  ) {
                    ah = this.getcolor(ae, aF, aT);
                  } else {
                    if (ae >= aT) {
                      ah = "rgba(" + aE + "," + aN + "," + aR + "," + W + ")";
                    } else {
                      ah = "rgba(" + aE + "," + aN + "," + aR + ",0)";
                    }
                  }
                  colstr = colstr + ah + " ";
                }
                aa.drawPolyCol(ao, colstr);
                context.strokeStyle = "#" + this.color;
                if (
                  mapviewer.settings.pacecoloring.type >= 1 &&
                  mapviewer.settings.pacecoloring.type != 6
                ) {
                  aa.setLineStyle(
                    this.color,
                    1,
                    mapviewer.settings.pacecoloring.thinlinewidth
                  );
                  aa.drawPoly(ao);
                }
              } else {
                aa.drawPoly(ao);
              }
            } else {
              if (mapviewer.settings.coursedefinition_mode == 3) {
                aa.setLineStyle(
                  this.color,
                  1,
                  mapviewer.settings.routewidth / 4
                );
              }
              aa.drawPoly(ao);
            }
          }
        }
      }
      if (nodata || ag <= 0) {
        aa.drawMarker(aM, aJ, av.markerRadius * 0.5);
      } else {
        if (mapviewer.settings.showgrouping == 1) {
          aa.drawMarker(aM, aJ, av.markerRadius * 0.5);
        } else {
          if (mapviewer.settings.coursedefinition_mode == 3) {
            var X = mapviewer.settings.routewidth / 2;
            var ad = ao.split(" ");
            for (var aQ = 0; aQ < ad.length; aQ++) {
              var aw = ad[aQ].split(",");
              if (aQ == 0 || aQ == ad.length - 1) {
                aa.drawCircle(aw[0], aw[1], X * 2);
              } else {
                aa.drawCircle(aw[0], aw[1], X);
              }
            }
          } else {
            var aA = av.markerRadius;
            if (
              mapviewer.settings.mode == mapviewer.settings.modes.ReplayMode &&
              mapviewer.settings.analyzecourse == 1 &&
              aL.splits.length > 0
            ) {
              var V = aL.currenttime(mapviewer.playtime);
              for (var aG = 0; aG < aL.splits.length; aG++) {
                if (Math.abs(V - aL.splits[aG].index) < mapviewer.play_speed) {
                  aA = av.markerRadius * 2;
                  var aI = aL.splits[aG].index - aL.splits[0].index;
                  var aD = 1e99;
                  for (af = 0; af < mapviewer.routes.length; af++) {
                    troute = mapviewer.routes[af];
                    if (troute.show) {
                      var ap = troute.splits[aG].index - troute.splits[0].index;
                      if (ap < aD) {
                        aD = ap;
                      }
                    }
                  }
                  aj = "+" + tominsec(aI - aD);
                }
              }
            }
            aa.drawMarker(aM, aJ, aA);
          }
        }
      }
      if (this.highlight) {
        aa.drawMarker(an, am, av.markerRadius);
      }
    } else {
      ax = aL.latarray[ai];
      at = aL.lngarray[ai];
      P = av.toxy(ax, at);
      aM = P.x;
      aJ = P.y;
      aa.drawMarker(aM, aJ, av.markerRadius);
    }
    if (an == undefined) {
      an = aM;
      am = aJ;
    }
    ab = new Object();
    ab.endx = aM;
    ab.endy = aJ;
    ab.startx = an;
    ab.starty = am;
    ab.end = ai;
    ab.start = ar;
    if (aj) {
      ab.showxtxt = aj;
    }
    if (ag <= 0) {
      nodata = true;
    }
    ab.nodata = nodata;
    var az = ar + (ai - ar) * G.middleval;
    if (az < 0) {
      az = 0;
    }
    if (az > this.latarray.length - 1) {
      az = this.latarray.length - 1;
    }
    var ax = aL.latarray[parseInt(az)];
    var at = aL.lngarray[parseInt(az)];
    P = av.toxy(ax, at);
    ab.middlex = P.x;
    ab.middley = P.y;
    return ab;
  };
  this.calc_corridor_results = function () {
    if (!G.offset_route) {
      return;
    }
    if (!G.results) {
      G.results = new Object();
    }
    var W = 0;
    var V = 0;
    for (var X = 0; X < G.offset_route.length; X++) {
      if (!isNaN(G.offset_route[X])) {
        W++;
      }
      if (G.offset_route[X] <= mapviewer.settings.corridorwidth / 2) {
        V++;
      }
    }
    if (W > 0) {
      G.results.corridor_time = (V / W) * 100;
    } else {
      G.results.corridor_time = 0;
    }
    var V = 0;
    for (var X = 0; X < G.offset_course.length; X++) {
      if (G.offset_course[X] <= mapviewer.settings.corridorwidth / 2) {
        V++;
      }
    }
    if (G.offset_course.length > 0) {
      G.results.corridor_length = (V / G.offset_course.length) * 100;
    } else {
      G.results.corridor_length = 0;
    }
    G.results.corridor_overall =
      (G.results.corridor_length * G.results.corridor_time) / 100;
  };
  this.drawMapreading = function (ao, X, ar, aj) {
    var an = this;
    if (this.taillength) {
      aj = this.taillength;
    }
    var ac = ar - aj;
    var aq = "";
    nodata = false;
    var ad = 1;
    var Y = an.findTimeIndex(ar + an.offset);
    var Z = an.findTimeIndex(ac + an.offset);
    var am = ar + an.offset;
    var ab = ac + an.offset;
    if (isFinite(Y) && !isFinite(Z)) {
      Z = 0;
    }
    if (isFinite(Z) && !isFinite(Y)) {
      Y = an.latarray.length - 1;
      nodata = true;
    }
    if (Y == -Infinity) {
      nodata = true;
      Y = 0;
      Z = Y;
    }
    if (Y == Infinity) {
      nodata = true;
      Y = an.latarray.length - 1;
    }
    if (Z == -Infinity) {
      Z = 0;
    }
    if (Z > Y) {
      Z = Y;
      nodata = true;
    }
    if (Z == undefined || isNaN(Z)) {
      Z = Y;
    }
    ad = 1;
    var aa = this.mapreading.split(";");
    var ai = 0;
    for (var W = 0; W < aa.length; W++) {
      var V = aa[W].split("|");
      var ae = V[0];
      var ag = V[1];
      if (ag >= ab && ae <= am) {
        ai++;
        var ap = an.findTimeIndex(ae);
        var al = an.findTimeIndex(ag);
        var ah = parseInt(al);
        var af = parseInt(ap);
        if (ap < 0) {
          ap = 0;
        }
        if (al >= an.lngarray.length) {
          al = an.lngarray.length - 1;
        }
        dt = ap - af;
        if (dt > 0) {
          L = interpolate(
            an.latarray[af],
            an.lngarray[af],
            an.latarray[af + 1],
            an.lngarray[af + 1],
            dt
          );
          P = ao.toxy(L.xn, L.yn);
          aq += P.x + "," + P.y + " ";
          ap = af + 1;
        }
        for (var ak = ap; ak <= ah; ak++) {
          P = ao.toxy(an.latarray[ak], an.lngarray[ak]);
          aq += P.x + "," + P.y + " ";
        }
        dt = al - ah;
        if (dt > 0) {
          L = interpolate(
            an.latarray[ah],
            an.lngarray[ah],
            an.latarray[ah + 1],
            an.lngarray[ah + 1],
            dt
          );
          P = ao.toxy(L.xn, L.yn);
          aq += P.x + "," + P.y + " ";
        }
        aq = aq.replace(/\s+$/, "");
        aq += "|";
      } else {
      }
    }
    aq = aq.replace(/\|$/, "");
    if (aq) {
      X.drawPolys(aq);
    }
  };
  this.calc_length = function (X, Y) {
    var Z = 1;
    var V = 0;
    X = parseInt(X);
    Y = parseInt(Y);
    if (X < 0) {
      X = 0;
    }
    lats = G.latarray;
    lngs = G.lngarray;
    lat1 = lats[X];
    lng1 = lngs[X];
    for (var W = X + Z; W < Y; W = W + Z) {
      lat2 = lats[W];
      lng2 = lngs[W];
      d = calcdistance(lat1, lng1, lat2, lng2);
      V = V + d;
      lat1 = lat2;
      lng1 = lng2;
    }
    lat2 = lats[Y];
    lng2 = lngs[Y];
    d = calcdistance(lat1, lng1, lat2, lng2);
    V = V + d;
    return V;
  };
  this.calc_climb = function (X, aa) {
    var ab = 1;
    var V = 0;
    X = parseInt(X);
    aa = parseInt(aa);
    if (X < 0) {
      X = 0;
    }
    var Y = 5;
    var Z = average_array(this.elevation, Y, "normal");
    prevele = Z[X];
    for (var W = X + ab; W < aa; W = W + ab) {
      thisele = Z[W];
      d = thisele - prevele;
      if (d < 0) {
        d = 0;
      }
      V = V + d;
      prevele = thisele;
    }
    thisele = Z[W];
    d = thisele - prevele;
    if (d < 0) {
      d = 0;
    }
    V = V + d;
    return V;
  };
  this.findclosestwithdistance_seconds = function (ad, ac, ae, ab, Z) {
    var W = -1;
    var aa = this.latarray;
    var ag = this.lngarray;
    from_search = ad;
    var af = ad + ab;
    if (af >= aa.length) {
      af = aa.length;
    }
    var Y = 1e99;
    for (var V = from_search; V < af; V++) {
      thisdist = calcdistance(aa[V], ag[V], ac, ae);
      if (thisdist < Y) {
        Y = thisdist;
        W = V;
      }
    }
    var X = calcdistance(aa[W], ag[W], ac, ae);
    if (X <= Z) {
      return W;
    } else {
      return -1;
    }
  };
  this.findfirstwithdistance_seconds = function (aa, Z, ab, Y, W) {
    var X = this.latarray;
    var ad = this.lngarray;
    from_search = aa;
    var ac = aa + Y;
    if (ac >= X.length) {
      ac = X.length;
    }
    mindistfirstsec = 1e99;
    for (var V = from_search; V < ac; V++) {
      thisdist = calcdistance(X[V], ad[V], Z, ab);
      if (thisdist <= W) {
        mindistfirstsec = thisdist;
        distind = V;
        return distind;
      }
    }
    return -1;
  };
  this.findfirst_beforemovingaway = function (af, ae, ag, ad, ah) {
    var ac = this.latarray;
    var aj = this.lngarray;
    Y = af;
    ai = ac.length;
    var ab = 1e99;
    newind = -1;
    var ak = 0;
    var V = -1;
    var aa = 0;
    var X = 1e99;
    for (var W = Y; W < ai; W++) {
      if (W > Y) {
        ak += calcdistance(ac[W], aj[W], ac[W - 1], aj[W - 1]);
      }
      if (ak >= ah && V < 0) {
        if (ah - prev_d_alongcourse < ak - ah) {
          V = W - 1;
          aa = prev_d_alongcourse;
        } else {
          V = W;
          aa = ak;
        }
      }
      prev_d_alongcourse = ak;
      thisdist = calcdistance(ac[W], aj[W], ae, ag);
      if (thisdist > ab) {
        if (thisdist < X || W <= Y + 1) {
          newind = W;
          ab = thisdist;
        } else {
          newind = W - 1;
          ab = X;
        }
        W = ai + 1;
      } else {
        if (thisdist < ab) {
          ab = thisdist;
        }
      }
      X = thisdist;
    }
    var Z = ak;
    if (newind >= 0) {
      var Y = newind + 1;
      var ai = newind + ad;
      if (ai >= ac.length) {
        ai = ac.length;
      }
      for (var W = Y; W < ai; W++) {
        if (W > Y) {
          ak += calcdistance(ac[W], aj[W], ac[W - 1], aj[W - 1]);
        }
        if (ak >= ah && V < 0) {
          if (ah - prev_d_alongcourse < ak - ah) {
            V = W - 1;
            aa = prev_d_alongcourse;
          } else {
            V = W;
            aa = ak;
          }
        }
        prev_d_alongcourse = ak;
        thisdist = calcdistance(ac[W], aj[W], ae, ag);
        if (thisdist < ab) {
          if (thisdist < X) {
            newind = W;
            ab = thisdist;
          } else {
            newind = W - 1;
            ab = X;
          }
          Z = ak;
        }
        X = thisdist;
      }
    }
    mindist_beforemoving = ab;
    maxpercentoffdist = mapviewer.settings.snapcourse_maxpercentoffdist;
    if (
      (Z < ((100 - maxpercentoffdist) / 100) * ah ||
        Z > ((100 + maxpercentoffdist) / 100) * ah) &&
      V >= 0
    ) {
      newind = V;
    }
    movinfo = new Object();
    movinfo.newind = newind;
    movinfo.mindist_beforemoving = mindist_beforemoving;
    return movinfo;
  };
  this.getcolor = function (ad, ab, ac) {
    if (ad > ac) {
      ad = ac;
    }
    if (ad < ab) {
      ad = ab;
    }
    var V = Math.floor(((ad - ab) / (ac - ab)) * (T.length - 1));
    var X = T[V];
    if (!X) {
      X = "0000ff";
    }
    var W = parseInt(X.substr(0, 2), 16);
    var Z = parseInt(X.substr(2, 2), 16);
    var aa = parseInt(X.substr(4, 2), 16);
    var Y = mapviewer.settings.routeopacity;
    col = "rgba(" + W + "," + Z + "," + aa + "," + Y + ")";
    return col;
  };
  this.getwidth = function (V, Z, X) {
    maxw = mapviewer.settings.colorbypace_maxwidth;
    var W = (X - Z) * mapviewer.canvas.zoomfactor;
    var Y = (V - Z) * W;
    if (Y < 1) {
      Y = 1;
    }
    if (Y > maxw) {
      Y = maxw;
    }
    return Y;
  };
  this.addsplits = function (ac, W, X) {
    if (ac == 1) {
      splits = $("#addsplitstext").val();
    } else {
      if (ac == 2) {
        splits = $("#addpassingstext").val();
      } else {
        if (ac == 3) {
          G.manualsplits = 0;
          mapviewer.calculate_autosplits();
          mapviewer.request_redraw();
          return;
        } else {
          if (ac == 4) {
            splits = W;
            splits = splits.replace(/ /gi, "");
            splits = splits.replace(/;/gi, " ");
            ac = 1;
          }
        }
      }
    }
    splits = splits.replace(/\s+/gi, " ");
    splits = splits.replace(/^\s+/gi, "");
    splits = splits.replace(/\s+$/gi, "");
    var Z = splits.split(" ");
    if (!X) {
      X = 1;
    }
    var V = Z[X - 1];
    minsec = V.split(":");
    min = minsec[0];
    sec = minsec[1];
    secs = parseInt(min) * 60 + parseInt(sec);
    var Y = this.splits[X].index - secs;
    this.splits[X - 1].index = parseInt(Y);
    var aa = 0;
    var ad = Z.length;
    if (ad >= this.splits.length) {
      ad = this.splits.length - 1;
    }
    for (var ab = 0; ab < ad; ab++) {
      V = Z[ab];
      minsec = V.split(":");
      min = minsec[0];
      sec = minsec[1];
      secs = parseInt(min) * 60 + parseInt(sec);
      if (ac == 1) {
        aa = aa + secs;
      } else {
        aa = secs;
      }
      G.splits[ab + 1].index = parseInt(aa + Y);
    }
    G.manualsplits = 1;
  };
  this.snaptocourse = function (bg) {
    var aY = new Object();
    var aQ = "";
    var aE = "";
    var aJ = mapviewer.coursecoords;
    var aM = mapviewer.courseinfo.distarray;
    var al = 0;
    var ac = 20;
    var aW = 60;
    var aW = mapviewer.settings.snapcourse_withinseconds_startsearch;
    var a3 = mapviewer.settings.snapcourse_max_allowed_timestep;
    var aH = mapviewer.settings.snapcourse_check_extra_seconds;
    var aB = mapviewer.settings.snapcourse_max_allowed_distance;
    var a0 = parseInt($("#snapcoursepercent").val());
    if (a0 > 0 && a0 < 999) {
      mapviewer.settings.snapcourse_maxpercentoffdist = a0;
    } else {
      if (a0 == 999) {
        al = 500;
        aB = 10;
        a3 = 5 * 60;
      } else {
        mapviewer.settings.snapcourse_maxpercentoffdist = 1000000;
      }
    }
    var bc = G.latarray;
    var aT = G.lngarray;
    var aw = G.timearray;
    var a4 = 0;
    var at = 0;
    var aX = 0;
    var W = -1;
    var Y = new Array();
    var ar = new Array();
    var aF = 0;
    var ag = 0;
    while (at < aw.length) {
      ag++;
      Y[aF] = new Object();
      thislapdata = Y[aF];
      thislapdata.times = new Array();
      thislapdata.offsets = new Array();
      thislapdata.averages = new Object();
      var aa = 0;
      var ak = 0;
      for (var am = 0; am < aJ.length; am++) {
        var a9 = aJ[am].split(",");
        var ap = a9[0];
        var ao = a9[1];
        var aR = mapviewer.map.tolatlng(ap, ao);
        var an = aR.lat;
        var aj = aR.lng;
        var ba = 0;
        if ($.inArray(am - 1, mapviewer.courseinfo.lap_spacing) >= 0) {
          ba = 1;
          ind_nextlapstartcandidate = G.findfirstwithdistance_seconds(
            Math.floor(at),
            an,
            aj,
            1e99,
            ac
          );
          var a1 = [at, ind_nextlapstartcandidate];
          if (ind_nextlapstartcandidate > 0) {
            at = ind_nextlapstartcandidate - 1;
          } else {
            at = aw.length + 1;
          }
        }
        if (am == 0) {
          ak = 0;
          var aV;
          ind_startcandidate = G.findfirstwithdistance_seconds(
            Math.floor(at),
            an,
            aj,
            1e99,
            ac
          );
          mindist = aV;
          if (ind_startcandidate >= 0) {
            ind_startcandidate_updated = G.findclosestwithdistance_seconds(
              ind_startcandidate,
              an,
              aj,
              aW,
              ac
            );
          } else {
            ind_startcandidate_updated = -1;
          }
          if (ind_startcandidate_updated < 0) {
            ind_startcandidate_updated = aw.length + 1;
          }
          at = ind_startcandidate_updated;
          thislapdata.times.push(at);
          if (!mindist) {
            mindist = 0;
          }
          thislapdata.offsets.push(mindist);
        } else {
          var aM =
            mapviewer.courseinfo.distarray[am] -
            mapviewer.courseinfo.distarray[am - 1];
          var X;
          movinfo = G.findfirst_beforemovingaway(at, an, aj, aH, aM);
          ind_nextcandidate = movinfo.newind;
          mindist = movinfo.mindist_beforemoving;
          if (
            ind_nextcandidate - at > a3 ||
            ind_nextcandidate < 0 ||
            mindist > aB
          ) {
            if (ind_nextcandidate - at > a3) {
              aa = am;
            }
            if (ind_nextcandidate < 0) {
              aa = am;
            }
            if (mindist > aB) {
              aa = am;
              ak++;
              if (mindist < 1e99) {
                mapviewer.visualize_point = Object;
                mapviewer.visualize_point.x = ap;
                mapviewer.visualize_point.y = ao;
                mapviewer.request_redraw();
              }
            }
            if (thislapdata.times.length < 10) {
              ak = al + 1;
            }
            if (ak > al) {
              am = aJ.length + 1;
            }
            at++;
          } else {
            at = ind_nextcandidate;
            if (0) {
              thislapdata.times.push(at);
              thislapdata.offsets.push(mindist);
            } else {
              l_from = at - 1;
              l_to = at + 1;
              l_steps = 10;
              l_dt = 1 / l_steps;
              var av = this.latarray;
              var Z = this.lngarray;
              mindist_l = 1e99;
              minind_l = at;
              prevlat_l = av[l_from - 1];
              prevlng_l = Z[l_from - 1];
              for (var bd = l_from; bd <= l_to; bd++) {
                lat_l = av[bd];
                lng_l = Z[bd];
                var a8 = lat_l - prevlat_l;
                var a7 = lng_l - prevlng_l;
                for (var af = 0; af < l_steps; af++) {
                  var ax = lat_l + (a8 * af) / l_steps;
                  var ad = lng_l + (a7 * af) / l_steps;
                  var a5 = bd + af * l_dt;
                  var au = calcdistance(ax, ad, an, aj);
                  if (au < mindist_l) {
                    mindist_l = au;
                    minind_l = a5;
                  }
                }
                prevlat_l = lat_l;
                prevlng_l = lng_l;
              }
              if (!mindist_l) {
                mindist_l = 0;
              }
              thislapdata.times.push(minind_l);
              thislapdata.offsets.push(mindist_l);
              ak = 0;
              aa = 0;
            }
          }
        }
        if (aa > 1) {
          if (thislapdata.times.length > 1) {
            thislapdata.times.push(
              thislapdata.times[thislapdata.times.length - 1]
            );
            thislapdata.offsets.push(
              thislapdata.offsets[thislapdata.offsets.length - 1]
            );
          }
        }
        prevlat = an;
        prevlng = aj;
      }
      if (thislapdata.times.length == aJ.length) {
        var a6 = new Array();
        a6[0] = 0;
        for (var bb = 1; bb < thislapdata.times.length; bb++) {
          var ah = thislapdata.times[bb] - thislapdata.times[bb - 1];
          var aD =
            mapviewer.courseinfo.distarray[bb] -
            mapviewer.courseinfo.distarray[bb - 1];
          thisspeed = aD / ah;
          a6[bb] = thisspeed;
        }
        var aO = 3;
        var aI = average_array(a6, aO, "normal");
        thislapdata.average_offset =
          thislapdata.offsets.sum() / thislapdata.offsets.length;
        var ay = mapviewer.datafieldtypes;
        for (var az = 0; az < ay.length; az++) {
          var aP = this[ay[az]];
          if (aP) {
            var ae = new Array();
            for (var am = 0; am < thislapdata.times.length; am++) {
              var at = thislapdata.times[am];
              if (at == NaN) {
                ae[am] = NaN;
              } else {
                var aq = parseInt(at);
                var ai = "use_closest";
                if (ai == "use_interpolation") {
                  sind_frac = at - aq;
                  val = aP[aq] + sind_frac * (aP[aq + 1] - aP[aq]);
                } else {
                  if (ai == "use_closest") {
                    val = aP[aq];
                  }
                }
                ae[am] = val;
              }
            }
            thislapdata[ay[az]] = ae;
            mapviewer.used_fieldtypes[ay[az]] = 1;
          }
        }
        if (thislapdata.cadence) {
          thislapdata.syklusvei = new Array();
          thislapdata.tidpersyklus = new Array();
          for (var am = 0; am < thislapdata.times.length; am++) {
            thissv = 0;
            thist = 0;
            if (thislapdata.cadence[am] != 0) {
              thissv = ((aI[am] / thislapdata.cadence[am]) * 60) / 2;
              thist = (1 / thislapdata.cadence[am]) * 60 * 2;
            }
            thislapdata.syklusvei[am] = thissv;
            thislapdata.tidpersyklus[am] = thist;
          }
        }
        thislapdata.starttime = thislapdata.times[0];
        thislapdata.time =
          thislapdata.times[thislapdata.times.length - 1] -
          thislapdata.starttime;
        aF++;
      } else {
        var bf = Y.splice(Y.length - 1, 1);
        var be = Math.ceil(bf[0].times[0]);
        var aU = Math.floor(bf[0].times[thislapdata.times.length - 1]);
        if (isNaN(aU)) {
          aU = Math.floor(bf[0].times[thislapdata.times.length - 2]);
        }
        var aZ = Math.floor(
          (bf[0].times.length / mapviewer.coursecoords.length) * 100
        );
        ar.push(bf[0]);
        if (aU - be > 1) {
          aE +=
            ' - <a href="Javascript:void(0);" onclick="mapviewer.showfitlap(' +
            bg +
            "," +
            (ar.length - 1) +
            ',2);">Failed</a>: <font color="#a00">' +
            aZ +
            "% fit</font>. From " +
            tominsec(be) +
            " to " +
            tominsec(aU) +
            ' <font color="#a00">(' +
            tominsec(aU - be) +
            ")</font><br>";
          var V =
            aZ +
            "% fit. From " +
            tominsec(be) +
            " to " +
            tominsec(aU) +
            ". Time " +
            tominsec(aU - be);
          bf[0].fitinfo = V;
        } else {
          bf[0].fitinfo = "1% fit from " + tominsec(be) + ". Time 0:01";
        }
        ak = 0;
      }
      if (ag > 500) {
        at = aw.length + 1;
      }
    }
    if (aF > 0) {
      G.lapdata = Y;
      $("#snapcourseinfo").append(
        G.runnername + ": " + G.lapdata.length + " laps<br>"
      );
      var aL = new Array();
      for (var aN = 0; aN < G.timearray.length; aN++) {
        aL[aN] = NaN;
      }
      var aK = null;
      for (var bb = 0; bb < G.lapdata.length; bb++) {
        var a2 = new Array();
        thislapdata = Y[bb];
        var be = Math.ceil(thislapdata.times[0]);
        var aU = Math.floor(thislapdata.times[thislapdata.times.length - 1]);
        var aC = be - thislapdata.times[0];
        if (aK != null) {
          aQ += ". Gap:" + tominsec(be - aK) + "</font><br>";
        }
        var V =
          "Lap " +
          (bb + 1) +
          ". From " +
          tominsec(be) +
          " to " +
          tominsec(aU) +
          ". Lap time: " +
          tominsec(aU - be) +
          ". Average offset " +
          parseInt(thislapdata.average_offset * 10) / 10 +
          " m";
        thislapdata.fitinfo = V;
        aQ +=
          ' - <a href="Javascript:void(0);" onclick="mapviewer.showfitlap(' +
          bg +
          "," +
          bb +
          ',1);">Lap ' +
          (bb + 1) +
          '</a> <font color="#0a0">100% fit</font>: From ' +
          tominsec(be) +
          " to " +
          tominsec(aU) +
          ' <font color="#0a0">(' +
          tominsec(aU - be) +
          ")</font>. Average offset " +
          parseInt(thislapdata.average_offset * 10) / 10 +
          " m";
        aK = aU;
        var aA = 0;
        for (var aN = be; aN <= aU; aN++) {
          while (thislapdata.times[aA] < aN && aA < thislapdata.times.length) {
            aA++;
          }
          if (thislapdata.times[aA] == aN) {
            aL[aN] = aA;
          } else {
            var aG = thislapdata.times[aA - 1];
            var aS = thislapdata.times[aA];
            var ab = aS - aG;
            if (ab != 0) {
              aL[aN] = aA - 1 + (aN - thislapdata.times[aA - 1]) / ab;
            } else {
              aL[aN] = aA - 1;
            }
          }
          a2[aN - be] = aL[aN];
        }
      }
      aQ += "<br>";
      G.timetolappos = aL;
      thislapdata.timetopos = a2;
    } else {
      G.lapdata = new Array();
    }
    if (ar.length) {
      G.lapdata_failed = ar;
    } else {
      G.lapdata_failed = new Array();
    }
    aY.html = aQ + aE;
    return aY;
  };
  this.snapto_o_course = function (aC) {
    if (!mapviewer.settings.autosplits_calculated) {
      mapviewer.calculate_autosplits();
    }
    var aa = mapviewer.coursecoords;
    var aB = G.latarray;
    var V = G.lngarray;
    var ab = G.timearray;
    var aF = G.splits;
    var W = new Array();
    var ag = new Array();
    var aw = new Array();
    var X = 0;
    var aG = 0;
    aw[X] = new Object();
    thislapdata = aw[X];
    var aA = 0;
    var Y = 0;
    coursecoords_alongline_arr = new Array();
    coords_alongroute_arr = new Array();
    for (var aA = 0; aA < aF[0].index; aA++) {
      W[aA] = 0;
      ag[aA] = 0;
      coursecoords_alongline_arr[aA] = "0,0";
      coords_alongroute_arr[aA] = "0,0";
    }
    var az = 0;
    for (var ai = 0; ai < aa.length - 1; ai++) {
      var av = aa[ai].split(",");
      var am = parseInt(av[0]);
      var aR = parseInt(av[1]);
      var av = aa[ai + 1].split(",");
      var al = parseInt(av[0]);
      var aQ = parseInt(av[1]);
      var ao = mapviewer.map.tolatlng(am, aR);
      var an = mapviewer.map.tolatlng(al, aQ);
      var aE = ao.lat;
      var aD = an.lat;
      var ar = ao.lng;
      var aq = an.lngt;
      nextcontrol_ind = aF[ai + 1].index;
      if (!nextcontrol_ind) {
        alert("Trouble");
        ai = 1e99;
        aA = 1e99;
      }
      ac = Math.sqrt((al - am) * (al - am) + (aQ - aR) * (aQ - aR));
      Lreal = calcdistance(aE, ar, aD, aq);
      theta = Math.atan2(aQ - aR, al - am);
      var ap = 0;
      while (!ap) {
        lat = aB[aA];
        lng = V[aA];
        P = mapviewer.map.toxy(lat, lng);
        x = P.x;
        y = P.y;
        l = Math.sqrt((x - am) * (x - am) + (y - aR) * (y - aR));
        lreal = calcdistance(lat, lng, aE, ar);
        theta_p = Math.atan2(y - aR, x - am);
        dist_from_line = lreal * Math.sin(theta_p - theta);
        dist_along_line = az + lreal * Math.cos(theta_p - theta);
        W[aA] = dist_from_line;
        ag[aA] = dist_along_line;
        coords_alongroute_arr[aA] = x + "," + y;
        xn = am + l * Math.cos(theta);
        yn = aR + l * Math.sin(theta);
        coursecoords_alongline_arr[aA] = xn + "," + yn;
        if (aA >= nextcontrol_ind || aA > aB.length) {
          ap = 1;
          az = az + lreal;
        } else {
        }
        aA++;
      }
    }
    var aP = az;
    thislapdata.dist_from_line_arr = W;
    thislapdata.dist_along_line_arr = ag;
    var aH = new Array();
    var ak = new Array();
    oplotspacing_coarse = 10;
    oplotspacing = 2;
    aG = 0;
    count_coarse = 0;
    for (var Z = 0; Z <= aP; Z = Z + oplotspacing_coarse) {
      while (ag[aG] <= Z && aG < W.length) {
        aG++;
      }
      var ae = aG;
      var af = aG - 1;
      if (af < 0) {
        af = 0;
      }
      var aJ = ag[af];
      var aI = ag[ae];
      var aK;
      if (aI == aJ) {
        aK = af;
      } else {
        aK = af + (aI - Z) / (aI - aJ);
      }
      aH[count_coarse] = aK;
      count_coarse++;
    }
    var ac = 0;
    var aG = 0;
    var au = oplotspacing_coarse / oplotspacing;
    var aM = new Array();
    for (var aN = 1; aN < aH.length; aN++) {
      var aj = aH[aN - 1];
      var aO = aH[aN];
      var aK = aj;
      var ah = (aO - aj) / au;
      for (var ai = 0; ai < au; ai++) {
        ak[aG] = aK;
        aM[aG] = ac;
        ac = ac + oplotspacing;
        aG++;
        aK = aK + ah;
      }
    }
    thislapdata.distindarr = ak;
    thislapdata.times = ak;
    thislapdata.distindarr_coarse = aH;
    thislapdata.distarr = aM;
    var at = mapviewer.datafieldtypes;
    for (var ax = 0; ax < at.length; ax++) {
      if (this[at[ax]] != null) {
        fname = at[ax];
        var ad = interpolate_arr(this[fname], ak);
        if (fname == "pulse" && this.maxpulse) {
          for (var aN = 0; aN < ad.length; aN++) {
            ad[aN] = parseInt((ad[aN] / this.maxpulse) * 100);
          }
        }
        thislapdata[fname] = ad;
      }
    }
    dist_from_line = interpolate_arr(W, ak);
    thislapdata.dist_from_line = dist_from_line;
    dist_along_line = interpolate_arr(ag, ak);
    thislapdata.dist_along_line = dist_along_line;
    coursecoords_alongline = interpolate_xyarr(coursecoords_alongline_arr, ak);
    coords_alongroute = interpolate_xyarr(coords_alongroute_arr, ak);
    thislapdata.coords_alongroute = coords_alongroute;
    if (aC == 0) {
      mapviewer.courseinfo.distarray = aM;
      mapviewer.coursecoords_alongline = coursecoords_alongline;
      mapviewer.coursecoords_alongline_arr = coursecoords_alongline_arr;
      mapviewer.coursecoords_distindarr = ak;
    }
    var ay = Math.floor(ak[0]);
    var aL = new Array();
    var ac = 0;
    aL.push(ac);
    for (var aN = 1; aN < this.latarray.length; aN++) {
      if (aN > ay + 1) {
        d = calcdistance(
          this.latarray[aN - 1],
          this.lngarray[aN - 1],
          this.latarray[aN],
          this.lngarray[aN]
        );
        ac = ac + d;
      }
      aL.push(ac);
    }
    routedist_int = interpolate_arr(aL, ak);
    thislapdata.routedist = routedist_int;
    G.lapdata = aw;
  };
  this.straightroute_shown = function (ag) {
    var aa = 0;
    var Y = 4;
    var ad, ae;
    if (ag) {
      ad = Math.floor(G.offset);
      ae = G.offset - G.segmenttime;
      aa = 1;
    } else {
      endtime = mapviewer.playtime;
      taillength = G.taillength;
      if (taillength > 0) {
        var af = endtime - taillength;
        ad = G.findTimeIndex(endtime + G.offset);
        ae = G.findTimeIndex(af + G.offset);
        aa = 1;
      } else {
      }
    }
    if (aa) {
      ae = parseInt(ae);
      ad = parseInt(ad);
      var X = G.latarray[ae];
      var ac = G.lngarray[ae];
      var W = G.latarray[ad];
      var Z = G.lngarray[ad];
      var ab = ad - ae;
      for (var V = 1; V < ab; V++) {
        G.latarray[ae + V] = X + ((W - X) * V) / ab;
        G.lngarray[ae + V] = ac + ((Z - ac) * V) / ab;
      }
    }
  };
  this.trim_shown = function (ad) {
    var Z = 0;
    var X = 4;
    var aa, ab;
    if (ad) {
      aa = Math.floor(G.offset);
      ab = G.offset - G.segmenttime;
      Z = 1;
    } else {
      endtime = mapviewer.playtime;
      taillength = G.taillength;
      if (taillength > 0) {
        var ac = endtime - taillength;
        aa = G.findTimeIndex(endtime + G.offset);
        ab = G.findTimeIndex(ac + G.offset);
        Z = 1;
      } else {
      }
    }
    if (ab <= X) {
      ab = 0;
    }
    if (aa >= G.latarray.length - X - 1) {
      aa = G.latarray.length;
    }
    if (Z) {
      G.latarray.splice(ab, aa - ab);
      G.lngarray.splice(ab, aa - ab);
      G.timearray.splice(ab, aa - ab);
      if (G.pulse) {
        if (G.pulse.length > 0) {
          G.pulse.splice(ab, aa - ab);
        }
      }
      if (G.elevation) {
        if (G.elevation.length > 0) {
          G.elevation.splice(ab, aa - ab);
        }
      }
      if (ab > 0 && aa < G.latarray.length - 1) {
        var Y = G.timearray[ab - 1];
        var W = 0;
        for (var V = ab; V < G.timearray.length; V++) {
          W++;
          G.timearray[V] = Y + W;
        }
      }
    } else {
      alert(G.runnername + ": Can currently only trim at start/end of route!");
    }
  };
  this.calc_averages_course_previous = function () {
    if (G.pulse && !G.maxpulse) {
      if (G.pulse.length > 0) {
        console.log(
          "Set maxpulse to " +
            G.maxpulse +
            " for " +
            G.runnername +
            " (from highest HR value"
        );
        G.maxpulse = G.pulse.max();
      }
    }
    var ac = G.lapdata;
    var X = mapviewer.courseinfo;
    if (ac.length) {
      for (var W = 0; W < ac.length; W++) {
        count++;
        var Z = ac[W];
        var V = mapviewer.datafieldtypes.slice();
        V.unshift("times");
        for (var ad = 0; ad < V.length; ad++) {
          var ab = new Array();
          fname = V[ad];
          if (Z[fname] != null) {
            var Y = Z[fname];
            for (var aa = 0; aa < Y.length; aa++) {
              thispos2 = X.distarray[aa];
              if (fname == "times") {
                thisval = Z.times[aa] - Z.times[0];
              } else {
                thisval = Y[aa];
              }
              ab.push([thispos2 / 1000, thisval]);
            }
            if (isNaN(mapviewer.datafieldtypes_basic_avpoints[1])) {
              mapviewer.datafieldtypes_basic_avpoints[1] = 3;
            }
            if (fname == "times") {
              avpoints = mapviewer.datafieldtypes_basic_avpoints[1];
              ab = average_line(ab, avpoints, "normal-separator");
            }
            if (fname == "times") {
              avthisline = average_segments(ab, 1);
            } else {
              avthisline = average_segments(ab, 0);
            }
            G.lapdata[W].averages[fname] = avthisline;
            G.calc_updownflat(fname);
          }
        }
        fix_cadence = G.lapdata[W].averages.tidpersyklus;
        if (fix_cadence) {
          for (var aa = 0; aa < fix_cadence.length; aa++) {
            tmpval = fix_cadence[aa];
            if (tmpval != 0) {
              tmpval = 1 / tmpval;
            }
            G.lapdata[W].averages.cadence[aa] = tmpval * 60;
          }
        }
      }
    }
  };
  this.calc_averages_course = function () {
    if (G.pulse && !G.maxpulse) {
      if (G.pulse.length > 0) {
        console.log(
          "Set maxpulse to " +
            G.maxpulse +
            " for " +
            G.runnername +
            " (from highest HR value)"
        );
        G.maxpulse = G.pulse.max();
      }
    }
    var ag = G.lapdata;
    var Y = mapviewer.courseinfo;
    if (ag.length) {
      for (var X = 0; X < ag.length; X++) {
        count++;
        var ab = ag[X];
        var V = mapviewer.datafieldtypes.slice();
        V.unshift("times");
        for (var ah = 0; ah < V.length; ah++) {
          var ad = new Array();
          fname = V[ah];
          if (ab[fname] != null) {
            if (fname == "times") {
              var aa = ab[fname];
              for (var ac = 0; ac < aa.length; ac++) {
                thispos2 = Y.distarray[ac];
                thisval = ab.times[ac] - ab.times[0];
                ad.push([thispos2 / 1000, thisval]);
              }
            } else {
              if (fname == "pulse") {
                ad[0] = new Array();
                ad[1] = new Array();
                var aa = G[fname];
                var af = ab.starttime;
                var ae = af + ab.time;
                for (var ac = 0; ac < ab.times.length; ac++) {
                  thisval = ab.times[ac] - ab.times[0];
                  ad[0].push(thisval);
                }
                for (var ac = af; ac < ae; ac++) {
                  thisval = aa[ac];
                  ad[1].push(thisval);
                }
              } else {
                var aa = ab[fname];
                for (var ac = 0; ac < aa.length; ac++) {
                  thispos2 = Y.distarray[ac];
                  thisval = aa[ac];
                  ad.push([thispos2 / 1000, thisval]);
                }
              }
            }
            if (isNaN(mapviewer.datafieldtypes_basic_avpoints[1])) {
              mapviewer.datafieldtypes_basic_avpoints[1] = 3;
            }
            if (fname == "times") {
              avpoints = mapviewer.datafieldtypes_basic_avpoints[1];
              var Z = ad[0][1];
              var W = ad[ad.length - 1][1];
              ad = average_line(ad, avpoints, "normal-separator");
              ad[0][1] = Z;
              ad[ad.length - 1][1] = W;
            }
            if (fname == "times") {
              avthisline = average_segments(ad, 1);
              console.log(avthisline.sum());
            } else {
              avthisline = average_segments(ad, 2);
            }
            G.lapdata[X].averages[fname] = avthisline;
            G.calc_updownflat(fname, X);
          }
        }
        fix_cadence = G.lapdata[X].averages.tidpersyklus;
        if (fix_cadence) {
          for (var ac = 0; ac < fix_cadence.length; ac++) {
            tmpval = fix_cadence[ac];
            if (tmpval != 0) {
              tmpval = 1 / tmpval;
            }
            G.lapdata[X].averages.cadence[ac] = tmpval * 60;
          }
        }
      }
    }
  };
  this.calc_updownflat = function (W, X) {
    var ad = G;
    var Y = mapviewer.courseinfo.segmenttypes.slice();
    Y.push("Complete");
    var aa = ad.lapdata.length;
    if (ad.lapdata[X].averages[W]) {
      var ac = new Array();
      for (var ab = 0; ab < Y.length; ab++) {
        var af = Y[ab];
        var ah = mapviewer.courseinfo.segmentstats[af];
        ac[af] = 0;
        var ae = 0;
        for (var V = 0; V < ah.length; V++) {
          var ag = ah[V];
          ae += parseFloat(ad.lapdata[X].averages.times[ag]);
          var Z = parseFloat(ad.lapdata[X].averages[W][ag]);
          if (W != "times") {
            Z = Z * ad.lapdata[X].averages.times[ag];
          }
          ac[af] += Z;
        }
        if (W != "times") {
          if (ae > 0) {
            ac[af] = ac[af] / ae;
          } else {
            ac[af] = 0;
          }
        }
      }
      if (!ad.lapdata[X].persegment) {
        ad.lapdata[X].persegment = new Object();
      }
      ad.lapdata[X].persegment[W] = ac;
    }
  };
  this.removedatapoints = function (W, V) {
    G.latarray.splice(W, V);
    G.lngarray.splice(W, V);
    G.timearray.splice(W, V);
    if (G.pulse) {
      if (G.pulse.length > 0) {
        G.pulse.splice(W, V);
      }
    }
    if (G.elevation) {
      if (G.elevation.length > 0) {
        G.elevation.splice(W, V);
      }
    }
  };
  if (f) {
    for (count = 0; count < g.length; count++) {
      o[count] = parseFloat(g[count]);
      p[count] = parseFloat(I[count]);
      O[count] = parseInt(E[count]);
      if (O[count] < 707055816) {
        O[count] = O[count] + 1136070000;
      }
    }
    this.interpolatelatlngtime();
    this.latarray = q;
    this.lngarray = B;
    this.timearray = v;
  } else {
    this.latarray = new Array();
    this.lngarray = new Array();
    this.timearray = new Array();
  }
  var z = null;
  var M = null;
  var U = new RegExp("_CS(\\d+)", "ig");
  findcut = S.match(U);
  if (findcut) {
    z = parseInt(findcut[0].substr(3));
  }
  var U = new RegExp("_CE(\\d+)", "ig");
  findcut = S.match(U);
  if (findcut) {
    M = parseInt(findcut[0].substr(3));
  }
  G.cutstart = z;
  G.cutend = M;
  S = S.replace(/_CS(\d+)/g, "");
  S = S.replace(/_CE(\d+)/g, "");
  var J = S;
  S = S.replace(/^[\d\+\s\-]+/g, "");
  if (S == "") {
    S = J;
  }
  this.runnername = S;
  this.runnername_long = S;
  this.runnername_short = S.substr(0, 8);
  this.runnername_middle = S.substr(0, 19);
  this.unit = F;
  this.show = R;
  this.pace = Q;
  this.color = K;
  this.orgcolor = K;
  this.highlight = 0;
  this.offset = 0;
  this.taillength = null;
  this.fav = 0;
  this.tottime = 0;
  this.totplace = 999;
  this.totbeind = 1e99;
  this.show_prev = 0;
  console.log("Setting in new Route for " + this.runnername);
  mapviewer.apply_settingsfromfile("maxpulse", this);
  mapviewer.apply_settingsfromfile("rename", this);
}
function Rwroute(q, g, v, j, p, A, z, m) {
  var B = this;
  this.name = g;
  this.rnr = q;
  this.equal = v;
  this.time = j;
  this.overtime = p;
  this.points = A;
  this.drawpoints = A;
  this.tottime = parseInt((parseFloat(j) + parseFloat(p) * 2) * 10) / 10;
  this.show = 0;
  this.variant = null;
  this.color = mapviewer.getnextcolor();
  if (z) {
    this.splits = z.split(" ");
  } else {
    this.splits = new Array();
  }
  if (m) {
    this.lengths = m.split(" ");
  } else {
    this.lengths = new Array();
  }
  var u;
  if (q > 0) {
    u = "";
    bgcolor = "ffffff";
  } else {
    u = "";
    this.show = 1;
    bgcolor = this.color;
  }
  var o = "";
  if (v > 0) {
    o = v + " % in ";
  }
  var f =
    '<div id="rwroute' +
    q +
    '" onclick="mapviewer.toggledrawrw(' +
    q +
    ')" class="colorbox" style="background:#' +
    bgcolor +
    '"></div>';
  $("#" + mapviewer.routedescdiv).append(
    '<div class="drawrw">' +
      f +
      "<b>" +
      g +
      ': </b> <span id="rwrouteinfo' +
      q +
      '">' +
      o +
      this.tottime +
      " s</span></div>"
  );
  this.writelength = function (F) {
    var D = "#rwrouteinfo" + B.rnr;
    var E = "";
    if (B.lengths) {
      E = B.lengths[F];
    }
    if (E) {
      E = E + " m";
    } else {
      E = "";
    }
    $(D).html(E);
  };
}
function MapViewer(F, o, D) {
  setInterval("mapviewer.updatetimer()", 1000);
  var z = this;
  var g = 0;
  this.waitforclick = null;
  this.waitfordrag = null;
  this.orgroutes = null;
  this.waitfordrag_startpoint = null;
  this.waitfordrag_dragging = null;
  this.waitfordrag_finishfunction = null;
  this.click_onmousedown = null;
  this.specialized_drawfunction = null;
  this.settings = new Object();
  this.settings.modes = new Object();
  this.settings.modes.ReplayMode = 0;
  this.settings.modes.AnalysisMode = 1;
  this.settings.modes.DetailedMode = 9;
  this.settings.modes.DrawCourseMode = 3;
  this.settings.modes.SaveDataMode = 8;
  this.settings.modes.LiveMode = 4;
  this.settings.modes.GraphMode = 5;
  this.settings.modes.CalibrationMode = 6;
  this.settings.modes.AddRoutesMode = 7;
  this.settings.modes.colorbyorg = 0;
  this.settings.modes.colorbysplit = 1;
  this.settings.modes.colorbylength = 2;
  this.settings.modes.colorbypace = 3;
  this.settings.modes.colorbypulse = 4;
  this.settings.modes.SingleLegend = 0;
  this.settings.modes.MultiLegend = 1;
  this.settings.modes.CornerLegend = 3;
  this.settings.modes.CornerLegend2 = 4;
  this.settings.modes.SingleLegend2 = 5;
  this.settings.modes.SingleLegend3 = 6;
  this.settings.modes.NoLegend = 2;
  this.settings.recolormode = "byathlete";
  this.settings.Ximagepos = new Array();
  this.settings.colorbypace_maxwidth = 100;
  this.settings.modes.replay_autorotate = 0;
  this.settings.rotate_maxanglechange = 1 / 20;
  this.settings.rotate_minanglechange = 1 / 20;
  this.settings.rotate_averagetime = 30;
  this.settings.papersize = 0;
  this.settings.papersize_mm = [210, 297];
  this.settings.papersize_name = "A4 portrait";
  this.settings.printscale = 10000;
  this.settings.nameinfotxt = "";
  this.settings.replayleg = 0;
  this.settings.replayleg_state = null;
  this.settings.replayleg_states = new Array();
  this.settings.replayleg_starttime = null;
  this.settings.replayleg_time = null;
  this.settings.wizardmode = 0;
  this.settings.sketchmode = 0;
  this.settings.sketchmode_mode = 1;
  this.settings.sketchmode_pointsize = 10;
  this.settings.sketchmodes = [
    "UnHighlight",
    "Highlight",
    "Red",
    "Blue",
    "Green",
    "Gray",
    "LGreen",
    "RedRing",
    "BlueRing",
    "GreenRing",
    "Delete",
  ];
  this.settings.is_sketching = 0;
  this.settings.is_sketching_mousedown = 0;
  this.settings.courseprofileshowgrade = 0;
  this.settings.courselength = 0;
  this.settings.shownorthlines = 0;
  this.settings.showprintbox = 0;
  this.settings.printbox = null;
  this.settings.variant_changefrom = null;
  this.settings.settings_from_file = null;
  this.settings.mindist_for_penalty = 15;
  this.settings.corridorwidth = 50;
  this.settings.corridoranalysis = 0;
  this.settings.compassanalysis = 0;
  this.settings.compassanalysis_showsplits = 0;
  this.otechinfo = new Object();
  this.settings.compasswidth = 25;
  this.settings.compassangle = 5;
  this.settings.dpi = 300;
  this.settings.scale = 10000;
  this.settings.sortxcresults = 2;
  this.settings.xc_betweenlap_separation_meters = 50;
  this.settings.savevideo = new Object();
  this.settings.savevideo.speed = 10;
  this.settings.savevideo.framespersec = 10;
  this.settings.savevideo.format = 1;
  this.settings.savevideo.maxframes = 10000;
  this.settings.savevideo.a = null;
  this.settings.biaplot_relhrmin = 0;
  this.settings.no_graphreplot_on_resize = 0;
  this.settings.lapanim = new Object();
  this.settings.lapanim.speed = 10;
  this.wizard = Object();
  this.wizard.data_raw = null;
  this.wizard.data = null;
  this.settings.lastlegendmaxwidth = 0;
  this.settings.lastcolorlegendmaxwidth = 0;
  this.settings.legendtypes = [
    "Route",
    "Box",
    "None",
    "LCorner",
    "UCorner",
    "RouteL",
    "RouteL2",
  ];
  this.settings.legendinfos = [
    "NLP",
    "Name",
    "SName",
    "NL",
    "NP",
    "DT",
    "NLP+IO",
    "N+IO",
    "NLPTP",
  ];
  this.settings.autrotanglemodes = [
    "Vertical",
    "Horizontal",
    "10 deg",
    "20 deg",
    "30 deg",
    "40 deg",
    "50 deg",
  ];
  this.settings.autrotanglemode = 0;
  this.settings.legendinfo = 0;
  this.settings.colormodes = ["Normal", "Time", "Length", "Pace", "Pulse"];
  this.settings.colorAnalysismodes = ["0", "1", "2", "3", "4", "5", "Tsnow"];
  this.settings.legendtype = this.settings.modes.SingleLegend;
  this.settings.mode = this.settings.modes.ReplayMode;
  this.settings.previousmode = this.settings.mode;
  this.settings.colormode = this.settings.modes.colorbyorg;
  this.settings.dotstep = 3;
  this.settings.drawsmoothlines = 0;
  this.settings.showdrawdots = 0;
  this.settings.otechanalysis = 0;
  this.settings.autoanalysis = 0;
  this.settings.detailedanalysis = 0;
  this.settings.mapreadingmode = 0;
  this.settings.analyzecourse = 0;
  this.settings.showcourse = 1;
  this.settings.hidecourse = 0;
  this.settings.definecourse = 0;
  this.settings.alwaysshowcourse = 0;
  this.settings.calc_inout_times = 0;
  this.settings.calc_inout_ringrad = 50;
  this.settings.addtags = 0;
  this.settings.tagmode = 0;
  this.settings.showtagmode = 0;
  this.settings.showtagall = 0;
  this.settings.minsegmentlength = 30;
  this.settings.maxrecheck = 3;
  this.settings.highlightcolor = "ff0000";
  this.settings.highlightcolor2 = "000000";
  this.settings.routeopacity = 0.7;
  this.settings.courseopacity = 0.8;
  this.settings.showcoursecontrolnumbers = 0;
  this.settings.coursecolor = "a626ff";
  this.settings.coursewhitebackground = 0;
  this.settings.coursewidthmult = 1;
  this.settings.controlRadius = 30;
  this.settings.controlnumberfontsize = 60;
  this.settings.infotxtfontsize = 60;
  this.settings.printboxcolor = "0044aa";
  this.settings.printboxlinewidth = 24;
  this.settings.showcoursecontrolnumbers = 1;
  this.settings.northlineswidth = 1;
  this.settings.routewidth = 7;
  this.settings.isprinting = 0;
  this.settings.isprinting_blank = 0;
  this.settings.showtextrotated = 1;
  this.settings.autoanalysis_writefull = 1;
  this.settings.draw_selected_routeparts = 0;
  this.settings.routeparts = null;
  this.settings.coursename = "";
  var v = Object();
  v.printspecial = 0;
  v.alwaysshowgrade = 0;
  v.minheight = 50;
  v.scaled_eleplot = 0;
  v.eleplot_scalefactor = 1;
  v.ydivpermeter = 5;
  v.scaletxt = 1;
  v.px_extra_y = 50;
  v.pxpermeter_y = 4 * 1.2;
  v.px_extra_x = 45;
  v.pxpermeter_x = 0.25 * 1.2;
  v.labelsperpixelbeforeoffset = 80;
  this.settings.eleplotoptions = v;
  this.clusters = null;
  this.settings.lastupdate_clusters = 0;
  this.settings.update_cluster_frequency = 5;
  this.settings.show_cluster_legend = 0;
  this.settings.cluster_spacing = 100;
  this.ocadcourses = new Array();
  this.ocadcontrols = new Array();
  this.ocadtranslate = new Object();
  this.ocadtranslate.x0 = 0;
  this.ocadtranslate.y0 = 0;
  this.ocadtranslate.scalex = 1;
  this.ocadtranslate.scaley = 1;
  this.ocadtranslate.clickinfo = [
    "Adjust course with mouse. (1) Please click on one of the control locations on the course",
    "(2) Please click on the corresponding point on the map",
    "(3) Please click on another control location on the course",
    "(4) Please click on the corresponding point on the map",
  ];
  this.ocadtranslate.currentcourse = null;
  this.loggedin = null;
  this.pwd = null;
  this.uname = null;
  this.settings.centerlegnum = 0;
  this.settings.autoselect_chosen = "3-O";
  this.settings.showautoselect = 0;
  this.settings.timegraphtype = 1;
  this.settings.timegraphlimit = 3;
  this.settings.graph_compare_winner = 0;
  this.settings.graphannotatetxtsize = 12;
  this.settings.exclude_averagejoe = new Array();
  this.settings.routecolors = new Array();
  this.settings.routenumbers = new Array();
  this.settings.graphs = new Array();
  this.settings.graphobjs = new Array();
  this.settings.maxgraphs = 4;
  this.settings.showgraphs = 0;
  for (var j = 0; j < this.settings.maxgraphs; j++) {
    this.settings.graphs[j] = new Object();
    this.settings.graphs[j].plottype = 0;
    this.settings.graphs[j].fraction_for_zero = 0.3;
    this.settings.graphs[j].avpoints = 0;
    this.settings.graphs[j].includeele_percent_min = -40;
    this.settings.graphs[j].includeele_percent_max = 40;
    this.settings.graphs[j].plot_average_segments = 0;
    this.settings.graphs[j].plotdiff = 0;
    this.settings.graphs[j].graphannotate = new Array();
    this.settings.graphs[j].acanvas = null;
    this.settings.graphs[j].acontext = null;
    this.settings.graphs[j].prevx = null;
    this.settings.graphs[j].prevy = null;
    this.settings.graphs[j].prevtime = null;
    this.settings.graphs[j].statinfox = 0.01;
    this.settings.graphs[j].statinfoy = 0.95;
    this.settings.graphs[j].aggregate_hillsegments = 0;
    this.settings.graphs[j].aggregate_hillsegments_type = "Complete";
  }
  this.settings.arrowmult = 1;
  this.settings.graphsettings = new Object();
  this.settings.graphsettings.barplotfontsize = "10pt";
  this.settings.graphsettings.barplotangle = -30;
  this.settings.graphsettings.barplotstackedfontsize = "8pt";
  this.settings.graphsettings.barplotstackedangle = -45;
  this.settings.graphsettings.barplotstackedpointlabel = "9px";
  this.settings.graphsettings.separatorlabel = "Separator";
  this.settings.graphsettings.axisfontsize = "16pt";
  this.settings.menu_isvisible = 1;
  this.lastcontrol = null;
  this.settings.tagging_timealt = 0;
  this.settings.tagging_lastcolorindex = 0;
  this.settings.tagging_lastgroup = 0;
  this.settings.tagging_deletemode = 1;
  this.settings.showgrouping = 0;
  this.settings.variants_showmode = 0;
  this.min_moveto_distance = 100;
  this.settings.pacegraph = new Object();
  this.settings.pacegraph.minpace = 2;
  this.settings.pacegraph.maxpace = 20;
  this.settings.pacegraph.dt = 10;
  this.settings.makeprettylines = 0;
  this.settings.minbezierlength = 30;
  this.settings.pacecoloring = new Object();
  this.settings.pacecoloring.minpace = 5;
  this.settings.pacecoloring.maxpace = 15;
  this.settings.pacecoloring.dt = 3;
  this.settings.pacecoloringslider = new Object();
  this.settings.pacecoloringslider.minpace = 2;
  this.settings.pacecoloringslider.maxpace = 30;
  this.settings.pacecoloringslider.minsec = 1;
  this.settings.pacecoloring.type = 1;
  this.settings.pacecoloring.thinlinewidth = 1;
  this.settings.pulsecoloring = new Object();
  this.settings.pulsecoloring.minpulse = 80;
  this.settings.pulsecoloring.maxpulse = 95;
  this.settings.mapopacity = 1;
  this.settings.routewidthmapreading = 10;
  this.settings.routeopacitymapreading = 0.6;
  this.settings.taillength = 60;
  this.settings.highlightopacity = 1;
  this.settings.highlightwidth = 8;
  this.settings.highlightwidth2 = 4;
  this.settings.tagcategories = new Array();
  this.settings.autosplits_calculated = 0;
  this.settings.splitlaps_outside_distance = 51;
  this.settings.splitlaps_inside_distance = 30;
  this.settings.usesplitlaps = 1;
  this.settings.sameroutechoice_distance = 50;
  this.settings.sameroutechoice_percent = 25;
  this.settings.thisclick_x = 0;
  this.settings.thisclick_y = 0;
  this.settings.lastclick_x = 0;
  this.settings.lastclick_y = 0;
  this.redraw_interval = 0.1;
  this.play_speed = 10;
  this.loadStatedata = null;
  this.dummycalibration = 0;
  this.settings.modifyroutes = 0;
  this.settings.modifyroute_mousedown = null;
  this.settings.calibrationmode = 0;
  this.apply_calinfo = null;
  this.calpoint_onmousedown = null;
  this.settings.calradius = 50;
  this.max_whiteborder_when_centering_map = 20;
  this.map_start_x = 0;
  this.map_start_y = 0;
  this.has_request_redraw = 0;
  this.showallinfo = 1;
  this.settings.legendoffset_x = 0;
  this.settings.legendoffset_y = 0;
  this.settings.legendoffset_basex = 0;
  this.settings.legendoffset_basey = 0;
  this.settings.legendroutenum = -1;
  this.settings.rotateoffset = 0;
  this.settings.rotate_centerx = 0;
  this.settings.rotate_centery = 0;
  this.settings.rotate_x0 = 0;
  this.settings.rotate_y0 = 0;
  this.settings.power_mu_g = 0.04;
  this.settings.power_air_ACD = 0.35;
  this.settings.power_mass = 70;
  this.offline = 0;
  this.loadedgpxfromurl = 0;
  this.center_map_on_runner = 0;
  this.settings.center_map_on_runners = ["No", "Yes"];
  this.prev_center_map_ind = 0;
  this.route_to_center = 0;
  this.DrawnLines = null;
  this.previousdrawstarttime_ms = null;
  this.replaystarttime_localtime_ms = null;
  this.replaystarttime_competitiontime_ms = null;
  this.showrouteswhilepanning = 1;
  this.settings.autoanalysis_withindistance = 10;
  this.settings.autoanalysis_withinseconds_samesegment = 15;
  this.settings.autoanalysis_maxsamesegmentlength = 30;
  this.settings.autoanalysis_adjusted = 0;
  this.printscreenfactor = 1;
  this.settings.printscreentype = "jpg";
  this.settings.runningwild = 0;
  this.settings.orunningwild = new Object();
  this.settings.orunningwild.x = 0;
  this.settings.orunningwild.y = 0;
  this.settings.orunningwild.linestr = "";
  this.settings.orunningwild.angle = null;
  this.settings.orunningwild.speed = 4;
  this.settings.orunningwild.previousline = null;
  this.settings.orunningwild.center = 0;
  this.settings.orunningwild.compareideal = 1;
  this.settings.orunningwild.ideal_show = 1;
  this.settings.orunningwild.ideal_lat = null;
  this.settings.orunningwild.ideal_lng = null;
  this.settings.orunningwild.ideal_startpos = null;
  this.settings.orunningwild.ideal_endpos = null;
  this.settings.orunningwild.ideal_color = "0000ff";
  this.settings.orunningwild.password = null;
  this.settings.orunningwild.futurepoints = new Array();
  this.settings.orunningwild.maxfuturepoints = 1e99;
  this.settings.orunningwild.maxfuturepointsbeforeeat = 1e99;
  this.settings.orunningwild.cont = 0;
  this.settings.orunningwild.prevdistpoint = 1e99;
  this.settings.orunningwild.overtime = 0;
  this.settings.orunningwild.starttime = 0;
  this.settings.orunningwild.time = 0;
  this.settings.orunningwild.finished = 0;
  this.settings.orunningwild.started = 0;
  this.settings.orunningwild.allpoints = new Array();
  this.settings.orunningwild.allpoints_interplat = new Array();
  this.settings.orunningwild.allpoints_interplng = new Array();
  this.settings.orunningwild.diffroutes = null;
  this.settings.orunningwild.name = "";
  this.settings.orunningwild.playername = "";
  this.settings.orunningwild.description = "";
  this.settings.orunningwild.equal_percent = null;
  this.settings.orunningwild.equal_cmpname = null;
  this.settings.orunningwild.drawfuturecircles = 0;
  this.settings.orunningwild.splits = new Array();
  this.settings.orunningwild.lengths = new Array();
  this.settings.orunningwild.autorotate = 1;
  this.settings.orunningwild.showcourse = 0;
  this.settings.orunningwild.anid = null;
  this.settings.orunningwild.usePac = 0;
  this.settings.orunningwild.variants = null;
  this.settings.orunningwild.currentcontrol = 0;
  this.settings.orunningwild.controlpointpixels = 15;
  this.variant_array = new Array();
  this.settings.orunningwild.sameroutechoice_distance = 30;
  this.settings.orunningwild.sameroutechoice_percent = 70;
  this.comments = new Array();
  this.comments_loaded = 0;
  this.Ocanvas = null;
  this.detailedpoints = new Array();
  this.tags = new Array();
  this.currenttag = null;
  this.visualize_point = null;
  this.currenttime_delta = 3;
  this.splitsbrowserlines = new Array();
  this.splitsbrowserdrawpoints = new Array();
  this.splitsbrowsermarkedsegment = null;
  this.showFractionInfoBelow = 0.35;
  this.showBelowFactor = 1;
  this.settings.courseinfofrac = 0.8;
  this.settings.showInfoBelow = false;
  this.AnalysisLogdef = new Object();
  this.AnalysisLogdef.img = null;
  this.AnalysisLogdef.img_blank = null;
  this.AnalysisLogdef.savetype = 0;
  this.AnalysisLogdef.savetypes = [
    "Screenshot",
    "+Blank",
    "+Blank+Alt",
    "Download",
  ];
  this.AnalysisLogdef.img_alternatives = null;
  this.AnalysisLogdef.loaded_lognames = null;
  this.AnalysisLogdef.prevvals = new Array();
  this.heatmap = null;
  if (typeof courseplanning != "undefined") {
  } else {
    courseplanning = 0;
  }
  this.datafieldtypes_basic = ["time", "speed", "pace", "eleprofile"];
  this.datafieldtypes_basic_avpoints = [null, 3, 4, 3, 3];
  this.datafieldtypes = [
    "pulse",
    "cadence",
    "syklusvei",
    "tidpersyklus",
    "roll",
    "elevation",
    "elesensor",
    "elegps",
    "pitch",
    "yaw",
    "tleft",
    "tright",
    "tsymmetry",
    "techniques",
    "watts",
    "smo2",
    "thb",
    "pulse_break",
    "speed_break",
    "bia_pulse_shooting",
    "bia_time_shooting",
    "power",
    "pgravity",
    "pfriction",
    "pdrag",
    "pacc",
    "dspeed",
  ];
  this.datafieldtypes_display = [
    "pulse",
    "frekvens",
    "syklusvei",
    "TidPerSyklus",
    "sidestabilitet",
    "Default elevation",
    "Sensor elevation",
    "GPS elevation",
    "pitch",
    "yaw",
    "tleft",
    "tright",
    "TakSymmetry",
    "techniques",
    "watts",
    "Smo2",
    "tHb",
    "Puls mellom runder",
    "Fart mellom runder",
    "Bia Shoot HR stat",
    "Bia Shoot Time stat",
    "Power",
    "Pgravity",
    "Pfriction",
    "Pdrag",
    "Pacc",
    "DopplerSpeed",
  ];
  this.datafieldtypes_avpoints = [
    2, 3, 3, 3, 3, 5, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3,
    3, 1,
  ];
  this.datafieldtypes_avtypes = [
    "normal",
    "avnozero",
    "avnozero",
    "normal",
    "normal",
    "normal",
    "startzero",
    "normal",
    "avnozero",
    "avnozero",
    "avnozero",
    "normal",
    "normal",
    "nozero",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
    "normal",
  ];
  this.datafieldtypes_o = [];
  this.datafieldtypes_avtypes_o = [];
  this.datafieldtypes_avpoints_o = [];
  this.datafieldtypes_o_display = [];
  this.datafieldtypes_o_display[101] = "Pulse";
  this.datafieldtypes_o_display[102] = "Distance from line";
  this.datafieldtypes_o_display[103] = "Distance along line";
  this.datafieldtypes_avpoints_o[101] = 3;
  this.datafieldtypes_avpoints_o[102] = 3;
  this.datafieldtypes_avpoints_o[103] = 3;
  this.datafieldtypes_avtypes_o[101] = "normal";
  this.datafieldtypes_avtypes_o[102] = "normal";
  this.datafieldtypes_avtypes_o[103] = "normal";
  this.datafieldtypes_o[101] = "pulse";
  this.datafieldtypes_o[102] = "distance-from-line";
  this.datafieldtypes_o[103] = "distance-along-line";
  this.used_fieldtypes = new Array();
  this.settings.autocourse_separation = 20;
  this.settings.coursedefinition_mode = 0;
  this.settings.routeedit_mode = 1;
  this.settings.ele_moveaverage_points = 5;
  this.settings.snapcourse_check_extra_seconds = 10;
  this.settings.snapcourse_max_allowed_timestep = 60;
  this.settings.snapcourse_withinseconds_startsearch = 60;
  this.settings.snapcourse_max_allowed_distance = 70;
  this.settings.snapcourse_maxpercentoffdist = 30;
  this.settings.coursefit_rnr = 0;
  this.settings.coursefit_lnr = 0;
  this.settings.coursefit_modpoint = null;
  if (istouchscreen) {
    this.showrouteswhilepanning = 0;
  }
  var f = 0;
  this.printgraph = 0;
  this.printwidth = 1000;
  this.printheight = 500;
  this.segments = null;
  this.numsegments = 0;
  this.ant_rechecks = 0;
  this.autornr1 = 0;
  this.autornr2 = 1;
  this.video = null;
  this.videooffset = 0;
  this.videosyncroute = 0;
  this.videospeed = 1;
  this.debug = 0;
  this.videodialogbox = $("#videodialog");
  this.videodialogbox.dialog();
  this.videodialogbox.dialog("close");
  this.xdialogbox = $("#xdialog");
  this.xdialogbox.dialog();
  this.xdialogbox.dialog("close");
  this.dialogbox = $("#dialog");
  this.dialogbox.dialog();
  this.dialogbox.dialog("close");
  $("#infobox").before(
    '<div id="fulldialog_outer" style="position:absolute;width:100%;height:100%;background:#ffffff;z-index:2000;text-align:center;display:none;"><div id="fulldialog_inner" style="overflow-y:scroll;height:100%;"><div id="fulldialog" style="text-align:left;margin-left:50px;margin-top:20px;max-width:1200px"></div></div></div>'
  );
  this.initvalue_mousemove = null;
  this.livetimer = null;
  this.livedatapos = 0;
  this.livedelay = 45;
  this.liveupdate = 20;
  this.liveunits = new Array();
  this.IsLive = 0;
  this.liveproblems = 1;
  this.liveserver = "../live";
  this.liveformat = "text";
  this.liveid = 12345;
  this.livedata_waiting = new Array();
  this.realtime = 0;
  this.PanTimeFactor = 1;
  if (xc) {
    this.linecolors = new Array(
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666",
      "0000FF",
      "FF0000",
      "006400",
      "ffff00",
      "DAA520",
      "9900ff",
      "e06666",
      "ff00ff",
      "660000",
      "3d85c6",
      "00ff00",
      "ea9999",
      "ffe599",
      "00ffff",
      "b45f06",
      "8e7cc3",
      "2E8B57",
      "7FFF00",
      "a64d79",
      "6fa8dc",
      "666666"
    );
  } else {
    this.linecolors = new Array(
      "0000FF",
      "FF0000",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A",
      "FF0000",
      "0000FF",
      "006400",
      "8A2BE2",
      "DAA520",
      "008B8B",
      "2E8B57",
      "7FFF00",
      "DC143C",
      "A52A2A"
    );
  }
  this.segcolors = new Array(
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603",
    "83157c",
    "0000aa",
    "8896c6",
    "AAcce3",
    "888888",
    "aa0000",
    "006D2C",
    "A63603"
  );
  this.hillcolors = new Array("00aa00", "777777", "aa0000", "0000aa");
  this.hilltypes = new Array("Downhill", "Flat", "Uphill", "Separator");
  this.hillcolorsongraph = new Array(
    "rgba(0,200,0,0.1)",
    "rgba(100,100,100,0.1)",
    "rgba(200,0,0,0.1)",
    "rgba(0,0,200,0.5)"
  );
  this.hillcolorsongraph2 = new Array(
    "rgba(0,200,0,0.15)",
    "rgba(100,100,100,0.15)",
    "rgba(200,0,0,0.15)",
    "rgba(0,0,200,0.5)"
  );
  this.gradedhillcolorsup = new Array(
    "rgba(119,119,119,0.9)",
    "rgba(155,70,70,0.9)",
    "rgba(131,60,60, 0.9)",
    "rgba(107,51,51, 0.9)",
    "rgba(83,41,41, 0.9)",
    "rgba(60,32,32, 0.9)"
  );
  this.gradedhillcolorsdown = new Array(
    "rgba(119,119,119,0.9)",
    "rgba(83,119,83, 0.9)",
    "rgba(59,119,59, 0.9)",
    "rgba(23,119,23, 0.9)",
    "rgba(11,119,11, 0.9)",
    "rgba(0,119,0, 0.9)"
  );
  this.updateinfobottomdiv = function () {
    if (xc) {
      $("#" + this.infobottomdiv).html("");
      z.settings.showcourse = 2;
      this.add_dragdrop();
    } else {
      if (!z.settings.calibrationmode) {
        z.printquicksettings_buttons();
      } else {
        $("#" + this.infobottomdiv).html(
          "<span class=bottomtitle>Calibration</span><br>"
        );
        $("#" + this.infobottomdiv).append("Drag to calibrate");
      }
    }
    $("#" + this.infobottomdiv)
      .children("a")
      .css("cursor", "pointer");
    $("#" + this.infobottomdiv)
      .children("a")
      .css("color", "#0000ff");
    $("#" + this.infobottomdiv)
      .children("a")
      .css("font-weight", "bold");
    if (mapviewer) {
      add_pacecolorslider();
    }
  };
  this.printquicksettings = function () {
    var M = parseInt($("#savesavezoom").val());
    if (!M) {
      M = 0;
    }
    $("#" + this.infobottomdiv).html(
      "<span class=bottomtitle>Quick Settings</span><br>"
    );
    if (this.settings.tagging_timealt) {
      $("#" + this.infobottomdiv).append(
        "DeltaT: " + z.currenttime_delta + " seconds<br>"
      );
      if (z.currenttag) {
        $("#" + this.infobottomdiv).append(
          "Next point: " +
            tominsec(z.currenttag.currenttime + z.currenttime_delta) +
            "<br><br>Altitude now: " +
            z.currenttag.currentalt +
            "<br><br>"
        );
      }
    }
    $("#" + this.infobottomdiv).append(
      'Tail: <a class="tooltip" title="Shorten tail" onclick="mapviewer.keypress(\'R\')">&lt</a> ' +
        tominsec(this.settings.taillength) +
        ' <a class="tooltip" title="Increase tail" onclick="mapviewer.keypress(\'T\')">&gt</a> (R/T to change)<br>'
    );
    $("#" + this.infobottomdiv).append(
      'LineWidth: <a class="tooltip"  title="Thinner line" onclick="mapviewer.keypress(\'K\')">&lt</a> ' +
        z.settings.routewidth +
        'px <a class="tooltip"  title="Thicker line" onclick="mapviewer.keypress(\'L\')">&gt</a> (K/L to change)<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="Play/pause" onclick="mapviewer.keypress(\'P\')">P</a> to play/pause<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="Reset to real-time. You can see where the runners are compared to eachother in the course at a given time." onclick="mapviewer.keypress(\'O\')">O</a> to reset all to real time<br>'
    );
    $("#" + this.infobottomdiv).append("Use +/- to zoom<br>");
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="Back 1 minute" onclick="mapviewer.keypress(\'N\')">N</a>/<a class="tooltip" title="Forward 1 minute" onclick="mapviewer.keypress(\'M\')">M</a> to go back/forward in time<br>'
    );
    $("#" + this.infobottomdiv).append("Use arrows keys to pan<br>");
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="Toggle legend type. For the ordered legend type, you can move the complete legend by holding the left mouse button and the Alt-key while moving the mouse." onclick="mapviewer.keypress(\'A\')">A</a> to toggle legend type<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="Save an analysis state for later retrieval. Note that you need to be logged in to save an analysis state. If you are not logged in, you can open a second browser window and log in there before trying again." onclick="mapviewer.keypress(\'S\')">S</a> to save analysis state<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <aclass="tooltip"  title="Center selected runner during replay" onclick="mapviewer.keypress(\'C\')">C</a> to center map on runner<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'B\')">B</a>/<a title="" onclick="mapviewer.keypress(\'V\')">V</a> to go change centered runner<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a class="tooltip" title="" onclick="mapviewer.keypress(\'G\')">G</a> to toggle mapreading analysis<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'Q\')">Q</a> to show splitsbrowser for autO<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'0\')">0</a> to show all complete routes<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'1\')">1</a> to show pace graph<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'3\')">3</a> to color by pace/pulse (experimental)<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'4\')">4</a> / <a title="" onclick="mapviewer.keypress(\'5\')">5</a> to show tag overview<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'6\')">6</a> to show/hide tags<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'7\')">7</a> to toggle annotation mode<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'8\')">8</a>/<a title="" onclick="mapviewer.keypress(\'9\')">9</a> to go change map opacity<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'2\')">2</a> to open settings dialog<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'W\')">W</a> to show splits table (exp)<br>'
    );
    $("#" + this.infobottomdiv).append(
      'Use <a title="" onclick="mapviewer.keypress(\'H\')">H</a> for HeadCam analysis (exp)<br>'
    );
    $("#" + this.infobottomdiv).append(
      "Use SHIFT+R to recalibrate map (exp)<br>"
    );
    $("#" + this.infobottomdiv).append("Experimental replay autorotate:<br>");
    $("#" + this.infobottomdiv).append(
      '<a title="" onclick="mapviewer.settings.modes.replay_autorotate=0;">Off</a> / <a title="" onclick="mapviewer.settings.modes.replay_autorotate=1;if (mapviewer.center_map_on_runner==0) {mapviewer.keypress(\'C\')} ">Rotate runner</a> /  <a title="" onclick="mapviewer.settings.modes.replay_autorotate=2;if (mapviewer.center_map_on_runner==0) {mapviewer.keypress(\'C\')}">Rotate leg</a>'
    );
    $("#" + this.infobottomdiv).append(
      'Toggle <a href="javascript:void(0);" onclick="if (mapviewer.settings.alwaysshowcourse==0) {mapviewer.settings.alwaysshowcourse=1;mapviewer.request_redraw();} else {mapviewer.settings.alwaysshowcourse=0;mapviewer.request_redraw();}">always view course</a><br>'
    );
    $("#" + this.infobottomdiv).append(
      '<br><a title="" onclick="mapviewer.toggle_rotation();">Toggle rotation (Rotate=Alt+mouse)</a><br>(Experimental)<br>'
    );
    $(".tooltip").tooltipster({
      animation: "fade",
      delay: 500,
      maxWidth: 350,
      position: "left",
      trigger: "hover",
    });
    if (this.settings.enableprintscreen || courseplanning) {
      $("#" + this.infobottomdiv).append(
        z.printselect(
          "<h4>Export image</h4>Save current view to JPG",
          "savesavezoom",
          "0:Zoom as shown|100:Original map size|300:300% of shown size|200:200% of shown size|150:150% of shown size|90:90% of shown size|80:80% of shown size|70:70% of shown size|60:60% of shown size|50:50% of shown size|25:25% of shown size",
          M
        )
      );
      this.addbutton(this.infobottomdiv, "saveview", "Save JPG");
      $("#" + this.infobottomdiv).append(
        '<br><i>(Works only in Google Chrome)</i> Save complete map: <a onclick="mapviewer.savecompletemap_withcourse_and_sketch(0.8);">v1</a> / <a onclick="mapviewer.savecompletemap_withcourse_and_sketch(0.2);">v2</a> / <a onclick="mapviewer.savecompletemap_withcourse_and_sketch(0.001);">v3</a> -'
      );
      $("#saveview").bind("click", function (Q, R) {
        var N;
        if (z.map.id == "localimage") {
          N = z.map.name;
        } else {
          N = "img";
        }
        if (!z.settings.saveviewcounter) {
          z.settings.saveviewcounter = 0;
        }
        z.settings.saveviewcounter++;
        var S = N + "_" + z.settings.saveviewcounter;
        var O = parseInt($("#savesavezoom").val());
        z.settings.isprinting = 1;
        if (O == 0) {
          z.redraw();
          z.play_loop();
          z.canvas.saveDataURL(S);
        } else {
          z.savearea_zoom(parseFloat(O / 100), S);
        }
        z.settings.isprinting = 0;
      });
      this.addbutton(
        this.infobottomdiv,
        "saveroutestojson",
        "Save Routes to JSON"
      );
      $("#saveroutestojson").bind("click", function (N, O) {
        z.open_dialog("saveroutesandcourse", null);
      });
    }
  };
  this.set_prettygraphsettings = function () {
    mapviewer.settings.graphsettings.barplotstackedangle = -20;
    mapviewer.settings.graphsettings.barplotstackedfontsize = "14pt";
    mapviewer.settings.graphsettings.barplotstacked_writelaptxt = 1;
    mapviewer.settings.nowritejqplot = 1;
  };
  this.saveview = function () {
    var M;
    if (z.map.id == "localimage") {
      M = z.map.name;
    } else {
      M = "img";
    }
    if (!z.settings.saveviewcounter) {
      z.settings.saveviewcounter = 0;
    }
    z.settings.saveviewcounter++;
    var O = M + "_" + z.settings.saveviewcounter;
    var N = parseInt($("#savesavezoom").val());
    z.settings.isprinting = 1;
    if (N == 0) {
      z.redraw();
      z.play_loop();
      z.canvas.saveDataURL(O);
    } else {
      z.savearea_zoom(parseFloat(N / 100), O);
    }
    z.settings.isprinting = 0;
  };
  this.printquickbutton = function (R, O, N) {
    var M = "";
    if (N) {
      M = "title='" + N + "'";
    }
    var Q =
      '<div style="height:22px;float:left;"' +
      M +
      '><a href="javascript:void(0);" class="cbutton" onclick="' +
      O +
      '">' +
      R +
      "</a></div>";
    return Q;
  };
  this.printquickbutton_onoff = function (R, O, N) {
    ischecked = "";
    if (N == 1) {
      ischecked = " checked ";
    }
    var M = R;
    var Q =
      '<div style="float:left;"><div class="onoffswitch" > <input type="checkbox" name="' +
      M +
      '" class="onoffswitch-checkbox" id="' +
      R +
      '"  onclick="' +
      O +
      '" ' +
      ischecked +
      '> <label class="onoffswitch-label" for="' +
      R +
      '"> <span class="onoffswitch-inner"></span> <span class="onoffswitch-switch"></span> </label> </div></div>';
    return Q;
  };
  this.printquickbutton_onoff = function (R, O, N) {
    ischecked = "";
    if (N == 1) {
      ischecked = " checked ";
    }
    var M = R;
    var Q =
      '<div style="float:left;"><div class="onoffswitch" > <input type="checkbox" name="' +
      M +
      '" class="onoffswitch-checkbox" id="' +
      R +
      '"  onclick="' +
      O +
      '" ' +
      ischecked +
      '> <label class="onoffswitch-label" for="' +
      R +
      '"> <span class="onoffswitch-inner"></span> <span class="onoffswitch-switch"></span> </label> </div></div>';
    return Q;
  };
  this.printselect = function (Z, O, U, X, Y, W, V) {
    if (!V) {
      V = "";
    } else {
      V = ' onChange="' + V + '" ';
    }
    var M;
    if (!Y) {
      Y = "verlabel";
    }
    var N = "height:30px;";
    if (O.match("multiple")) {
      N = "margin-bottom:8px;";
    }
    if (Y == "verlabel") {
      M = "<font size=1>" + Z + "</font><br>";
    } else {
      if (Y == "horlabel") {
        M = z.printquickbutton_label(
          Z,
          "font-size:10px;font-weight:normal;margin-top:4px;width:70px",
          W,
          O + "_label"
        );
        M = M + '<div style="height:26px">';
      } else {
        if (Y == "horlabelwide") {
          M = z.printquickbutton_label(
            Z,
            "font-size:10px;font-weight:normal;margin-top:4px;width:150px",
            W,
            O + "_label"
          );
          M = M + '<div style="' + N + '">';
        }
      }
    }
    if (O.match("multiple")) {
      M += "<select " + V + ' multiple id="' + O + '">';
    } else {
      M += "<select " + V + ' id="' + O + '">';
    }
    if (U) {
      options = U.split("|");
    } else {
      options = "--------------------";
    }
    for (var ab = 0; ab < options.length; ab++) {
      var S;
      var aa;
      if (options[ab].match(/\d\d:\d\d - \d\d:\d\d/)) {
        S = options[ab];
        aa = S;
      } else {
        var T = options[ab].split(":");
        S = T[0];
        aa = T[1];
      }
      if (!aa) {
        aa = S;
      }
      var R;
      if ($.isArray(X)) {
        var R = "";
        for (var Q = 0; Q < X.length; Q++) {
          if (S == X[Q]) {
            R = " selected ";
          }
        }
      } else {
        if (S == X) {
          R = " selected ";
        } else {
          R = "";
        }
      }
      M += '<option value="' + S + '"' + R + ">" + aa + "</option>";
    }
    M += "</select>";
    if (Y == "verlabel") {
      M += "<br>";
    }
    if (Y == "horlabel") {
      M += '</div><div style="clear:both"></div>';
    }
    if (Y == "horlabelwide") {
      M += '</div><div style="clear:both"></div>';
    }
    return M;
  };
  this.printentry = function (O, N, R, T, Q, S) {
    var M;
    if (!Q) {
      Q = "verlabel";
    }
    if (Q == "verlabel") {
      M = "<font size=1>" + O + "</font><br>";
    } else {
      if (Q == "horlabel") {
        M = z.printquickbutton_label(
          O,
          "font-size:10px;font-weight:normal;margin-top:4px;width:70px",
          S,
          N + "_label"
        );
      } else {
        if (Q == "horlabelwide") {
          M = z.printquickbutton_label(
            O,
            "font-size:10px;font-weight:normal;margin-top:4px;width:150px",
            S,
            N + "_label"
          );
        }
      }
    }
    if (R == "text") {
      M = M + '<div style="height:30px;">';
      M += '<input size=30 id="' + N + '" value="' + T + '">';
    } else {
      if (R == "text-40") {
        M = M + '<div style="height:30px;">';
        M += '<input size=40 id="' + N + '" value="' + T + '">';
      } else {
        if (R == "textarea") {
          M = M + '<div style="margin-bottom:10px;">';
          M += '<textarea cols=40 rows=4 id="' + N + '">' + T + "</textarea>";
        }
      }
    }
    if (Q == "verlabel") {
      M += "<br>";
    }
    if (Q == "horlabel") {
      M += '</div><div style="clear:both"></div>';
    }
    if (Q == "horlabelwide") {
      M += '</div><div style="clear:both"></div>';
    }
    return M;
  };
  this.printquickbutton_label = function (S, N, O, T) {
    var R;
    var M;
    if (N == "middle") {
      M = "width:60px;text-align:center;";
    } else {
      if (N == "onoff") {
        M = "width:70px;position:relative;top:3px;";
      } else {
        if (N == "left" || N == "") {
          M = "width:70px;";
        } else {
          M = N;
        }
      }
    }
    var Q = "";
    if (T) {
      Q = 'id="' + T + '"';
    }
    if (O) {
      R =
        "<div " +
        Q +
        ' class="tooltip" title="' +
        O +
        '" style="cursor:help;float:left;' +
        M +
        '"><b>' +
        S +
        "</b></div>";
    } else {
      R =
        '<div id="' +
        T +
        '"  style="float:left;' +
        M +
        '"><b>' +
        S +
        "</b></div>";
    }
    return R;
  };
  this.printquickbutton_toggle = function (U, S, T, Q, O, N, M) {
    var R;
    R =
      '<div style="height:26px;' +
      M +
      '">' +
      z.printquickbutton_label(S, "onoff", N, T + "_label") +
      z.printquickbutton_onoff(T, Q, O) +
      '</div><div style="clear:both"></div>';
    if (U) {
      $("#" + U).append(R);
    }
    return R;
  };
  this.printquickbutton_updown = function (S, U, O, M, Q, N, R, T) {
    return (
      "<div>" +
      z.printquickbutton_label(S, "", R, T + "_label") +
      z.printquickbutton(U, O) +
      z.printquickbutton_label(N, "middle", "", T + "_val") +
      z.printquickbutton(M, Q) +
      '</div><div style="clear:both"></div>'
    );
  };
  this.printquicksettings_buttons = function () {
    var Q = parseInt($("#savesavezoom").val());
    if (!Q) {
      Q = 0;
    }
    if (courseplanning) {
      $("#" + this.infobottomdiv).html("<h4>Settings</h4>");
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Route width",
          "&lt;",
          "mapviewer.keypress('K')",
          "&gt;",
          "mapviewer.keypress('L')",
          this.settings.routewidth + " px",
          "Change tail length. Shortcut: 'K' to reduce, 'L' to increase",
          "linewidthbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Route opacity",
          "&lt;",
          "mapviewer.reducerouteopacity();",
          "&gt;",
          "mapviewer.increaserouteopacity();",
          parseInt(this.settings.routeopacity * 100) + " %",
          "Change map opacity. Shortcut: Shift+'8' to reduce, Shift+'9' to increase",
          "lineopacitybutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Map opacity",
          "&lt;",
          "mapviewer.keypress('8')",
          "&gt;",
          "mapviewer.keypress('9')",
          parseInt(this.settings.mapopacity * 100) + " %",
          "Change map opacity. Shortcut: '8' to reduce, '9' to increase",
          "mapopacitybutt"
        )
      );
      z.printquickbutton_toggle(
        this.infobottomdiv,
        "Show course",
        "id_showcourse",
        "if (mapviewer.settings.showcourse==0) {mapviewer.settings.showcourse=1;} else {mapviewer.settings.showcourse=0}; mapviewer.request_redraw();mapviewer.showcoursebutt_check();",
        z.settings.showcourse,
        "Show/hide course"
      );
    } else {
      $("#" + this.infobottomdiv).html(
        "<div class=bottomtitle2>Settings</div>"
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          'Tail [<a title="Set zero tail length (no tails)" href="javascript:void(0);" onclick="mapviewer.set_tail_length(0);">0</a>/<a title="Set infinity tail length." href="javascript:void(0);" onclick="mapviewer.set_tail_length(999*60);">Max</a>]',
          "&lt;",
          "mapviewer.keypress('R')",
          "&gt;",
          "mapviewer.keypress('T')",
          tominsec(this.settings.taillength),
          "Change tail length. Shortcut: 'R' to shorten, 'T' to lengthen. Click the text 'Max' to set infinite tail length and 0 to set the tail length to zero.",
          "taillengthbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Line width",
          "&lt;",
          "mapviewer.keypress('K')",
          "&gt;",
          "mapviewer.keypress('L')",
          this.settings.routewidth + " px",
          "Change tail length. Shortcut: 'K' to reduce, 'L' to increase",
          "linewidthbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Map opacity",
          "&lt;",
          "mapviewer.keypress('8')",
          "&gt;",
          "mapviewer.keypress('9')",
          parseInt(this.settings.mapopacity * 100) + " %",
          "Change map opacity. Shortcut: '8' to reduce, '9' to increase",
          "mapopacitybutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Route opacity",
          "&lt;",
          "mapviewer.reducerouteopacity();",
          "&gt;",
          "mapviewer.increaserouteopacity();",
          parseInt(this.settings.routeopacity * 100) + " %",
          "Change map opacity. Shortcut: Shift+'8' to reduce, Shift+'9' to increase",
          "lineopacitybutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Label pos",
          "&lt;",
          "mapviewer.change_legendtype(-1);",
          "&gt;",
          "mapviewer.change_legendtype(1);",
          z.settings.legendtypes[z.settings.legendtype],
          "Change legend position. Shortcut: 'A' to toggle legend. Alt + left mouse button to move legend",
          "legendposbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Label info",
          "&lt;",
          "mapviewer.change_legendinfo(-1);",
          "&gt;",
          "mapviewer.change_legendinfo(1);",
          z.settings.legendinfos[z.settings.legendinfo],
          "Change legend info\nN = Name, L = Length, P = Pace, IO = In/Out of control\nUse advanced options to change control ring size for IO",
          "legendinfobutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Color mode",
          "&lt;",
          "mapviewer.toggleColormode(-1);",
          "&gt;",
          "mapviewer.toggleColormode(1);",
          z.settings.colormodes[z.settings.colormode],
          "Change line coloring. Shortcut: '3' to toggle color type",
          "colormodebutt"
        )
      );
      var R = "-";
      if (z.settings.colormode > 2) {
        R = z.settings.colorAnalysismodes[z.settings.pacecoloring.type];
      }
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "ColorAnalysis",
          "&lt;",
          "mapviewer.toggleColorAnalysismode(-1);",
          "&gt;",
          "mapviewer.toggleColorAnalysismode(1);",
          R,
          "Change color analysis type - only possible for Pace/Pulse color mode.\nMode 0: Color gradient by value from green (slow pace / low pulse) to red (high pace / high pulse)\nMode 1: As Mode 0, but with thin center line in ahtlete color\nMode 2: Thick line only outside the pace/pulse range set in advanced settings.\nMode 3: Three color threshold coloring; green for below chosen range in advanced settings.\n                Orange for chosen range. Red for above chosen range.\nMode 4: As mode 2, but thick line inside chosen range.\n Shortcut: SHIFT+'3' to toggle color analysis type",
          "coloranalysisbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "Dot step",
          "&lt;",
          "mapviewer.change_dotstep(-1);",
          "&gt;",
          "mapviewer.change_dotstep(+1);",
          this.settings.dotstep + " s",
          "Change dotstep",
          "dotstepbutt"
        )
      );
      z.printquickbutton_toggle(
        this.infobottomdiv,
        "Show course",
        "id_showcourse",
        "if (mapviewer.settings.showcourse==0) {mapviewer.settings.showcourse=1;} else {mapviewer.settings.showcourse=0}; mapviewer.request_redraw();mapviewer.showcoursebutt_check();",
        z.settings.showcourse,
        "Show/hide course"
      );
      z.printquickbutton_toggle(
        this.infobottomdiv,
        "AutoCenter",
        "id_autocenter",
        "mapviewer.keypress('C')",
        z.center_map_on_runner,
        "Replay mode: Centering on/off for chosen athlete\nSplit mode: AutoCenter and rotate chosen split"
      );
      var R = "-";
      var V = z.routes[z.route_to_center];
      if (V) {
        R = V.runnername_short;
      }
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "CenterRunner",
          "&lt;",
          "mapviewer.keypress('B')",
          "&gt;",
          "mapviewer.keypress('V')",
          R,
          "Replay mode only when AutoCenter is on: Choose which runner to center on in replay mode",
          "centerrunnerbutt"
        )
      );
      $("#" + this.infobottomdiv).append(
        z.printquickbutton_updown(
          "AutRot angle",
          "&lt;",
          "mapviewer.change_autrotangle(-1);",
          "&gt;",
          "mapviewer.change_autrotangle(1);",
          z.settings.autrotanglemodes[z.settings.autrotanglemode],
          "Split analysis only when AutoCenter is on: Which angle to show leg/split in when autocenter/rotate",
          "autorotanglebutt"
        )
      );
      var R = 0;
      if ($("#realtimesliderdiv").css("display") == "none") {
        R = 0;
      } else {
        R = 1;
      }
      z.printquickbutton_toggle(
        this.infobottomdiv,
        "Time slider",
        "id_timeslider",
        "mapviewer.toggle_timeslider()",
        R,
        "Toggle time slider on/off in replay-mode. Turning on automatically changes to replay mode."
      );
    }
    if (!courseplanning) {
      z.printquickbutton_toggle(
        this.infobottomdiv,
        "GroupReplay",
        "id_groupreplaymode",
        "mapviewer.grouping_toggle()",
        z.settings.showgrouping,
        "Grouping Mode: Show groups during replay"
      );
    }
    z.printquickbutton_toggle(
      this.infobottomdiv,
      "SketchMode",
      "id_sketchmode",
      "mapviewer.sketchmode_toggle()",
      z.settings.sketchmode,
      "Sketch Mode: Highlight features for simplification map"
    );
    var M = "none";
    if (z.settings.sketchmode) {
      M = "block";
    }
    var W =
      '<div style="border-top:1px solid #080;border-bottom:1px solid #080;padding-top:5px;padding-bottom:5px;background:#ddd;display:' +
      M +
      '" id="sketch_settings_id"></div>';
    $("#" + this.infobottomdiv).append(W);
    z.printquickbutton_toggle(
      "sketch_settings_id",
      "DrawSketch",
      "id_sketchmode_start",
      "mapviewer.sketchmode_startstopsketch()",
      z.settings.is_sketching,
      "Start sketching. Sketch-mode can also be invoked by holding shift key while moving mouse."
    );
    $("#sketch_settings_id").append(
      z.printquickbutton_updown(
        "Sketch size",
        "&lt;",
        "mapviewer.sketchmode_brushsize(-1);",
        "&gt;",
        "mapviewer.sketchmode_brushsize(1);",
        this.settings.sketchmode_pointsize + " px",
        "Change Sketch brushsize",
        "brushsizebutt"
      )
    );
    $("#sketch_settings_id").append(
      z.printquickbutton_updown(
        "Sketch mode",
        "&lt;",
        "mapviewer.sketchmode_setmode(-1);",
        "&gt;",
        "mapviewer.sketchmode_setmode(1);",
        z.settings.sketchmodes[z.settings.sketchmode_mode],
        "Change mode between drawing and deleting",
        "sketchmodesetbutt"
      )
    );
    var R = 0;
    if (z.canvas) {
      if (z.canvas.mouse_rotate == 1) {
        R = 1;
      }
    }
    z.printquickbutton_toggle(
      this.infobottomdiv,
      'Map rot [<a href="javascript:void(0);" onclick="mapviewer.toggle_rotation(1);">0deg</a>]',
      "id_maprot",
      "mapviewer.toggle_rotation()",
      R,
      "Toggle rotation of map (Rotate map using Alt+mouse)"
    );
    var S = 20;
    if (z.canvas) {
      S = z.canvas.outlinetxtsize;
    }
    var O =
      "6:6|8:8|10:10|12:12|14:14|16:16|18:18|20:20|22:22|24:24|26:26|28:28|30:30|35:35|40:40|45:45|50:50|60:60|70:70|80:80|90:90|100:100";
    var U = z.printselect(
      "Font size",
      "changefontsize_select",
      O,
      S,
      "horlabel",
      "Choose font size for legends and other information on the map"
    );
    $("#" + this.infobottomdiv).append(U);
    $("#changefontsize_select").bind("change", function (X, Y) {
      z.canvas.outlinetxtsize = $("#changefontsize_select").val();
      z.request_redraw();
    });
    if (!courseplanning) {
      this.addbutton(this.infobottomdiv, "advancedoptions", "Advanced options");
      $("#advancedoptions").bind("click", function (X, Y) {
        z.OpenSettings();
      });
      $("#" + this.infobottomdiv).append("<br><hr>");
      $("#" + this.infobottomdiv).append(
        'Use <a  class="tooltip" title="Save an analysis state for later retrieval. Note that you need to be logged in to save an analysis state. If you are not logged in, you can open a second browser window and log in there before trying again." onclick="mapviewer.keypress(\'S\')">S</a> to save analysis state<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'Q\')">Q</a> to show splitsbrowser for autO<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'0\')">0</a> to show all complete routes<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'1\')">1</a> to show pace graph<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'4\')">4</a> / <a title="" onclick="mapviewer.keypress(\'5\')">5</a> to show tag overview<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'6\')">6</a> to show/hide tags<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'7\')">7</a> to toggle annotation mode<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'W\')">W</a> to show splits table (exp)<br>'
      );
      $("#" + this.infobottomdiv).append(
        'Use <a title="" onclick="mapviewer.keypress(\'H\')">H</a> for HeadCam analysis (exp)<br>'
      );
      $("#" + this.infobottomdiv).append(
        "Use SHIFT+R to recalibrate map (exp)<br>"
      );
      $("#" + this.infobottomdiv).append("Experimental replay autorotate:<br>");
      $("#" + this.infobottomdiv).append(
        '<a title="" onclick="mapviewer.settings.modes.replay_autorotate=0;">Off</a> / <a title="" onclick="mapviewer.settings.modes.replay_autorotate=1;if (mapviewer.center_map_on_runner==0) {mapviewer.keypress(\'C\')} ">Rotate runner</a> /  <a title="" onclick="mapviewer.settings.modes.replay_autorotate=2;if (mapviewer.center_map_on_runner==0) {mapviewer.keypress(\'C\')}">Rotate leg</a>'
      );
      if (!courseplanning) {
        $("#" + this.infobottomdiv).append(
          'Use <a title="" onclick="mapviewer.keypress(\'0\')">0</a> to show all complete routes<br>'
        );
      }
    }
    $(".tooltip").tooltipster({
      animation: "fade",
      delay: 500,
      maxWidth: 350,
      trigger: "hover",
      position: "left",
    });
    if (
      window.location.host == "localhost" ||
      (getURLParameter("dragdrop") && !z.settings.enableprintscreen)
    ) {
      z.settings.enableprintscreen = 1;
    }
    if (z.settings.enableprintscreen || courseplanning) {
      if (z.map && z.map.id == "mapant") {
        $("#" + z.infobottomdiv).append("<hr><h4>Print course (mapant)</h4>");
        $("#" + this.infobottomdiv).append(
          "For UsynligO use 'Print course PDF' along with 'Save course XML' below. For Livelox use 'Print map KMZ' along with 'Save course XML' below.<div style=\"margin-top:4px;\"></div>"
        );
        $("#" + z.infobottomdiv).append("<hr>");
        z.printquickbutton_toggle(
          this.infobottomdiv,
          "NorthLines",
          "id_northlines",
          "mapviewer.northlines_toggle()",
          z.settings.shownorthlines,
          "Toggle north lines"
        );
        this.addbutton(z.infobottomdiv, "orientnorth", "Rotate to NorthLines");
        $("#" + z.infobottomdiv).append("<hr>");
        $("#" + z.infobottomdiv).append(
          '<table cellpadding=1><tr><td><font size=1><b>Print scale:</b></font></td><td><input size=6 id="printscale" value="' +
            z.settings.printscale +
            '"></td></tr></table>'
        );
        $("#" + z.infobottomdiv).append(
          z.printselect(
            "Paper size",
            "papersize",
            "0:A4 portrait|1:A4 landscape|2:A3 portrait|3:A3 landscape|4:A5 portrait|5:A5 landscape|6:Letter portrait|7:Letter landscape",
            z.settings.papersize
          )
        );
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(z.infobottomdiv, "setprint", "Set print area");
        $("#" + z.infobottomdiv).append(
          '<div style="margin-top:4px;margin-bottom:4px;" id="printinfo"></div>'
        );
        $("#" + z.infobottomdiv).append("<hr>");
        z.settings.courseopacity = 0.7;
        z.settings.coursewidthmult = 1.6;
        z.settings.controlRadius = 50;
        z.settings.showcoursecontrolnumbers = 1;
        z.settings.coursewhitebackground = 1;
        z.settings.coursecolor = "a626ff";
        z.settings.northlineswidth = 2;
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        var S = z.settings.controlnumberfontsize;
        if (!z.settings.showcoursecontrolnumbers) {
          S = 0;
        }
        var O =
          "0:None|12:12pt|14:14pt|16:16pt|18:18pt|20:20pt|22:22pt|24:24pt|26:26pt|28:28pt|30:30pt|35:35pt|40:40pt|45:45pt|50:50pt|60:60pt|70:70pt|80:80pt|90:90pt|100:100pt|120:120pt|140:140pt|160:160pt";
        var U = z.printselect(
          "Ctrl-numbers",
          "changecontrolfontsize_select",
          O,
          S,
          "horlabel",
          "Choose control number font size"
        );
        $("#" + this.infobottomdiv).append(U);
        $("#changecontrolfontsize_select").bind("change", function (X, Y) {
          var Z = parseInt($("#changecontrolfontsize_select").val());
          if (Z == 0) {
            z.settings.showcoursecontrolnumbers = 0;
          } else {
            z.settings.showcoursecontrolnumbers = 1;
            z.settings.controlnumberfontsize = Z;
          }
          z.request_redraw();
        });
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        var S = z.settings.infotxtfontsize;
        var O =
          "0:None|12:12pt|14:14pt|16:16pt|18:18pt|20:20pt|22:22pt|24:24pt|26:26pt|28:28pt|30:30pt|35:35pt|40:40pt|45:45pt|50:50pt|60:60pt|70:70pt|80:80pt|90:90pt|100:100pt|120:120pt|140:140pt|160:160pt|180:180pt|200:200pt|220:220pt|-12:12pt-bg|-14:14pt-white|-16:16pt-white|-18:18pt-white|-20:20pt-white|-22:22pt-white|-24:24pt-white|-26:26pt-white|-28:28pt-white|-30:30pt-white|-35:35pt-white|-40:40pt-white|-45:45pt-white|-50:50pt-white|-60:60pt-white|-70:70pt-white|-80:80pt-white|-90:90pt-white|-100:100pt-white|-120:120pt-white|-140:140pt-white|-160:160pt-white|-180:180pt-white|-200:200pt-white|-220:220pt-white1";
        var U = z.printselect(
          "Info txt",
          "changeinfotxtfontsize_select",
          O,
          S,
          "horlabel",
          "Choose into text font size"
        );
        $("#" + this.infobottomdiv).append(U);
        $("#changeinfotxtfontsize_select").bind("change", function (X, Y) {
          var Z = parseInt($("#changeinfotxtfontsize_select").val());
          z.settings.infotxtfontsize = Z;
          z.request_redraw();
        });
        $("#" + z.infobottomdiv).append(
          '<div style="margin-top:4px;"></div><hr>'
        );
        $("#" + z.infobottomdiv).append(
          '<table cellpadding=1><tr><td><font size=1><b>Name:</b></font></td><td><input size=12 id="infotxt" value="' +
            z.settings.nameinfotxt +
            '" onChange="mapviewer.settings.nameinfotxt=$(\'#infotxt\').val()"></td></tr></table>'
        );
        $("#" + z.infobottomdiv).append(
          '<div style="margin-top:4px;"></div><hr>'
        );
        this.addbutton(z.infobottomdiv, "printcoursepdf", "Print course PDF");
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(z.infobottomdiv, "printcoursepng", "Print course PNG");
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(z.infobottomdiv, "printcoursekmz", "Print course KMZ");
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(z.infobottomdiv, "printmapkmz", "Print map KMZ");
        $("#" + this.infobottomdiv).append("<hr>");
        $("#" + z.infobottomdiv).append("<hr><h4>Export course file</h4>");
        $("#" + this.infobottomdiv).append(
          'The XML course file can be imported into e.g. UsynligO or Livelox.<div style="margin-top:4px;"></div>'
        );
        this.addbutton(z.infobottomdiv, "savexmlfile", "Save course XML");
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        $("#savexmlfile").bind("click", function (X, Y) {
          mapviewer.savecourseandtags("savexmlfile", null, null);
        });
        this.addbutton(z.infobottomdiv, "savegpxfile", "Save course GPX");
        $("#savegpxfile").bind("click", function (X, Y) {
          mapviewer.savecourseandtags("savegpxfile", null, null);
        });
        Q = 100;
        $("#" + z.infobottomdiv).append("<hr><h4>Export viewport image</h4>");
        $("#" + this.infobottomdiv).append(
          "Export part of map as image (with arbitrary rotation). No world file/georeferencing is provided - needs to be georeferenced manually to be used e.g. in Livelox.<br>"
        );
        $("#" + z.infobottomdiv).append(
          z.printselect(
            "Save current view to PNG",
            "savesavezoom",
            "0:Zoom as shown|100:Original map size|300:300% of shown size|200:200% of shown size|150:150% of shown size|90:90% of shown size|80:80% of shown size|70:70% of shown size|60:60% of shown size|50:50% of shown size|25:25% of shown size",
            Q
          )
        );
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(z.infobottomdiv, "saveview", "Save viewport as PNG");
        $("#" + z.infobottomdiv).append("<hr><h4>Export full map/course</h4>");
        $("#" + this.infobottomdiv).append(
          'Export full map image (with zero rotation). Either this or the original png-file from mapant can be used in Livelox. Please use the original pgw/world file exported from mapant.<div style="margin-top:4px;"></div>'
        );
        this.addbutton(z.infobottomdiv, "savecomplete", "Save complete as PNG");
        $("#" + z.infobottomdiv).append('<div style="margin-top:4px;"></div>');
        this.addbutton(
          z.infobottomdiv,
          "savecompletejpg",
          "Save complete as JPG"
        );
        $("#" + z.infobottomdiv).append(
          '<div style="margin-top:4px;"></div><a id="setXimage">Xim</a>'
        );
        $("#savecomplete").bind("click", function (X, Y) {
          var Z = z.canvas.rotate_angle;
          z.canvas.context.rotate(-Z);
          z.redraw();
          mapviewer.savecompletemap_withcourse_and_sketch(0.8);
          z.canvas.context.rotate(Z);
        });
        $("#savecompletejpg").bind("click", function (X, Y) {
          z.settings.printscreentype = "jpg";
          var Z = z.canvas.rotate_angle;
          z.canvas.context.rotate(-Z);
          z.redraw();
          mapviewer.savecompletemap_withcourse_and_sketch(0.8);
          z.canvas.context.rotate(Z);
          z.settings.printscreentype = "png";
        });
        $("#orientnorth").bind("click", function (X, Y) {
          mapviewer.canvas.orientnorth();
        });
        $("#setprint").bind("click", function (X, Y) {
          z.settings.printscale = parseInt($("#printscale").val());
          z.waitforclick = 1;
          z.waitforclickfunction = function (Z, ac, aa) {
            var ab = new Object();
            ab.x = Z;
            ab.y = ac;
            z.waitforclick = 0;
            z.setprintarea(ab);
          };
        });
        $("#setXimage").bind("click", function (X, Y) {
          z.waitforclick = 1;
          z.waitforclickfunction = function (Z, ac, aa) {
            var ab = new Object();
            ab.x = Z;
            ab.y = ac;
            z.waitforclick = 0;
            z.setXimagepos(ab, 1);
          };
        });
        $("#printcoursepdf").bind("click", function (aa, ab) {
          if (!z.settings.printbox_rotated) {
            alert("Please define print area first!");
          } else {
            z.settings.routewidth = z.settings.routewidth * z.canvas.zoomfactor;
            var X = z.settings.printbox;
            var Z = X[3] - X[1];
            var ae = z.settings.printbox_rotated;
            z.settings.printscreentype = "jpg";
            var ad = mapviewer.savemaprectangle_custom(
              ae[0],
              ae[1],
              ae[4],
              ae[5],
              Z
            );
            z.settings.printscreentype = "png";
            var Y = "p";
            if (z.settings.papersize_name.match("landscape")) {
              Y = "l";
            }
            var ac = new jsPDF(Y, "mm", z.settings.papersize_mm);
            ac.addImage(
              ad,
              "JPG",
              0,
              0,
              z.settings.papersize_mm[0],
              z.settings.papersize_mm[1]
            );
            ac.save("course.pdf");
            z.settings.routewidth = z.settings.routewidth / z.canvas.zoomfactor;
          }
        });
        $("#printcoursepng").bind("click", function (Z, aa) {
          if (!z.settings.printbox_rotated) {
            alert("Please define print area first!");
          } else {
            var X = z.settings.printbox;
            var Y = X[3] - X[1];
            var ac = z.settings.printbox_rotated;
            var ab = mapviewer.savemaprectangle_custom(
              ac[0],
              ac[1],
              ac[4],
              ac[5],
              Y
            );
            downloadImg(ab, "course.png");
          }
        });
        $("#printcoursekmz").bind("click", function (ar, an) {
          if (!z.settings.printbox_rotated) {
            alert("Please define print area first!");
          } else {
            var X = z.settings.printbox;
            var ac = X[3] - X[1];
            var ah = X[2] - X[0];
            var al = z.settings.printbox_rotated;
            z.settings.printscreentype = "jpg";
            var am = mapviewer.savemaprectangle_custom(
              al[0],
              al[1],
              al[4],
              al[5],
              ac
            );
            z.settings.printscreentype = "png";
            am = am.substr(23);
            var ag = z.map.tolatlng(al[0], al[1]);
            var aj = ag.lat;
            var Y = ag.lng;
            var ag = z.map.tolatlng(al[2], al[3]);
            var af = ag.lat;
            var ax = ag.lng;
            var ag = z.map.tolatlng(al[6], al[7]);
            var aA = ag.lat;
            var aq = ag.lng;
            var ag = z.map.tolatlng(al[4], al[5]);
            var aw = ag.lat;
            var ao = ag.lng;
            var au = 1;
            var ab = 1;
            var at = ah;
            var aa = ac;
            var ae;
            $.ajax({
              type: "get",
              async: false,
              url:
                "../do_calculate_ge_rotation.php?nw_lat=" +
                aj +
                "&nw_lng=" +
                Y +
                "&se_lat=" +
                aw +
                "&se_lng=" +
                ao +
                "&x1=" +
                au +
                "&y1=" +
                ab +
                "&x2=" +
                at +
                "&y2=" +
                aa +
                "&ww=" +
                ah +
                "&hh=" +
                ac,
              success: function (aB) {
                ae = aB;
              },
            });
            var ai = ae.split(",");
            var ay = ai[3];
            var ad = ai[2];
            var Z = ai[0];
            var ap = ai[1];
            var ak = ai[4];
            var az =
              '<?xml version="1.0" encoding="UTF-8"?>\n<!-- Generator: 2DRerun -->\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Folder>\n<name></name>\n<GroundOverlay>\n<name>tile_0_0.jpg</name>\n<drawOrder>75</drawOrder>\n<Icon>\n<href>files/tile_0_0.jpg</href>\n<viewBoundScale>0.75</viewBoundScale>\n</Icon>\n<color>FFffffff</color>\n<LatLonBox>\n<north>' +
              parseFloat(Z) +
              "</north>\n<south>" +
              parseFloat(ap) +
              "</south>\n<east>" +
              parseFloat(ad) +
              "</east>\n<west>" +
              parseFloat(ay) +
              "</west>\n<rotation>" +
              parseFloat(ak) +
              "</rotation>\n</LatLonBox>\n</GroundOverlay>\n</Folder>\n</kml>";
            var av = new JSZip();
            av.file("doc.kml", az);
            av.folder("files").file("tile_0_0.jpg", am, {
              base64: true,
              binary: true,
            });
            av.generateAsync({ type: "blob" }).then(function (aC) {
              var aB = document.createElement("a");
              aB.download = "course.kmz";
              aB.href = window.URL.createObjectURL(aC);
              aB.textContent = "";
              aB.click();
            });
          }
        });
        $("#printmapkmz").bind("click", function (ar, an) {
          if (!z.settings.printbox_rotated) {
            alert("Please define print area first!");
          } else {
            mapviewer.settings.hidecourse = 1;
            mapviewer.redraw();
            var X = z.settings.printbox;
            var ac = X[3] - X[1];
            var ah = X[2] - X[0];
            var al = z.settings.printbox_rotated;
            z.settings.printscreentype = "jpg";
            var am = mapviewer.savemaprectangle_custom(
              al[0],
              al[1],
              al[4],
              al[5],
              ac
            );
            z.settings.printscreentype = "png";
            am = am.substr(23);
            var ag = z.map.tolatlng(al[0], al[1]);
            var aj = ag.lat;
            var Y = ag.lng;
            var ag = z.map.tolatlng(al[2], al[3]);
            var af = ag.lat;
            var ax = ag.lng;
            var ag = z.map.tolatlng(al[6], al[7]);
            var aA = ag.lat;
            var aq = ag.lng;
            var ag = z.map.tolatlng(al[4], al[5]);
            var aw = ag.lat;
            var ao = ag.lng;
            var au = 1;
            var ab = 1;
            var at = ah;
            var aa = ac;
            var ae;
            $.ajax({
              type: "get",
              async: false,
              url:
                "../do_calculate_ge_rotation.php?nw_lat=" +
                aj +
                "&nw_lng=" +
                Y +
                "&se_lat=" +
                aw +
                "&se_lng=" +
                ao +
                "&x1=" +
                au +
                "&y1=" +
                ab +
                "&x2=" +
                at +
                "&y2=" +
                aa +
                "&ww=" +
                ah +
                "&hh=" +
                ac,
              success: function (aB) {
                ae = aB;
              },
            });
            var ai = ae.split(",");
            var ay = ai[3];
            var ad = ai[2];
            var Z = ai[0];
            var ap = ai[1];
            var ak = ai[4];
            var az =
              '<?xml version="1.0" encoding="UTF-8"?>\n<!-- Generator: 2DRerun -->\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Folder>\n<name></name>\n<GroundOverlay>\n<name>tile_0_0.jpg</name>\n<drawOrder>75</drawOrder>\n<Icon>\n<href>files/tile_0_0.jpg</href>\n<viewBoundScale>0.75</viewBoundScale>\n</Icon>\n<color>FFffffff</color>\n<LatLonBox>\n<north>' +
              parseFloat(Z) +
              "</north>\n<south>" +
              parseFloat(ap) +
              "</south>\n<east>" +
              parseFloat(ad) +
              "</east>\n<west>" +
              parseFloat(ay) +
              "</west>\n<rotation>" +
              parseFloat(ak) +
              "</rotation>\n</LatLonBox>\n</GroundOverlay>\n</Folder>\n</kml>";
            var av = new JSZip();
            av.file("doc.kml", az);
            av.folder("files").file("tile_0_0.jpg", am, {
              base64: true,
              binary: true,
            });
            av.generateAsync({ type: "blob" }).then(function (aC) {
              var aB = document.createElement("a");
              aB.download = "map.kmz";
              aB.href = window.URL.createObjectURL(aC);
              aB.textContent = "";
              aB.click();
            });
            mapviewer.settings.hidecourse = 0;
          }
        });
      } else {
        $("#" + z.infobottomdiv).append("<hr><h4>Export image</h4>");
        $("#" + z.infobottomdiv).append(
          z.printselect(
            "Save current view to JPG",
            "savesavezoom",
            "0:Zoom as shown|100:Original map size|300:300% of shown size|200:200% of shown size|150:150% of shown size|90:90% of shown size|80:80% of shown size|70:70% of shown size|60:60% of shown size|50:50% of shown size|25:25% of shown size",
            Q
          )
        );
        this.addbutton(z.infobottomdiv, "saveview", "Save JPG");
        $("#" + this.infobottomdiv).append(
          '<br><i>(Works only in Google Chrome)</i><br>Save complete map: <a onclick="mapviewer.savecompletemap_withcourse_and_sketch(0.8);">v1</a> - <a onclick="mapviewer.savecompletemap_withcourse_and_sketch(0.001);">v2</a> -'
        );
      }
      if (!courseplanning) {
        $("#" + z.infobottomdiv).append(
          '<hr><h4 style="margin-bottom:7px;">Make AnalysisLog</h4>'
        );
        $("#" + z.infobottomdiv).append(
          z.printquickbutton_updown(
            "Save type",
            "&lt;",
            "mapviewer.analysislog_setsave(-1);",
            "&gt;",
            "mapviewer.analysislog_setsave(1);",
            z.AnalysisLogdef.savetypes[z.AnalysisLogdef.savetype],
            "Change which images to save",
            "analysislogsetsavebutt"
          )
        );
        this.addbutton(z.infobottomdiv, "box", "New entry");
        $("#" + z.infobottomdiv).append(
          "<br><i>(Works only in Google Chrome)</i><br><br>"
        );
        $("#box").bind("click", function (X, Y) {
          mapviewer.analysislog_entry();
        });
      }
      $("#papersize").bind("click", function (X, Y) {
        z.settings.papersize = parseInt($("#papersize").val());
        if (z.settings.papersize == 0) {
          z.settings.papersize_mm = [210, 297];
          z.settings.papersize_name = "A4 portrait";
        } else {
          if (z.settings.papersize == 1) {
            z.settings.papersize_mm = [297, 210];
            z.settings.papersize_name = "A4 landscape";
          } else {
            if (z.settings.papersize == 2) {
              z.settings.papersize_mm = [297, 420];
              z.settings.papersize_name = "A3 portrait";
            } else {
              if (z.settings.papersize == 3) {
                z.settings.papersize_mm = [420, 297];
                z.settings.papersize_name = "A3 landscape";
              } else {
                if (z.settings.papersize == 4) {
                  z.settings.papersize_mm = [148, 210];
                  z.settings.papersize_name = "A5 portrait";
                } else {
                  if (z.settings.papersize == 5) {
                    z.settings.papersize_mm = [210, 148];
                    z.settings.papersize_name = "A5 landscape";
                  } else {
                    if (z.settings.papersize == 6) {
                      z.settings.papersize_mm = [216, 279];
                      z.settings.papersize_name = "Letter portrait";
                    } else {
                      if (z.settings.papersize == 7) {
                        z.settings.papersize_mm = [279, 216];
                        z.settings.papersize_name = "Letter landscape";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      });
      $("#saveview").bind("click", function (Z, aa) {
        var X;
        if (z.map.id == "localimage") {
          X = z.map.name;
        } else {
          X = "img";
        }
        if (!z.settings.saveviewcounter) {
          z.settings.saveviewcounter = 0;
        }
        z.settings.saveviewcounter++;
        var ab = X + "_" + z.settings.saveviewcounter;
        var Y = parseInt($("#savesavezoom").val());
        z.settings.isprinting = 1;
        if (Y == 0) {
          z.redraw();
          z.play_loop();
          z.canvas.saveDataURL(ab);
        } else {
          z.savearea_zoom(parseFloat(Y / 100), ab);
        }
        z.settings.isprinting = 0;
      });
      if (!courseplanning) {
        this.addbutton(
          z.infobottomdiv,
          "saveroutestojson",
          "Save Routes to JSON"
        );
        $("#saveroutestojson").bind("click", function (X, Y) {
          z.open_dialog("saveroutesandcourse", null);
        });
      }
    }
    if (courseplanning && !z.map) {
      $("#" + z.infobottomdiv).hide();
    }
    if (!courseplanning) {
      this.addbutton(z.infobottomdiv, "togglesaveanimbutt", "S");
    }
    $("#" + z.infobottomdiv).append(
      "<hr><br><a href='javascript:void(0)'  onclick='find_where_others_better()'>OB</a> <a href='javascript:void(0)'  onclick='find_where_others_better_off()'>OB-end</a> <a href='javascript:void(0)' onclick='mapviewer.showeleprofiles(0);'>Eleprofile</a>  <a href='javascript:void(0)' onclick='mapviewer.lengthtab();'>LenTab</a>"
    );
    $("#togglesaveanimbutt").bind("click", function (X, Y) {
      if (!z.is_save_animation) {
        z.start_save_animation();
        if (!z.playing) {
          z.toggleplay();
        }
      } else {
        z.stop_save_animation();
        if (z.playing) {
          z.toggleplay();
        }
      }
    });
    if (!courseplanning) {
      $("#" + z.infobottomdiv).append(
        '<hr><h4>Store & view situations</h4>Store situations to view later. Will be erased when reloading page.<br><input type="text" id="storestate_name"><br>'
      );
      this.addbutton(z.infobottomdiv, "storestate", "Store");
      $("#" + z.infobottomdiv).append('<hr><div id="choosestatediv"></div>');
      this.addbutton(z.infobottomdiv, "showleg", "Show");
      this.addbutton(z.infobottomdiv, "replayleg", "Replay");
      if (z.settings.enableprintscreen || courseplanning) {
        this.addbutton(z.infobottomdiv, "replaylegvideo", "Video");
      }
      var T = new Array();
      if (z.settings.replayleg_states.length > 0) {
        for (var N = 0; N < z.settings.replayleg_states.length; N++) {
          T.push(N + ":" + z.settings.replayleg_states[N].name);
        }
        $("#choosestatediv").html(
          z.printselect(
            "Choose situation to view",
            "choosestate",
            T.join("|"),
            z.settings.replayleg_states.length - 1
          )
        );
      }
      $("#storestate").bind("click", function (Y, aa) {
        var X = C.savestate();
        X.name = $("#storestate_name").val();
        if (!X.name) {
          X.name = "Situation " + (z.settings.replayleg_states.length + 1);
        }
        z.settings.replayleg_states.push(X);
        $("#storestate_name").val("");
        var ab = new Array();
        for (var Z = 0; Z < z.settings.replayleg_states.length; Z++) {
          ab.push(Z + ":" + z.settings.replayleg_states[Z].name);
        }
        $("#choosestatediv").html(
          z.printselect(
            "Choose situation to view",
            "choosestate",
            ab.join("|"),
            z.settings.replayleg_states.length - 1
          )
        );
      });
      $("#showleg").bind("click", function (Z, aa) {
        var X = $("#choosestate").val();
        var Y = z.settings.replayleg_states[X];
        if (Y) {
          C.replayleg(Y, { noplay: 1 });
        }
      });
      $("#replayleg").bind("click", function (Z, aa) {
        var X = $("#choosestate").val();
        var Y = z.settings.replayleg_states[X];
        if (Y) {
          C.replayleg(Y, {
            dots: z.settings.showdrawdots,
            samezoom: 0,
            legendtype: mapviewer.settings.legendtype,
          });
        }
      });
      $("#replaylegvideo").bind("click", function (Z, aa) {
        var X = $("#choosestate").val();
        var Y = z.settings.replayleg_states[X];
        if (Y) {
          C.savevideoleg(Y, {
            dots: z.settings.showdrawdots,
            samezoom: 0,
            legendtype: mapviewer.settings.legendtype,
          });
        }
      });
    }
  };
  this.setprintarea = function (ac) {
    var ab = mapviewer.map.utm_coords.split("|");
    var N = parseInt(ab[0]);
    var R = parseInt(ab[1]);
    var aj = parseInt(ab[2]);
    var M = parseInt(ab[3]);
    var ak = z.settings.printscale;
    var X = z.settings.papersize_name;
    var U = z.settings.papersize_mm;
    var V = U[0];
    var Z = U[1];
    var T = aj - N;
    var Y = R - M;
    var ad = (T / ak) * 1000;
    var ai = (Y / ak) * 1000;
    var aa = mapviewer.map.width;
    var ah = mapviewer.map.height;
    var W = parseInt((V / ad) * aa);
    var ag = parseInt((Z / ai) * ah);
    var af = ac.x;
    var Q = ac.y;
    var ae = af + W;
    var O = Q + ag;
    var S = (W / V) * 25.4;
    z.settings.printbox = [af, Q, ae, O];
    mapviewer.settings.showprintbox = 1;
    $("#printinfo").html("DPI: " + S);
  };
  this.setXimagepos = function (O, M) {
    var N = O.x;
    var Q = O.y;
    if (M == 2) {
      z.settings.Ximagepos[2] = N;
      z.settings.Ximagepos[3] = Q;
    } else {
      if (M == 1) {
        z.settings.Ximagepos[0] = N;
        z.settings.Ximagepos[1] = Q;
        z.waitforclick = 1;
        z.waitforclickfunction = function (R, U, S) {
          var T = new Object();
          T.x = R;
          T.y = U;
          z.waitforclick = 0;
          z.setXimagepos(T, 2);
        };
      }
    }
  };
  this.savetxtfile = function (Q, O, M, N) {
    if (M) {
      z.savespastxttofile(O, Q, N);
    } else {
      if ($.browser.name == "chrome" || $.browser.name == "safari") {
        downloadTxt(O, Q);
      } else {
        z.open_dialog(
          "Save data",
          "Please consider using the Google Chrome browser instead - then you would get the file downloaded directly. Now you need to copy the content of the textbox below into a file.<p><textarea>" +
            O +
            "</textarea>",
          1
        );
      }
    }
  };
  this.savecoursewithmap = function (M) {
    $.ajax({
      url: "../uploadcoursewithmap.php",
      type: "POST",
      dataType: "json",
      data: {
        image: mapviewer.map.mapobject.src,
        mapurl: mapviewer.map.url,
        mapw: mapviewer.map.width,
        maph: mapviewer.map.height,
        calstr: mapviewer.map.calstring,
        data: M,
      },
      success: function (O) {
        var N = O.status;
        var R = O.md5;
        var Q = "courseplanning.php?coursewithmap=" + R;
        z.open_dialog(
          "Course/routes saved",
          'Please write down the link to the map+course:<ul><li><a href="' +
            Q +
            '">Link to course</a></ul>Note! You will not find this link again if you loose it!',
          1
        );
        return;
      },
      error: function (O, Q, N) {
        alert(N);
      },
    });
  };
  this.savemapdb = function (M) {
    var N = null;
    $.ajax({
      url: "../uploadmapdb.php",
      type: "POST",
      dataType: "json",
      async: false,
      data: {
        image: mapviewer.map.mapobject.src,
        mapurl: mapviewer.map.url,
        mapw: mapviewer.map.width,
        maph: mapviewer.map.height,
        calstr: mapviewer.map.calstring,
      },
      success: function (O) {
        stat = O.status;
        N = O.id;
        md5 = O.md5;
      },
      error: function (Q, R, O) {
        alert(O);
      },
    });
    return N;
  };
  this.loadcoursewithmap = function (O) {
    var N = "http://3drerun.worldofo.com";
    if (window.location.host == "localhost") {
      N = "http://localhost/ge";
    }
    if (window.location.host == "loggator2.worldofo.com") {
      N = "http://loggator2.worldofo.com";
    }
    var M = N + "/cmaps/" + O + ".json";
    z.settings.loadmaptype = "loadcoursewithmap";
    $.ajax({
      url: M,
      dataType: "json",
      success: function (R) {
        var W = R.url;
        var T = R.mapw;
        var V = R.maph;
        var S = R.calstr;
        var Q = "3point";
        var U = jQuery.parseJSON(R.savedata);
        z.tags = U.tags;
        z.coursecoords = U.coursecoords;
        z.otechinfo = U.otechinfo;
        z.settings.tagging_timealt = 0;
        z.settings.showtagmode = 1;
        z.loadmap(W, T, V, S, Q, null);
        if (typeof courseplanning != "undefined") {
        } else {
          courseplanning = 0;
        }
        if (courseplanning) {
          value = "drawcourse";
          $("#selectmode option[value=" + value + "]").removeAttr("disabled");
          value = "savedata";
          $("#selectmode option[value=" + value + "]").removeAttr("disabled");
          value = "analyzecourse";
          $("#selectmode option[value=" + value + "]").removeAttr("disabled");
        }
      },
      error: function (R, S, Q) {
        console.log("Unexpected error  Could not load data! " + S + " " + Q);
        return;
      },
    });
  };
  this.loadcoursesplitsidstr = function () {
    var N = getURLParameter("lidstr");
    var M = "../loadcoursesplitsidstr.php";
    $.ajax({
      url: M,
      type: "POST",
      dataType: "json",
      data: { idstr: N },
      success: function (Q) {
        var U = jQuery.parseJSON(Q.savedata);
        if (U) {
          z.tags = U.tags;
          z.coursecoords = U.coursecoords;
          z.calculate_autosplits();
          var O = U.units;
          var V = U.splits;
          if (O) {
            for (var R = 0; R < O.length; R++) {
              var T = O[R];
              for (var S = 0; S < z.routes.length; S++) {
                if (z.routes[S].unit == T) {
                  z.routes[S].splits = V[R];
                }
              }
            }
          }
          z.request_redraw();
          z.update_routediv();
        }
      },
      error: function (Q, R, O) {
        console.log("Unexpected error  Could not load data! " + R + " " + O);
        return;
      },
    });
  };
  this.savespasimgtofile = function (N, M, O) {
    $.ajax({
      type: "POST",
      url: "saveImageJson.php",
      async: false,
      dataType: "json",
      data: { data: N, name: M, id: O, type: "spas" },
      success: function (R) {
        var Q = R.status;
      },
      error: function (R, S, Q) {
        alert(Q);
      },
    });
  };
  this.savespastxttofile = function (O, N, Q) {
    var M;
    $.ajax({
      type: "POST",
      url: "saveTxtJson.php",
      dataType: "json",
      async: false,
      data: { data: O, name: N, id: Q, type: "spas" },
      success: function (S) {
        var R = S.status;
        M = S;
      },
      error: function (S, T, R) {
        alert(R);
      },
    });
    return M;
  };
  this.spasdeploytoserver = function (N) {
    var M;
    $.ajax({
      type: "POST",
      url: "loadsavespas.php",
      dataType: "json",
      async: false,
      data: {
        action: "deploy",
        raceid: z.spasnameid_server,
        racename: z.spasnameid,
        coursename: "class",
        base: N,
      },
      success: function (O) {
        var Q = O.status;
        if (Q == "OK") {
          $("#step6div").show();
        } else {
          alert("Unfortunately we could not deploy to server! Message: " + Q);
        }
      },
      error: function (Q, R, O) {
        alert(O);
      },
    });
    return M;
  };
  this.showlastspas = function () {
    var O = "";
    var N = z.spasnameid_server;
    var Q = "spas/" + N + "/";
    var U = z.spasimgs;
    for (var S = 0; S < U.length; S++) {
      var R = U[S];
      O += "<h2>Leg " + (S + 1) + "</h2>";
      O += '<img width=400 src="' + Q + R + '_no.png"> ';
      O += '<img width=400 src="' + Q + R + '.png">';
      O +=
        '<div style="border:1px solid black;padding:4px;margin:2px;" id="spassplits-' +
        (S + 1) +
        '">Splits for leg ' +
        (S + 1) +
        " will appear here after loading splits...</div>";
      O += "<br>";
    }
    z.spashtml = O;
    var T =
      '<form style="display:none"><input type="file" id="splitinput" accept=".txt" multiple style="display:none"></form><button onclick="$(\'#splitinput\').trigger(\'click\');">Step 2: Browse for splittime-file from Woosplits</button><br>';
    var M =
      '<br><b>Step 2 finished!</b><br><hr><br><h2>Step 3: Check SPAS illustrations and upload split times</h2>You have now saved illustrations for a SPAS-analysis and are ready to add split times.<br>Please check that all images are OK below (scroll all the way to the bottom and check each leg). If something is missing, <a href="javascript:void(0)"  onclick="mapviewer.close_fulldialog();">go back and fix it</a>. When everything is fine, you can come back here, make SPAS illustrations again, and finally upload splittime-file generated by <a target=_blank href="http://events.worldofo.com/woosplits/">Woosplits</a>. Instructions for uploading split times is given below the SPAS illustrations.<br>' +
      O +
      '<hr><br>If all SPAS illustrations look good, you are ready to add split times. Use the link at the bottom of the Splits-tab in <a target=_blank href="http://events.worldofo.com/woosplits/">Woosplits</a> to save a file (a special text-file format) which you then can load using the button below. When the split times are loaded, split times for all runners are shown in the boxes below each leg above. Please check that they look correct for all legs before proceeding. <br><br>' +
      T +
      '<br><div id="spasstep4"></div>';
    $("#spascontent").html(M);
    $("#splitinput").bind("change", function (aa) {
      tmptmp4 = aa;
      var Z = aa.originalEvent.target.files;
      var Y = Z[0];
      var V = Y.name;
      var X = Y.type;
      var W = Y.size;
      console.log("Reading " + V + " ....");
      var ab = new FileReader();
      ab.onload = function (ai) {
        tmptmp2 = ai;
        var ap = ai.target.result;
        z.spassplits = ap;
        z.savespastxttofile(ap, "splits.txt", z.spasnameid);
        var aq = z.spassplits.split("\n");
        for (var ae = 0; ae < U.length; ae++) {
          $("#spassplits-" + (ae + 1)).html("");
          for (var ag = 0; ag < aq.length; ag++) {
            var ar = aq[ag];
            var ak = ar.split(";");
            var ac = ak[0];
            var aj = ak[4];
            console.log(aj);
            console.log(ar);
            if (aj) {
              var ao = aj.split("|");
              var af = ao[ae];
              var ah = af.split("-");
              $("#spassplits-" + (ae + 1)).append(ac + " " + ah[1] + "<br>");
            }
          }
        }
        var am;
        var an = z.spasnameid_server;
        var al = z.spasnameid;
        var ad = "";
        if (window.location.host == "localhost") {
          ad = "genlocal";
          am =
            "http://localhost/dropbox/worldofo/sprintquiz/?raceid=" +
            an +
            "&base=" +
            ad +
            "&course=class&racename=" +
            al +
            "&blankmap=1";
        } else {
          ad = "gen";
          am =
            "http://events.worldofo.com/spas/?raceid=" +
            an +
            "&base=" +
            ad +
            "&course=class&racename=" +
            al +
            "&blankmap=1";
        }
        $("#spasstep4").html(
          "<b>Step 3 finished!</b><br><hr><br><h2>Step 4: Check loaded split times and that SPAS-analysis looks good</h2>Please check that split times for each leg look good. If this is not the case, you need to either return to step to and load a new set of split times, <a href='javascript:void(0)'  onclick='mapviewer.close_fulldialog();'>go back to analysis mode</a> and modify your course, or lie down and cry (sorry, no big support available here).<p>If the split times look good, you can check out your SPAS creation in the SPAS interface to see if everything looks OK.<br><br><button onclick='window.open(\"" +
            am +
            '","_blank");$("#step5div").show();\'>Step 4: Open SPAS analysis and check</button><div id="step5div"  style="display:none"><h2>Step 5: Deploy SPAS-analysis</h2>If things looked good under step 4, you are now ready to deploy your SPAS-analysis to the server. If you skip this step, the SPAS-analysis which you tested under step 4 will work for a while, but may be deleted at any time (as it fills up server space).<br><br><button onclick="mapviewer.spasdeploytoserver(\'' +
            ad +
            '\');">Deploy SPAS analysis</button><div id="step6div" style="display:none"><br><br><b>Congratulations!</b> Link to your SPAS analysis:<br><br><i><a target=_blank href="' +
            am +
            '">' +
            am +
            "</a></i><br></div>"
        );
      };
      ab.readAsText(Y, "UTF-8");
    });
  };
  this.checklogin_analysislog_entry = function () {
    var M = "";
    if (window.location.host == "loggator.worldofo.com") {
      M = "http://3drerun.worldofo.com/2d/";
    }
    $.ajax({
      type: "GET",
      url: M + "loadsavedata.php?checklogin=1",
      dataType: "json",
      error: function (O, Q, N) {
        return;
      },
      success: function (N) {
        if (N.loggedin == 1) {
          z.loggedin = 1;
          z.analysislog_entry();
        } else {
          z.open_dialog(
            "Log in",
            'Please log in in order to save AnalysisLog<p><form name="loginform" id="loginform" onsubmit="return mapviewer.submitlogin_analysislog_entry()"><b>3DRerun UserID: <input type="text" id="uname"><br>Password: <input id="pwd" type="password"></b><p><input type="submit" value="Login"></form>.',
            1
          );
        }
        return;
      },
    });
  };
  this.checklogin = function () {
    var M = "";
    if (window.location.host == "loggator.worldofo.com") {
      M = "http://3drerun.worldofo.com/2d/";
    }
    $.ajax({
      type: "GET",
      url: M + "loadsavedata.php?checklogin=1",
      async: false,
      dataType: "json",
      error: function (O, Q, N) {
        return;
      },
      success: function (N) {
        if (N.loggedin == 1) {
          z.loggedin = 1;
        } else {
          z.loggedin = 0;
        }
        return;
      },
    });
    return z.loggedin;
  };
  this.submitlogin_analysislog_entry = function () {
    z.uname = $("#uname").val();
    z.pwd = $("#pwd").val();
    var M = "";
    if (window.location.host == "loggator.worldofo.com") {
      M = "http://3drerun.worldofo.com/2d/";
    }
    $.ajax({
      type: "POST",
      url: M + "loadsavedata.php?login=1&uname=" + z.uname + "&pwd=" + z.pwd,
      dataType: "json",
      error: function (O, Q, N) {
        alert("Server error: Could not log you in");
        return;
      },
      success: function (N) {
        if (N.loggedin == 1) {
          z.loggedin = 1;
          z.close_dialog();
          z.analysislog_entry();
        } else {
          alert("Could not log you in: " + N.status);
        }
        return;
      },
    });
    return false;
  };
  this.findpace = function () {
    var N = mapviewer;
    var S = 0;
    var O = 0;
    for (var R = 0; R < N.routes.length; R++) {
      if (N.routes[R].show) {
        if (mapviewer.routes[R].segmenttime > 0) {
          S =
            S +
            (mapviewer.routes[R].segmenttime /
              mapviewer.routes[R].segmentlength) *
              1000;
          O++;
        }
      }
    }
    var M = S / O;
    var Q = "";
    if (M > 0) {
      Q = tominsecpad(M);
    }
    return Q;
  };
  this.analysislog_entry = function () {
    if (isTainted(mapviewer.canvas.context)) {
      var M = document.URL + "&printscreen=1";
      z.open_dialog(
        "Can not save images",
        'You need to use <a href="' +
          M +
          '">this link in order to save images/AnalysisLogs</a>.',
        1
      );
      return;
    }
    if (!z.loggedin) {
      z.checklogin_analysislog_entry();
      return;
    }
    mapviewer.loadLogForm();
    mapviewer.loadLogNames();
    mapviewer.waitfordrag_startpoint = null;
    mapviewer.waitfordrag = 1;
    $("#map").css("cursor", "cell");
    mapviewer.waitfordrag_finishfunction = function () {
      var R = mapviewer.waitfordrag_startpoint;
      var Q = mapviewer.waitfordrag_dragpoint;
      if (Q != null) {
        mapviewer.waitfordrag_dragging = 0;
        mapviewer.waitfordrag_dragpoint = null;
        mapviewer.waitfordrag = 0;
        $("#map").css("cursor", "crosshair");
        img = mapviewer.savemaprectangle(R.x, R.y, Q.x, Q.y);
        if (z.AnalysisLogdef.savetype == 3) {
          var S =
            "leg_" +
            parseInt(mapviewer.settings.centerlegnum).toFixed().pad(2, "0") +
            ".jpg";
          downloadImg(img, S);
          return;
        }
        img_alternatives = null;
        if (z.AnalysisLogdef.savetype >= 2 && z.AnalysisLogdef.savetype <= 2) {
          var N = mapviewer.settings.tagging_timealt;
          var O = mapviewer.settings.showtagmode;
          mapviewer.settings.tagging_timealt = 4;
          mapviewer.settings.showtagmode = 1;
          img_alternatives = mapviewer.savemaprectangle(R.x, R.y, Q.x, Q.y);
          mapviewer.settings.tagging_timealt = N;
          mapviewer.settings.showtagmode = O;
        }
        img_blank = null;
        if (z.AnalysisLogdef.savetype >= 1 && z.AnalysisLogdef.savetype <= 2) {
          z.settings.isprinting_blank = 1;
          img_blank = mapviewer.savemaprectangle(R.x, R.y, Q.x, Q.y);
          z.settings.isprinting_blank = 0;
        }
        setTimeout(
          "mapviewer.addimg_to_analysislog(img,img_blank,img_alternatives);",
          0
        );
      }
    };
    mapviewer.specialized_drawfunction = function () {
      mapviewer.canvas.setLineStyle("0000ff", 1, 3);
      var Q = mapviewer.click_onmousedown;
      var O = mapviewer.waitfordrag_dragpoint;
      if (Q && O) {
        var N = mapviewer.canvas.use_translated_coordinates;
        mapviewer.canvas.use_translated_coordinates = 1;
        mapviewer.canvas.drawRectangleRot(Q.x, Q.y, O.x, O.y);
        mapviewer.canvas.use_translated_coordinates = N;
      }
    };
  };
  this.grouping_toggle = function () {
    if (z.settings.showgrouping) {
      z.settings.showgrouping = 0;
    } else {
      z.settings.showgrouping = 1;
      if (!z.playing) {
        z.toggleplay();
      }
    }
    z.request_redraw();
  };
  this.sketchmode_toggle = function () {
    if (z.settings.sketchmode) {
      z.settings.sketchmode = 0;
      $("#sketch_settings_id").hide();
      if (z.settings.mapopacity < 0.6) {
        z.settings.mapopacity = 1;
        z.updateinfobottomdiv();
      }
    } else {
      z.settings.sketchmode = 1;
      $("#sketch_settings_id").slideDown();
      if (z.settings.mapopacity > 0.6) {
        z.settings.mapopacity = 0.3;
        z.updateinfobottomdiv();
      }
    }
    z.request_redraw();
  };
  this.northlines_toggle = function () {
    if (z.settings.shownorthlines) {
      z.settings.shownorthlines = 0;
    } else {
      z.settings.shownorthlines = 1;
    }
    z.request_redraw();
  };
  this.sketchmode_brushsize = function (M) {
    if (M == -1) {
      z.settings.sketchmode_pointsize--;
    } else {
      z.settings.sketchmode_pointsize++;
    }
    if (z.settings.sketchmode_pointsize < 1) {
      z.settings.sketchmode_pointsize = 1;
    }
    if (z.settings.sketchmode_pointsize > 99) {
      z.settings.sketchmode_pointsize = 99;
    }
    z.updateinfobottomdiv();
  };
  this.sketchmode_setmode = function (M) {
    if (M == -1) {
      z.settings.sketchmode_mode--;
    } else {
      z.settings.sketchmode_mode++;
    }
    if (z.settings.sketchmode_mode < 0) {
      z.settings.sketchmode_mode = z.settings.sketchmodes.length - 1;
    }
    if (z.settings.sketchmode_mode > z.settings.sketchmodes.length - 1) {
      z.settings.sketchmode_mode = 0;
    }
    z.updateinfobottomdiv();
  };
  this.analysislog_setsave = function (M) {
    if (M == -1) {
      z.AnalysisLogdef.savetype--;
    } else {
      z.AnalysisLogdef.savetype++;
    }
    if (z.AnalysisLogdef.savetype < 0) {
      z.AnalysisLogdef.savetype = z.AnalysisLogdef.savetypes.length - 1;
    }
    if (z.AnalysisLogdef.savetype > z.AnalysisLogdef.savetypes.length - 1) {
      z.AnalysisLogdef.savetype = 0;
    }
    z.updateinfobottomdiv();
  };
  this.sketchmode_startstopsketch = function (M) {
    if (!z.settings.is_sketching || M == "start") {
      z.settings.is_sketching = 1;
      $("#map").css("cursor", "cell");
    } else {
      if (z.settings.is_sketching || M == "stop") {
        z.settings.is_sketching = 0;
        $("#map").css("cursor", "crosshair");
      }
    }
    z.request_redraw();
  };
  this.sketchmode_draw = function (O, X, W, Y, R, aa, Z, M, V, U) {
    var N = mapviewer.map.height;
    var T = mapviewer.map.width;
    if (!mapviewer.canvas.o_canvas) {
      mapviewer.canvas.o_canvas = document.createElement("canvas");
      mapviewer.canvas.o_canvas.width = T;
      mapviewer.canvas.o_canvas.height = N;
      mapviewer.canvas.o_context = mapviewer.canvas.o_canvas.getContext("2d");
      mapviewer.canvas.o2_canvas = document.createElement("canvas");
      mapviewer.canvas.o2_canvas.width = T;
      mapviewer.canvas.o2_canvas.height = N;
      mapviewer.canvas.o2_context = mapviewer.canvas.o2_canvas.getContext("2d");
    }
    if (
      !mapviewer.canvas.draw_canvas &&
      mapviewer.settings.sketchmode_mode >= 2
    ) {
      mapviewer.canvas.draw_canvas = document.createElement("canvas");
      mapviewer.canvas.draw_canvas.width = T;
      mapviewer.canvas.draw_canvas.height = N;
      mapviewer.canvas.draw_context =
        mapviewer.canvas.draw_canvas.getContext("2d");
    }
    if (mapviewer.settings.isprinting && mapviewer.settings.mapopacity != 1) {
      ctx = mapviewer.canvas.o2_context;
      ctx.globalAlpha = 1;
      ctx.clearRect(0, 0, T, N);
      ctx.drawImage(O, 0, 0);
      ctx.save();
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(mapviewer.canvas.o_canvas, 0, 0);
      ctx.restore();
      ctx.globalAlpha = mapviewer.settings.mapopacity;
      ctx.drawImage(O, 0, 0);
      ctx.globalAlpha = 1;
      var S = mapviewer.canvas.o2_canvas.toDataURL("image/png");
      var Q = new Image();
      Q.src = S;
      mapviewer.canvas.context.fillStyle = "rgba(255,255,255,1)";
      mapviewer.canvas.context.fillRect(
        -2 * mapviewer.canvas.width,
        -2 * mapviewer.canvas.height,
        4 * mapviewer.canvas.width,
        4 * mapviewer.canvas.height
      );
      mapviewer.canvas.context.globalAlpha = 1;
      mapviewer.canvas.context.drawImage(Q, X, W, Y, R, aa, Z, M, V);
    } else {
      ctx = mapviewer.canvas.context;
      ctx.globalAlpha = 1;
      ctx.drawImage(O, X, W, Y, R, aa, Z, M, V);
      ctx.save();
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(mapviewer.canvas.o_canvas, X, W, Y, R, aa, Z, M, V);
      ctx.restore();
      ctx.globalAlpha = mapviewer.settings.mapopacity;
      ctx.drawImage(O, X, W, Y, R, aa, Z, M, V);
      ctx.globalAlpha = 1;
      if (mapviewer.canvas.draw_canvas) {
        ctx.drawImage(mapviewer.canvas.draw_canvas, X, W, Y, R, aa, Z, M, V);
      }
    }
  };
  this.sketchmode_drawpt = function (S) {
    var M = S.x;
    var T = S.y;
    var R = mapviewer.settings.sketchmode_pointsize;
    if (mapviewer.settings.sketchmode_mode <= 1) {
      var O = mapviewer.canvas.o_context;
      if (mapviewer.settings.sketchmode_mode == 0) {
        O.save();
        O.globalCompositeOperation = "destination-out";
      }
      var N = O.createRadialGradient(M, T, 1 * R, M, T, 2 * R);
      N.addColorStop(0, "#000");
      N.addColorStop(0.5, "rgba(0,0,0,0.5)");
      N.addColorStop(1, "rgba(0,0,0,0)");
      O.fillStyle = N;
      O.fillRect(M - 2 * R, T - 2 * R, 10 * R, 10 * R);
      if (mapviewer.settings.sketchmode_mode == 0) {
        O.restore();
      }
    } else {
      if (mapviewer.canvas.draw_context) {
        var O = mapviewer.canvas.draw_context;
        if (
          mapviewer.settings.sketchmode_mode ==
          mapviewer.settings.sketchmodes.length - 1
        ) {
          O.save();
          O.globalCompositeOperation = "destination-out";
        }
        var Q = "0,0,0";
        if (
          mapviewer.settings.sketchmode_mode == 2 ||
          mapviewer.settings.sketchmode_mode == 7
        ) {
          Q = "255,0,0";
        } else {
          if (
            mapviewer.settings.sketchmode_mode == 3 ||
            mapviewer.settings.sketchmode_mode == 8
          ) {
            Q = "0,0,255";
          } else {
            if (
              mapviewer.settings.sketchmode_mode == 4 ||
              mapviewer.settings.sketchmode_mode == 9
            ) {
              Q = "0,150,0";
            } else {
              if (mapviewer.settings.sketchmode_mode == 5) {
                Q = "80,80,80";
              } else {
                if (mapviewer.settings.sketchmode_mode == 6) {
                  Q = "0,250,0";
                }
              }
            }
          }
        }
        var N;
        if (
          mapviewer.settings.sketchmode_mode <= 6 ||
          mapviewer.settings.sketchmode_mode ==
            mapviewer.settings.sketchmodes.length - 1
        ) {
          N = O.createRadialGradient(M, T, 1 * R, M, T, 2 * R);
          N.addColorStop(0, "rgba(" + Q + ",1)");
          N.addColorStop(0.5, "rgba(" + Q + ",0.5)");
          N.addColorStop(1, "rgba(" + Q + ",0)");
        } else {
          N = O.createRadialGradient(M, T, 1 * R, M, T, 2 * R);
          N.addColorStop(0, "rgba(0,0,0,0)");
          N.addColorStop(0.6, "rgba(" + Q + ",0)");
          N.addColorStop(0.7, "rgba(" + Q + ",1)");
          N.addColorStop(0.9, "rgba(" + Q + ",1)");
          N.addColorStop(1, "rgba(" + Q + ",0)");
        }
        O.fillStyle = N;
        O.fillRect(M - 2 * R, T - 2 * R, 10 * R, 10 * R);
        if (
          mapviewer.settings.sketchmode_mode ==
          mapviewer.settings.sketchmodes.length - 1
        ) {
          O.restore();
        }
      }
    }
  };
  this.readlocalbinfile = function (O, Q) {
    var N = O.name;
    var M = new FileReader();
    M.onload = function (S) {
      var R = S.target.result;
      tmptmp2 = S;
      if (N.substr(-3) == "fit" || N.substr(-3) == "FIT") {
        z.loadfitfilefromdata(R, N.substr(0, N.length - 4));
      } else {
        if (
          N.substr(-3) == "tif" ||
          N.substr(-3) == "TIF" ||
          N.substr(-4) == "tiff" ||
          N.substr(-4) == "TIFF"
        ) {
          z.loadtiffilefromdata(R);
        }
      }
    };
    M.readAsArrayBuffer(O);
  };
  this.readlocaltextfile = function (O, Q) {
    var N = O.name;
    var M = new FileReader();
    M.onload = function (T) {
      tmptmp2 = T;
      var S = 0;
      var U = T.target.result;
      if (N == "location.json") {
        z.loadSkiiotfilefromdata(U, N);
      } else {
        if (N.substr(0, 7) == "skiiot_") {
          z.loadSkiiotfilefromdata(U, N);
        } else {
          if (N.substr(-4) == "json" && Q != "xml") {
            data = jQuery.parseJSON(U);
            if (z.map.width == null && !data.fullroutes) {
              alert("You need to add a route or map before adding a course!");
            } else {
              if (data.fullroutes) {
                z.loadRoutesfromdata(data.fullroutes);
              }
              if (data.fullmap) {
                setTimeout(
                  "mapviewer.loadMapfromdata(data.fullmap,data.calstring);",
                  10
                );
              } else {
                if (z.map.width == null) {
                  z.load_blank_map();
                } else {
                  if (z.map.calstring == "0|0|0|0|1|1|1600|1600|0|1|0|1600") {
                    S = 1;
                    $("#selectmode").val("calibrate");
                    $("#selectmode").change();
                    calstring = mapviewer.find_initial_calstring();
                    mapviewer.map.initcalibration(calstring);
                    mapviewer.map.calstring = calstring;
                    mapviewer.redraw();
                  } else {
                    if (data.coursecoords || !data.savedata) {
                      if (data.tags) {
                        z.tags = data.tags;
                      }
                      if (data.otechinfo) {
                        z.otechinfo = data.otechinfo;
                      }
                      z.coursecoords = data.coursecoords;
                      $("#selectmode").val("drawcourse");
                      $("#selectmode").change();
                      return;
                    }
                  }
                }
              }
              setTimeout("mapviewer.loadCoursefromdata(data.savedata);", 1000);
              $("#selectmode").val("graphmode");
              $("#selectmode").change();
            }
          } else {
            if (N.substr(-3) == "xml") {
              mapviewer.parse_xml_general(U);
            } else {
              if (N.substr(-3) == "cal") {
                U = U.replace("\n", "");
                z.map.initcalibration(U);
                z.map.calstring = U;
                z.redraw();
                z.request_redraw();
                z.update_routediv();
              } else {
                if (N.substr(-3) == "tmp") {
                  z.loadTemperaturefilefromdata(U, N);
                } else {
                  if (N.substr(-12) == "settings.txt") {
                    z.loadSettingsfromdata(U);
                  } else {
                    if (N.substr(-3) == "tcx" || N.substr(-3) == "TCX") {
                      alert("Sorry, TCX-files not yet supported");
                    } else {
                      if (Q != "xml") {
                        mapviewer.addroutefromtxt(U, N.substr(0, N.length - 4));
                        if (z.map.width == null) {
                          z.load_blank_map();
                        } else {
                          if (
                            z.map.calstring ==
                            "0|0|0|0|1|1|1600|1600|0|1|0|1600"
                          ) {
                            S = 1;
                            $("#selectmode").val("calibrate");
                            $("#selectmode").change();
                            calstring = mapviewer.find_initial_calstring();
                            mapviewer.map.initcalibration(calstring);
                            mapviewer.map.calstring = calstring;
                            mapviewer.redraw();
                          }
                        }
                        if (getURLParameter("course") && loadcourse == 0) {
                          var R = getURLParameter("course");
                          z.loadCoursefromlocalfile(R + ".json");
                          loadcourse = -1;
                        } else {
                          if (z.coursecoords == 0 && xc == 1) {
                            $("#selectmode").val("definecourse");
                            $("#selectmode").change();
                          }
                        }
                        z.request_redraw();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    M.readAsText(O, "ISO-8859-1");
  };
  this.loadtiffilefromdata = function (O) {
    z.elevationparser = new GeotiffParser();
    z.elevationparser.parseHeader(O);
    if (!z.elevationparser.isGeotiff()) {
      alert("Error: Not a GeoTIFF, can not use this for elevation profiles");
      z.elevationparser = null;
      return;
    }
    console.log("Read elevation data");
    console.log("CRS Code:" + z.elevationparser.getCRSCode());
    var N = z.elevationparser.ImageToPCS(0, 0);
    var R = z.elevationparser.ImageToPCS(z.elevationparser.imageWidth, 0);
    var Q = z.elevationparser.ImageToPCS(0, z.elevationparser.imageLength);
    var M = z.elevationparser.ImageToPCS(
      z.elevationparser.imageWidth,
      z.elevationparser.imageLength
    );
    if (N[0] == 1) {
      console.log("UL=" + N[1], N[2]);
    } else {
      console.log("UL= failure");
    }
    if (R[0] == 1) {
      console.log("UR=" + R[1], R[2]);
    } else {
      console.log("UR= failure");
    }
    if (Q[0] == 1) {
      console.log("LL=" + Q[1], Q[2]);
    } else {
      console.log("LL= failure");
    }
    if (M[0] == 1) {
      console.log("LR=" + M[1], M[2]);
    } else {
      console.log("LR= failure");
    }
  };
  this.reloadlastmap_from_localstorage = function () {
    var N = localStorage_getItem("lastmap");
    var M = localStorage_getItem("lastcalstring");
    if (N && M) {
      z.loadmap(
        "dep/blank1600.gif",
        1600,
        1600,
        "0|0|0|0|1|1|1600|1600|0|1|0|1600",
        "3point"
      );
      z.map.mapobject.src = N;
      z.map.width = z.map.mapobject.width;
      z.map.height = z.map.mapobject.height;
      z.map.id = "localimage";
      $("#selectmode").val("calibrate");
      $("#selectmode").change();
      mapviewer.map.initcalibration(M);
      mapviewer.map.calstring = M;
      mapviewer.redraw();
      setTimeout(
        "mapviewer.map.initcalibration(mapviewer.map.calstring);mapviewer.redraw();$('#selectmode').val('analysis');$('#selectmode').change();",
        1000
      );
      z.request_redraw();
    }
  };
  this.readlocalximage = function (Q, N, O) {
    if (!z.settings.localmaps) {
      z.settings.localmaps = new Array();
    }
    var S = 0;
    for (var R = 0; R < z.settings.localmaps.length; R++) {
      if (Q.name == z.settings.localmaps[R].name) {
        S = 1;
      }
    }
    if (!S) {
      z.settings.localmaps.push(Q);
    }
    var M = new FileReader();
    M.readAsDataURL(Q);
    M.onload = function (U) {
      var T = new Image();
      T.src = U.target.result;
      T.onload = function () {
        mapviewer.settings.ximage = T;
      };
    };
  };
  this.readlocalimage = function (Q, N, O) {
    if (!z.settings.localmaps) {
      z.settings.localmaps = new Array();
    }
    var S = 0;
    for (var R = 0; R < z.settings.localmaps.length; R++) {
      if (Q.name == z.settings.localmaps[R].name) {
        S = 1;
      }
    }
    if (!S) {
      z.settings.localmaps.push(Q);
    }
    var M = new FileReader();
    M.readAsDataURL(Q);
    M.onload = function (U) {
      var T = new Image();
      T.src = U.target.result;
      T.onload = function () {
        var Z = 1;
        if (z.map.width == null) {
          z.loadmap(
            "dep/blank1600.gif",
            1600,
            1600,
            "0|0|0|0|1|1|1600|1600|0|1|0|1600",
            "3point"
          );
          Z = 0;
        }
        if (1) {
          z.map.mapobject.src = T.src;
          z.map.width = z.map.mapobject.width;
          z.map.height = z.map.mapobject.height;
          z.map.name = N + "_" + O;
          z.map.id = "localimage";
          var ak;
          if (N.match("^mapant-export")) {
            z.map.id = "mapant";
            z.settings.printscreentype = "png";
            N = z.map.name;
            N = N.replace(/--/g, "-M");
            N = N.replace(/-/g, ";");
            N = N.replace(/M/g, "-");
            N = N.replace(/\./g, ";");
            calinfo = N.split(";");
            var W = parseInt(calinfo[2]);
            var ah = parseInt(calinfo[5]);
            var aw = parseInt(calinfo[4]);
            var V = parseInt(calinfo[3]);
            var au = 1;
            var af = 1;
            var aq = z.map.width;
            var X = z.map.height;
            var ap = aw;
            var ar = ah;
            var at = aq;
            var ad = af;
            var ax = "+proj=utm +zone=33";
            var am = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
            var aa = proj4(ax, am, [W, ah]);
            var az = aa[0];
            var ai = aa[1];
            var ao = proj4(ax, am, [ap, ar]);
            var ay = ao[0];
            var ag = ao[1];
            var ac = proj4(ax, am, [aw, V]);
            var av = ac[0];
            var ab = ac[1];
            z.map.utm_coords = W + "|" + ah + "|" + aw + "|" + V;
            z.map.proj = "+proj=utm +zone=33";
            var Y =
              az +
              "|" +
              ai +
              "|1|1|" +
              ay +
              "|" +
              ag +
              "|" +
              at +
              "|" +
              ad +
              "|" +
              av +
              "|" +
              ab +
              "|" +
              aq +
              "|" +
              X;
            z.coursecoords_latlng = new Array();
            if (z.coursecoords) {
              for (var ae = 0; ae < z.coursecoords.length; ae++) {
                var an = z.coursecoords[ae];
                var aj = an.split(",");
                var al = z.map.tolatlng(aj[0], aj[1]);
                z.coursecoords_latlng[ae] = al.lat + "," + al.lng;
              }
            }
            mapviewer.map.initcalibration(Y);
            mapviewer.map.calstring = Y;
            mapviewer.redraw();
            console.log(mapviewer.map.calstring);
            setTimeout(
              "mapviewer.map.initcalibration(mapviewer.map.calstring);mapviewer.update_coursecoords_fromlatlng();mapviewer.redraw();",
              1000
            );
            mapviewer.printquicksettings_buttons();
          } else {
            ak = localStorage_getItem("calstring_" + z.map.name);
          }
          if (1) {
            if (typeof courseplanning != "undefined") {
            } else {
              courseplanning = 0;
            }
            if (courseplanning) {
              value = "drawcourse";
              $("#selectmode option[value=" + value + "]").removeAttr(
                "disabled"
              );
              value = "savedata";
              $("#selectmode option[value=" + value + "]").removeAttr(
                "disabled"
              );
              $("#courseplanning_courselength").show();
              $("#" + z.infobottomdiv).show();
              if (z.map.id == "mapant") {
                $("#selectmode").val("drawcourse");
                $("#selectmode").change();
                if (1) {
                  z.open_dialog(
                    "Instructions: Course planning tool for MapAnt.no",
                    "<b>1. Make course:</b> Add controls by clicking on the map. Click left mouse-button + hold CTRL key to remove control (if clicked close to existing control) or add extra control in-between. Hold SHIFT key and left mouse-button while moving mouse to move controls. Hold CTRL key and left mouse-button while moving mouse to move control.<br><br><b>2. Add north lines and rotate map:</b> In the right menu under 'Print course' you can add north lines and rotate the map.<br><br><b>3. Export to UsynligO or Livelox:</b> The course can easily be exported to UsynligO or Livelox. <br><br>- For UsynligO use the following steps: (a) Choose paper size and scale and set print area. (b) Print course PDF and save course XML - these are the two files UsynligO asks for<br>- For Livelox use the following steps: (a) Choose paper size and scale and set print area as above. (b) Print map KMZ and save course XML - these are the two files Livelox asks for.",
                    1
                  );
                }
              } else {
                $("#setscalediv").show();
                setTimeout("mapviewer.setdpiscale_frominput();", 10);
                if (
                  z.savecourseandtags(
                    "loadbrowser",
                    null,
                    null,
                    z.maps[0].name
                  ) == "none"
                ) {
                  z.open_dialog(
                    "Instructions: 2DRerun Course planning tool",
                    "<b>1. Load map (OK)</b><br>You may replace the map with another map at any timeby dragging a new map onto the map window.<p><b>2. Set Scale/DPI</b><br>The next step is to set scale/DPI for your map in the column to the right. Default values are 1:10.000 and 300 DPI.<p><b>3. Draw course</b><br>When you have set the correct Scale/DPI, use the menu in the upper right corner to go to the 'Draw course' mode and draw your course.<p><b>4. Draw routechoices</b><br>When you have drawn your course, use the menu to go to 'Draw routechoices' to start exploring route choice alternatives.",
                    1
                  );
                }
              }
            }
          }
          if (Z || ak) {
            $("#selectmode").val("calibrate");
            $("#selectmode").change();
            if (ak) {
              Y = ak;
            } else {
              if (mapviewer.routes.length > 0) {
                Y = mapviewer.find_initial_calstring();
              } else {
                Y = mapviewer.map.calstring;
              }
            }
            mapviewer.map.initcalibration(Y);
            mapviewer.map.calstring = Y;
            mapviewer.redraw();
            if (!Z && ak) {
              setTimeout(
                "mapviewer.map.initcalibration(mapviewer.map.calstring);mapviewer.redraw();$('#selectmode').val('analysis');$('#selectmode').change();",
                1000
              );
            }
            if (ak && Z) {
              setTimeout(
                "mapviewer.map.initcalibration(mapviewer.map.calstring);mapviewer.redraw();$('#selectmode').val('analysis');$('#selectmode').change();mapviewer.canvas.cx=mapviewer.map.width/2;mapviewer.canvas.cy=mapviewer.map.height/2;mapviewer.canvas.zoomfactor=0.5;mapviewer.redraw();",
                1000
              );
            }
            z.updatelocalmaps();
            z.request_redraw();
          }
        }
      };
    };
  };
  this.update_coursecoords_fromlatlng = function () {
    z.coursecoords = new Array();
    if (z.coursecoords_latlng) {
      for (var O = 0; O < z.coursecoords_latlng.length; O++) {
        var M = z.coursecoords_latlng[O];
        var Q = M.split(",");
        var N = z.map.toxy(Q[0], Q[1]);
        z.coursecoords[O] = N.x + "," + N.y;
      }
    }
    z.update_courselength();
  };
  this.add_dragdrop = function () {
    if (!z.dragdrop_added) {
      z.dragdrop_added = 1;
    } else {
      return;
    }
    z.add_dragdrop_top();
    var M = "mapholder";
    $("#" + M)[0].addEventListener(
      "dragover",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "dragleave",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "drop",
      function (O) {
        O.preventDefault();
        var N = O.dataTransfer.files;
        z.uploadfiles(N, "all");
      },
      true
    );
  };
  this.add_dragdrop_xml = function () {
    var M = "routedesc";
    $("#" + M)[0].addEventListener(
      "dragover",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "dragleave",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "drop",
      function (O) {
        O.preventDefault();
        var N = O.dataTransfer.files;
        z.uploadfiles(N, "xml");
      },
      true
    );
  };
  this.add_dragdrop_top = function () {
    var M = "infobox";
    $("#" + M)[0].addEventListener(
      "dragover",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "dragleave",
      function (N) {
        N.preventDefault();
      },
      true
    );
    $("#" + M)[0].addEventListener(
      "drop",
      function (O) {
        O.preventDefault();
        var N = O.dataTransfer.files;
        z.uploadfiles(N, "infodiv");
      },
      true
    );
  };
  this.uploadfiles = function (S, T) {
    for (var R = 0; R < S.length; R++) {
      var Q = S[R];
      var M = Q.name;
      var O = Q.type;
      var N = Q.size;
      if (O.match(/image.*/) && T == "infodiv") {
        z.readlocalximage(Q, M, N);
      } else {
        if (
          O.match(/image.*/) &&
          T != "xml" &&
          !(
            M.substr(-3) == "tif" ||
            M.substr(-3) == "TIF" ||
            M.substr(-4) == "tiff" ||
            M.substr(-4) == "TIFF"
          )
        ) {
          z.readlocalimage(Q, M, N);
        } else {
          if (
            M.substr(-3) == "fit" ||
            M.substr(-3) == "FIT" ||
            M.substr(-3) == "tif" ||
            M.substr(-3) == "TIF" ||
            M.substr(-4) == "tiff" ||
            M.substr(-4) == "TIFF"
          ) {
            console.log("Loading BIN file");
            z.readlocalbinfile(Q, T);
          } else {
            z.readlocaltextfile(Q, T);
          }
        }
      }
    }
  };
  this.exportgraphdata = function (aU) {
    if (aU == 1) {
      var M = JSON.stringify(mapviewer.routes);
      var an = JSON.stringify(mapviewer.courseinfo);
      var Z = JSON.stringify(mapviewer.coursecoords);
      var X = getURLParameter("race");
      if (X) {
        X = X.replace("/", "_");
      } else {
        X = "xcviewer";
      }
      if (typeof use_exeoutput != "undefined") {
        exeoutput.SetGlobalVariable("routesdata", M, false);
        exeoutput.SetGlobalVariable("courseinfo", an, false);
        exeoutput.SetGlobalVariable("coursecoords", Z, false);
        exeoutput.SetGlobalVariable("race", X, false);
      }
      $.ajax({
        type: "POST",
        url: "exportdata.php",
        dataType: "json",
        data: { routesdata: M, courseinfo: an, coursecoords: Z, race: X },
        error: function (aW, aX, aV) {
          alert("Error");
          return;
        },
        success: function (aV) {
          if (aV.status == "OK") {
            alert("OK");
          }
        },
      });
    } else {
      if (aU == 2) {
        z = mapviewer;
        var ay = "";
        var ah = "";
        var al = new Array();
        var aG = new Array();
        var aP = new Array();
        var az = new Array();
        var ag = new Array();
        var Q = new Array();
        var aH = new Array();
        for (var af = 0; af < z.coursecoords.length; af++) {
          var T = z.coursecoords[af].split(",");
          x1 = T[0];
          y1 = T[1];
          ele = parseFloat(T[2]);
          orgdist = parseFloat(T[3]);
          al.push(ele);
          aP.push(af);
          az.push(x1);
          ag.push(y1);
          var ak = z.map.tolatlng(T[0], T[1]);
          Q.push(ak.lat);
          aH.push(ak.lng);
        }
        var V = "Point number;;" + aP.join(";") + "\n";
        var Y = "course=struct('info','Course data');\n";
        var Y =
          Y +
          "course.distance=[" +
          z.courseinfo.distarray.join(" ") +
          "];distance=course.distance;\n";
        var N = "Distance;;" + z.courseinfo.distarray.join(";") + "\n";
        var aB =
          "course.elevation=[" +
          al.join(" ") +
          "];elevation=course.elevation;\n";
        var av = "course.x=[" + az.join(" ") + "];\n";
        av = av + "course.y=[" + ag.join(" ") + "];\n";
        av = av + "course.lat=[" + Q.join(" ") + "];\n";
        av = av + "course.lng=[" + aH.join(" ") + "];\n";
        var aD = "Elevation;;" + al.join(";") + "\n";
        ay = ay + Y + aB + av;
        ah = ah + V + N + aD;
        var aO = "hillsegments=struct('info','Hillsegment data');;\n";
        var au = "";
        var aQ = new Array();
        var W = new Array();
        var O = new Array();
        var ad = new Array();
        var aa = new Array();
        var U = new Array();
        for (var aJ = 0; aJ < z.courseinfo.hillsegments.length; aJ++) {
          var ab = z.courseinfo.hillsegments[aJ];
          aQ.push(ab.startind);
          W.push(ab.endind);
          O.push(ab.theelediff);
          ad.push(ab.thelength);
          aa.push(ab.thetype);
          U.push(ab.thetypeint);
        }
        aO = aO + "hillsegments.startinds=[" + aQ.join(" ") + "];\n";
        aO = aO + "hillsegments.endinds=[" + W.join(" ") + "];\n";
        aO = aO + "hillsegments.elediffs=[" + O.join(" ") + "];\n";
        aO = aO + "hillsegments.lengths=[" + ad.join(" ") + "];\n";
        aO = aO + "hillsegments.typeints=[" + U.join(" ") + "];\n";
        aO = aO + "hillsegments.types={'" + aa.join("','") + "'};\n";
        au = au + "Startinds;" + aQ.join(";") + "\n";
        au = au + "Endinds;" + W.join(";") + "\n";
        au = au + "Elediffs;" + O.join(";") + "\n";
        au = au + "Lengths;" + ad.join(";") + "\n";
        au = au + "Typeints;" + U.join(";") + "\n";
        au = au + "Types;" + aa.join(";") + "'\n";
        ay = ay + aO + "\n";
        ah = ah + au + "\n";
        var aM = "routes={};\n";
        var aT = "";
        var ap = "";
        var aK = 0;
        var at = z.courseinfo.hillsegments;
        for (var aE = 0; aE < z.routes.length; aE++) {
          var R = z.routes[aE];
          var aw = R.lapdata;
          if (aw.length) {
            aM += "routes{" + (aE + 1) + "}.name='" + R.runnername + "';\n";
            aM += "routes{" + (aE + 1) + "}.zerotime=" + R.zerotime + ";\n";
            for (var aR = 0; aR < aw.length; aR++) {
              var aS = new Array();
              var ar = new Array();
              var aL = new Array();
              var aA = new Array();
              for (var ab = 0; ab < at.length; ab++) {
                aS.push(
                  R.lapdata[aR].times[at[ab].endind] -
                    R.lapdata[aR].times[at[ab].startind]
                );
                if (R.lapdata[aR].dspeed) {
                  aL.push(R.lapdata[aR].dspeed[at[ab].startind] * 3.6);
                  aA.push(R.lapdata[aR].dspeed[at[ab].endind] * 3.6);
                  var ae = new Array();
                  for (var ao = at[ab].startind; ao <= at[ab].endind; ao++) {
                    ae.push(R.lapdata[aR].dspeed[ao]);
                  }
                  if (ae.length > 0) {
                    ar.push((ae.sum() / ae.length) * 3.6);
                  } else {
                    ar.push(0);
                  }
                }
              }
              aK = aK + 1;
              aM +=
                "routes{" +
                (aE + 1) +
                "}.starttime(" +
                (aR + 1) +
                ")=" +
                R.lapdata[aR].starttime +
                ";\n";
              aM +=
                "routes{" +
                (aE + 1) +
                "}.times(" +
                (aR + 1) +
                ",:)=[" +
                R.lapdata[aR].times.join(" ") +
                "];\n";
              aM +=
                "routes{" +
                (aE + 1) +
                "}.offsets(" +
                (aR + 1) +
                ",:)=[" +
                R.lapdata[aR].offsets.join(" ") +
                "];\n";
              aM +=
                "routes{" +
                (aE + 1) +
                "}.times_per_segment(" +
                (aR + 1) +
                ",:)=[" +
                aS.join(" ") +
                "];\n";
              aT +=
                R.runnername +
                " (" +
                (aR + 1) +
                ");Time;" +
                R.lapdata[aR].times.join(";") +
                "\n";
              aT +=
                R.runnername +
                " (" +
                (aR + 1) +
                ");Offsets;" +
                R.lapdata[aR].offsets.join(";") +
                "\n";
              ap +=
                R.runnername +
                " (" +
                (aR + 1) +
                ");Times;" +
                aS.join(";") +
                "\n";
              if (R.lapdata[aR].dspeed) {
                ap +=
                  R.runnername +
                  " (" +
                  (aR + 1) +
                  ");MaxSpeed;" +
                  ar.join(";") +
                  "\n";
                ap +=
                  R.runnername +
                  " (" +
                  (aR + 1) +
                  ");InSpeed;" +
                  aL.join(";") +
                  "\n";
                ap +=
                  R.runnername +
                  " (" +
                  (aR + 1) +
                  ");OutSpeed;" +
                  aA.join(";") +
                  "\n";
              }
              var aq = z.datafieldtypes;
              for (var ax = 0; ax < aq.length; ax++) {
                var aj = aq[ax];
                if (aj == "pulse") {
                  if (R.lapdata[aR][aj]) {
                    aM +=
                      "routes{" +
                      (aE + 1) +
                      "}." +
                      aj +
                      "(" +
                      (aR + 1) +
                      ",:)=[" +
                      R.lapdata[aR][aj].join(" ") +
                      "];\n";
                    aM +=
                      "routes{" +
                      (aE + 1) +
                      "}." +
                      aj +
                      "_per_segment_avg(" +
                      (aR + 1) +
                      ",:)=[" +
                      R.lapdata[aR].averages[aj].join(" ") +
                      "];\n";
                    aT +=
                      R.runnername +
                      " (" +
                      (aR + 1) +
                      ");" +
                      aj +
                      "average;" +
                      R.lapdata[aR][aj].join(";") +
                      "\n";
                    ap +=
                      R.runnername +
                      " (" +
                      (aR + 1) +
                      ");" +
                      aj +
                      "average;" +
                      R.lapdata[aR].averages[aj].join(";") +
                      "\n";
                  }
                }
              }
            }
          }
        }
        ay = ay + aM;
        ah = ah + aT;
        var aF = new Array();
        var aI = new Array();
        aI.start = new Array();
        aI.end = new Array();
        aI.type = new Array();
        aI.typeint = new Array();
        var at = z.courseinfo.hillsegments;
        var aN = new Array();
        for (var aR = 0; aR < at.length; aR++) {
          aN.push(aR);
          th = at[aR];
          aF.push(th.startind + " " + th.endind + " " + th.thetypeint);
          aI.start.push(th.startind);
          aI.end.push(th.endind);
          aI.type.push(th.thetype);
          aI.typeint.push(th.thetypeint);
          for (var aE = 0; aE < z.routes.length; aE++) {}
        }
        var aC = "eledetails=[" + aF.join(";") + "];\n";
        ay = ay + aC;
        var ac =
          "Hill segment number;;" +
          aN.join(";") +
          "\nStart point;;" +
          aI.start.join(";") +
          "\nEnd point;;" +
          aI.end.join(";") +
          "\nType;;" +
          aI.type.join(";") +
          "\nType number;;" +
          aI.typeint.join(";") +
          "\n";
        ah = ah + ac;
        ah = ah + ap;
        z.savetxtfile("coursedata.csv", ah);
        sleep(500);
        z.savetxtfile("coursedata.m", ay);
      } else {
        if (aU == 33) {
          z = mapviewer;
          var ay = "";
          var al = new Array();
          var aP = new Array();
          var az = new Array();
          var ag = new Array();
          for (var af = 0; af < z.coursecoords.length; af++) {
            var T = z.coursecoords[af].split(",");
            x1 = T[0];
            y1 = T[1];
            ele = parseFloat(T[2]);
            orgdist = parseFloat(T[3]);
            al.push(ele);
            aP.push(af);
            az.push(x1);
            ag.push(y1);
          }
          var ay = "var elevation=[" + al.join(",") + "];\n";
          var ay = ay + "var x=[" + az.join(",") + "];\n";
          ay = ay + "var y=[" + ag.join(",") + "];\n";
          var aF = new Array();
          var at = z.courseinfo.hillsegments;
          for (var aR = 0; aR < at.length; aR++) {
            th = at[aR];
            aF.push(th.startind + "," + th.endind + "," + th.thetypeint);
          }
          var aC = "eledetails=[" + aF.join(",") + "];\n";
          ay = ay + aC;
          if (!z.settings.dZ3D) {
            z.settings.dZ3D = 3;
          }
          ay =
            ay +
            "var thedZ=" +
            z.settings.dZ3D +
            ";var dZ=new Array(); for (var kk=0;kk<elevation.length;kk++) { if (kk==0) { dZ[kk]=0;} else if (kk<elevation.length/2) { dZ[kk]=dZ[kk-1]+1;} else { dZ[kk]=dZ[kk-1]-1;} dZ[kk]=thedZ; }\n";
          z.savetxtfile("coursedef.js", ay);
        } else {
          if (aU == 3) {
            var ai = new Object();
            z = mapviewer;
            var al = new Array();
            var aP = new Array();
            var az = new Array();
            var ag = new Array();
            for (var af = 0; af < z.coursecoords.length; af++) {
              var T = z.coursecoords[af].split(",");
              x1 = T[0];
              y1 = T[1];
              ele = parseFloat(T[2]);
              orgdist = parseFloat(T[3]);
              al.push(ele);
              aP.push(af);
              az.push(x1);
              ag.push(y1);
            }
            ai.elevation = al;
            ai.x = az;
            ai.y = ag;
            var aF = new Array();
            var at = z.courseinfo.hillsegments;
            for (var aR = 0; aR < at.length; aR++) {
              th = at[aR];
              aF.push(th.startind);
              aF.push(th.endind);
              aF.push(th.thetypeint);
            }
            ai.eledetails = aF;
            var am = new Array();
            for (var aR = 0; aR < ai.elevation.length; aR++) {
              if (aR == 0) {
                am[aR] = 0;
              } else {
                if (aR < ai.elevation.length / 2) {
                  am[aR] = am[aR - 1] + 1;
                } else {
                  am[aR] = am[aR - 1] - 1;
                }
              }
              am[aR] = 3;
            }
            ai.dZ = am;
            localStorage_setItem("course3D", JSON.stringify(ai));
            var S = "3dcourse.php";
            window.open(S, "_blank");
          }
        }
      }
    }
  };
  this.plotsegmentinfo = function (X, S) {
    allroutes = z.routes;
    if (!S) {
      S = 0;
    }
    var R = null;
    var Q = null;
    seg = new Object();
    seg.addinfo = "";
    if (parseInt(X) == X) {
    } else {
      if (X == "Uphill" || X == "Downhill" || X == "Flat" || X == "Complete") {
        seg.hilltype = "all " + X;
        searchtype = X;
        X = new Array();
        for (var ac = 0; ac < z.courseinfo.hillsegments.length; ac++) {
          thisseg = z.courseinfo.hillsegments[ac];
          if (thisseg.thetype == searchtype || searchtype == "Complete") {
            X.push(ac);
          }
        }
      } else {
        if (X.substr(0, 3) == "CMP") {
          var M = X.split("|");
          fasterslower = M[1];
          antsec = parseFloat(M[2]);
          searchtype = M[3];
          seg.addinfo =
            " - segments more than " + antsec + " second " + fasterslower;
          for (var O = 0; O < z.routes.length; O++) {
            if (z.routes[O].show) {
              if (R == null) {
                R = O;
              } else {
                Q = O;
                O = z.routes.length + 1;
              }
            }
          }
          X = new Array();
          for (var ac = 0; ac < z.courseinfo.hillsegments.length; ac++) {
            thisseg = z.courseinfo.hillsegments[ac];
            var aa = z.routes[R].lapdata[0].averages.times[ac];
            var Z = z.routes[Q].lapdata[0].averages.times[ac];
            if (
              (aa - Z >= Math.abs(antsec) && fasterslower == "Faster") ||
              (Z - aa >= Math.abs(antsec) && fasterslower == "Slower")
            ) {
              if (thisseg.thetype == searchtype || searchtype == "Complete") {
                X.push(ac);
              }
            }
          }
        }
      }
    }
    if (parseInt(X) == X) {
      thisseg = z.courseinfo.hillsegments[X];
      seg.thelength = Math.floor(thisseg.thelength);
      seg.percent = " (" + thisseg.percent + "%)";
      seg.elediff = Math.floor(thisseg.theelediff);
      seg.hilltype = thisseg.thetype;
      seg.segmentinfo = "Segment " + (X + 1);
      X = [X];
    } else {
      seg.thelength = 0;
      if (!seg.hilltype) {
        seg.hilltype = null;
      }
      for (var ac = 0; ac < X.length; ac++) {
        thisseg = z.courseinfo.hillsegments[X[ac]];
        seg.thelength = seg.thelength + Math.floor(thisseg.thelength);
        seg.elediff = null;
        if (seg.hilltype != null && seg.hilltype != thisseg.thetype) {
          if (seg.hilltype.substr(0, 3) == "all") {
          } else {
            seg.hilltype = "Mixed";
          }
        } else {
          seg.hilltype = thisseg.thetype;
        }
      }
      seg.percent = " (" + X.length + " segments)";
      seg.segmentinfo = "Segments";
    }
    fieldtypes = [
      "times",
      "syklusvei",
      "tidpersyklus",
      "cadence",
      "roll",
      "tsymmetry",
      "pulse",
      "pitch",
      "yaw",
      "smo2",
      "thb",
    ];
    fieldtypesb = [
      "Tid",
      "Syklusvei",
      "TidPerSyklus",
      "SyklusPerMinutt",
      "Sidestabilitet",
      "Tid h?yre/venstre",
      "Puls",
      "Fremoverstabilitet",
      "Rotasjon",
      "Smo2",
      "tHb",
    ];
    html = "";
    firstrow_html = "<tr><td class=ttitle></td>";
    names = new Array();
    colors = new Array();
    usednames = new Array();
    divs = "";
    plotthis = new Array();
    for (var Y = 0; Y < fieldtypes.length; Y++) {
      fname = fieldtypes[Y];
      fnameb = fieldtypesb[Y];
      usethistype = 0;
      vals = new Array();
      cc = 0;
      htmlrow = "<tr><td>" + fnameb.capitalize() + "</td>";
      for (rnr = 0; rnr < allroutes.length; rnr++) {
        var U = allroutes[rnr];
        var W = 1;
        if (R != null && Q != null && rnr != R && rnr != Q) {
          W = 0;
        }
        if (U.show && W) {
          var N = U.runnername_short;
          var T = U.lapdata.length;
          if (rnr == R || rnr == Q) {
            T = 1;
          }
          for (lnr = 0; lnr < T; lnr++) {
            if (Y == 0) {
              tname = N;
              counter = 2;
              while (usednames[tname]) {
                tname = N + " " + counter;
                counter++;
              }
              usednames[tname] = 1;
              names[cc] = tname;
              colors[cc] = "#" + U.color;
              firstrow_html =
                firstrow_html +
                "<td class=ttitle>" +
                tname.capitalize() +
                "</td>";
            }
            if (U.lapdata[lnr].averages[fname]) {
              val = 0;
              for (var V = 0; V < X.length; V++) {
                if (fname != "cadence") {
                  val = val + U.lapdata[lnr].averages[fname][X[V]];
                } else {
                  val = val + U.lapdata[lnr].averages.tidpersyklus[X[V]];
                }
              }
              if (fname == "cadence") {
                val = val / X.length;
                if (val != 0) {
                  val = (1 / val) * 60;
                }
              } else {
                if (fname != "times") {
                  val = val / X.length;
                }
              }
            } else {
              val = NaN;
            }
            vals[cc] = val;
            cc++;
            if (isNaN(val)) {
              tval = "";
            } else {
              tval = parseInt(10 * val) / 10;
              usethistype = 1;
            }
            htmlrow = htmlrow + "<td>" + tval + "</td>";
          }
        }
      }
      seg[fname] = vals;
      seg.names = names;
      htmlrow = htmlrow + "</tr>";
      if (usethistype) {
        html = html + htmlrow;
      }
      divw = parseInt(40 * (cc + 2));
      divh = 200;
      divw = (getBrowserWidth() * 5) / 6 - 50;
      divh = 350;
      if (usethistype) {
        divs =
          divs +
          '<div id="' +
          fname +
          'plot" class="draggable" style="width:' +
          divw +
          "px;height:" +
          divh +
          'px;float:left;"></div>';
        plotthis[fname] = 1;
      } else {
        plotthis[fname] = 0;
      }
    }
    firstrow_html = firstrow_html + "</tr>";
    html =
      divs +
      '<div style="clear:both;"></div><p><table class=dettable>' +
      firstrow_html +
      html +
      "</table>";
    z.open_xdialog(
      seg.segmentinfo +
        " :" +
        seg.thelength +
        " m " +
        seg.hilltype +
        seg.percent +
        seg.addinfo,
      html,
      0
    );
    for (var Y = 0; Y < fieldtypes.length; Y++) {
      fname = fieldtypes[Y];
      fnameb = fieldtypesb[Y];
      if (plotthis[fname]) {
        data = seg[fname];
        mindata = data.min() - (data.max() - data.min()) / 3;
        maxdata = data.max() + (data.max() - data.min()) / 3;
        if (maxdata - mindata < 0.2) {
          mindata = mindata - 0.1;
          maxdata = maxdata + 0.1;
        } else {
          if (maxdata - mindata < 0.4) {
            mindata = mindata - 0.1;
            maxdata = maxdata + 0.1;
          }
        }
        var ab = new Array();
        for (var O = 0; O < data.length; O++) {
          if (Math.abs(seg[fname][O]) < 3) {
            fact = 100;
          } else {
            fact = 10;
          }
          ab[O] = [names[O], parseInt(fact * seg[fname][O]) / fact];
        }
        if (S) {
          if (fname == "times") {
            sind = findsort(ab);
          }
          if (sind) {
            ab = sortline(ab, sind);
          }
          scolors = sortline(colors, sind);
        } else {
          scolors = colors;
        }
        formatstr = "%.1f";
        if (Math.abs(maxdata) < 3) {
          formatstr = "%.2f";
        }
        if (fname == "syklusvei") {
          formatstr = "%.1f";
        }
        barplot(
          fname + "plot",
          fnameb.capitalize(),
          [ab],
          scolors,
          formatstr,
          mindata,
          maxdata
        );
      }
    }
    $(".draggable").draggable();
  };
  this.plotupdownflat = function () {
    z = mapviewer;
    allroutes = z.routes;
    html = "";
    names = new Array();
    colors = new Array();
    divs = "";
    var V = z.hilltypes.slice();
    V.push("Complete");
    plotthis = new Array();
    seg = new Object();
    for (var T = 0; T < V.length; T++) {
      firstrow_html = "<tr><td class=ttitle></td>";
      segname = V[T];
      var R = null;
      var Q = null;
      seg.addinfo = "";
      seg.hilltype = "all " + segname;
      searchtype = segname;
      segnr = new Array();
      for (var Z = 0; Z < z.courseinfo.hillsegments.length; Z++) {
        thisseg = z.courseinfo.hillsegments[Z];
        if (thisseg.thetype == searchtype || searchtype == "Complete") {
          segnr.push(Z);
        }
      }
      if (segnr.length > 0) {
        seg.thelength = 0;
        if (!seg.hilltype) {
          seg.hilltype = null;
        }
        for (var Z = 0; Z < segnr.length; Z++) {
          thisseg = z.courseinfo.hillsegments[segnr[Z]];
          seg.thelength = seg.thelength + Math.floor(thisseg.thelength);
          seg.elediff = null;
          if (seg.hilltype != null && seg.hilltype != thisseg.thetype) {
            if (seg.hilltype.substr(0, 3) == "all") {
            } else {
              seg.hilltype = "Mixed";
            }
          } else {
            seg.hilltype = thisseg.thetype;
          }
        }
        seg.percent = " (" + segnr.length + " segments)";
        seg.segmentinfo = "Segments";
        fname = "times";
        fnameb = "Tid";
        usethistype = 0;
        vals = new Array();
        cc = 0;
        htmlrow = "<tr><td>" + segname + "</td>";
        usedrnames = new Array();
        for (rnr = 0; rnr < allroutes.length; rnr++) {
          var U = allroutes[rnr];
          var X = 1;
          if (R != null && Q != null && rnr != R && rnr != Q) {
            X = 0;
          }
          if (U.show && X) {
            var N = U.runnername_middle;
            if (usedrnames[N]) {
              N = U.runnername;
            }
            var M = 1;
            while (usedrnames[N]) {
              N = N + "" + M;
              M++;
            }
            usedrnames[N] = N;
            var S = U.lapdata.length;
            if (rnr == R || rnr == Q) {
              S = 1;
            }
            usednames = new Array();
            for (lnr = 0; lnr < S; lnr++) {
              tname = N;
              M = 2;
              while (usednames[tname]) {
                tname = N + " " + M;
                M++;
              }
              usednames[tname] = 1;
              names[cc] = tname;
              colors[cc] = "#" + U.color;
              firstrow_html =
                firstrow_html + "<td class=ttitle>" + tname + "</td>";
              if (U.lapdata[lnr].averages[fname]) {
                val = 0;
                for (var W = 0; W < segnr.length; W++) {
                  if (fname != "cadence") {
                    val = val + U.lapdata[lnr].averages[fname][segnr[W]];
                  } else {
                    val = val + U.lapdata[lnr].averages.tidpersyklus[segnr[W]];
                  }
                }
                if (fname == "cadence") {
                  val = val / segnr.length;
                  if (val != 0) {
                    val = (1 / val) * 60;
                  }
                } else {
                  if (fname != "times") {
                    val = val / segnr.length;
                  }
                }
              } else {
                val = NaN;
              }
              vals[cc] = val;
              cc++;
              if (isNaN(val)) {
                tval = "";
              } else {
                tval = parseInt(10 * val) / 10;
                usethistype = 1;
              }
              htmlrow = htmlrow + "<td>" + tval + "</td>";
            }
          }
        }
        seg[segname] = vals;
        seg.names = names;
        htmlrow = htmlrow + "</tr>";
        if (usethistype) {
          html = html + htmlrow;
        }
        divw = (getBrowserWidth() * 5) / 6 - 50;
        divh = 350;
        if (usethistype) {
          divs =
            divs +
            '<div id="' +
            segname +
            'plot" class="draggable" style="width:' +
            divw +
            "px;height:" +
            divh +
            'px;float:left;"></div>';
          plotthis[segname] = 1;
        } else {
          plotthis[segname] = 0;
        }
        firstrow_html = firstrow_html + "</tr>";
        if (segname == "Complete") {
          the_firstrow_html = firstrow_html;
        }
      }
    }
    html =
      divs +
      '<div style="clear:both;"></div><p><table class=dettable>' +
      the_firstrow_html +
      html +
      "</table>";
    z.open_xdialog("Comparison up/down/flat", html, 0);
    for (var T = 0; T < V.length; T++) {
      segname = V[T];
      if (seg[segname]) {
        fname = "times";
        fnameb = "Tid";
        data = seg[segname];
        mindata = data.min() - (data.max() - data.min()) / 3;
        maxdata = data.max() + (data.max() - data.min()) / 3;
        if (maxdata - mindata < 0.2) {
          mindata = mindata - 0.1;
          maxdata = maxdata + 0.1;
        } else {
          if (maxdata - mindata < 0.4) {
            mindata = mindata - 0.1;
            maxdata = maxdata + 0.1;
          }
        }
        var Y = new Array();
        for (var O = 0; O < data.length; O++) {
          if (Math.abs(seg[segname][O]) < 3) {
            fact = 100;
          } else {
            fact = 10;
          }
          Y[O] = [names[O], parseInt(fact * seg[segname][O]) / fact];
        }
        scolors = colors;
        formatstr = "%.1f";
        if (Math.abs(maxdata) < 3) {
          formatstr = "%.2f";
        }
        if (fname == "syklusvei") {
          formatstr = "%.1f";
        }
        barplot(
          segname + "plot",
          segname,
          [Y],
          scolors,
          formatstr,
          mindata,
          maxdata
        );
        data = $("#" + segname + "plot").jqplotToImageStr({});
        data = data.replace("image/png", "image/octet-stream");
        downloadImg(data, segname + "plot.png");
      }
    }
    $(".draggable").draggable();
  };
  this.plotsegmentoverview = function (N, M, O) {
    var N = null;
    var M = null;
    if (!N && !M && !O) {
      for (var R = 0; R < z.routes.length; R++) {
        if (z.routes[R].show) {
          if (N == null) {
            N = R;
          } else {
            M = R;
            R = z.routes.length + 1;
          }
        }
      }
    }
    if (!O) {
      O = z.datafieldtypes[$("#selectgraph-1").val() - 5];
    }
    if (N == null || M == null) {
      alert("Not enough routes shown. Aborting!");
      return;
    }
    if (!O) {
      alert("No valid datatype. Aborting!");
      return;
    }
    miny = -10;
    maxy = 10;
    z.findhills_eleprofile();
    segs = z.courseinfo.hillsegments;
    colors = new Array();
    updowns = new Array();
    percent = new Array();
    for (var R = 0; R < segs.length; R++) {
      colors[R] = segs[R].hillcolor;
      updowns[R] = segs[R].thetypeint;
      percent[R] = segs[R].percent;
    }
    fname = O;
    data1 = z.routes[N].lapdata[0].averages[fname];
    data2 = z.routes[M].lapdata[0].averages[fname];
    dataline = new Array();
    for (var R = 0; R < data1.length; R++) {
      dataline[R] = data2[R] - data1[R];
    }
    fname = "times";
    data1 = z.routes[N].lapdata[0].averages[fname];
    data2 = z.routes[M].lapdata[0].averages[fname];
    data = new Array();
    for (var R = 0; R < data1.length; R++) {
      data[R] = data2[R] - data1[R];
    }
    title =
      z.routes[N].runnername +
      " vs " +
      z.routes[M].runnername +
      ": Time and " +
      O.capitalize();
    z.plotgraph_dialog(title);
    segs = z.courseinfo.hillsegments;
    colors = new Array();
    for (var R = 0; R < segs.length; R++) {
      colors[R] = segs[R].hillcolor;
    }
    var Q = $.jqplot("plotdialog", [data], {
      series: [{ renderer: $.jqplot.BarRenderer }],
      axes: {
        xaxis: { renderer: $.jqplot.CategoryAxisRenderer, min: 0, max: 52 },
        yaxis: { min: -5, max: 5 },
      },
      seriesColors: colors,
      seriesDefaults: {
        renderer: $.jqplot.LineRenderer,
        color: "#00f",
        rendererOptions: {
          fillToZero: true,
          barMargin: 2,
          barWidth: 15,
          varyBarColor: true,
          useNegativeColors: false,
        },
      },
    });
    $("#plotdialog").bind("jqplotDataClick", function (U, S, T, V) {
      mapviewer.plotsegmentinfo(T);
    });
  };
  this.set_spas_nameid = function () {
    chosen_nameid = $("#spasnameidinput").val();
    if (!chosen_nameid) {
      alert("Please choose a name/ID!");
      return;
    }
    var M = chosen_nameid;
    var N = z.savespastxttofile(M, "name.txt", chosen_nameid);
    if (N.status == "OK") {
      z.spasnameid = chosen_nameid;
      z.spasnameid_server = N.diridprocessed;
      $("#spasstep2").show();
      $("#spasnameid").html(
        "<b>SPAS Name/ID:</b> " + chosen_nameid + "<br><br>"
      );
    } else {
      alert("Could not make this name/ID. Please try a different name/ID!");
    }
  };
  this.open_makespas_dialog = function () {
    var M =
      '<div id="spasnameid"><b>SPAS Name/ID:</b> <input id="spasnameidinput" size=40> <button onclick="mapviewer.set_spas_nameid();">Step 1: Set SPAS name/ID</button></div>';
    z.open_fulldialog(
      "Make SPAS",
      '<button onclick="mapviewer.close_fulldialog();">Back to Analysis mode</button><br><br>This is a very experimental feature to setup a SPAS analysis. Note that SPAS-analysis is intended to be used only for sprint-orienteering - not for forest orienteering. The procedure to make a SPAS analysis is as follows: <ol><li>Choose a name/ID for your SPAS-analysis<li>Make SPAS illustrations (three illustration for each leg) with leg only, leg with alternatives and leg with alternatives and route lenghts. This is done by clicking the "Make SPAS illustrations"-button below. Note that before you can do this, you have to:<ul><li>Draw all required alternatives for all legs. Please <a href="javascript:void(0)"  onclick="mapviewer.close_fulldialog();">go back to analysis mode</a> and <b>check that you have drawn all the required alternatives for all legs</b> - there is no redoing once a SPAS has been made!</li><li>Remember to "Set names and colors" and apply <b>"SPAS color scheme". If you have not, <a href="javascript:void(0)"  onclick="mapviewer.close_fulldialog();">go back and do it</a>, then come back here again.</b></li></ul><li>Add split times exported from WooSplits (button will be available after SPAS illustrations are generated). Thus <b>make sure split times are available in a format that is supported by <a target=_blank href="http://events.worldofo.com/woosplits/">Woosplits</a></b> before proceeding (e.g. IOF xml-format exported from WinSplits Pro).<li>Check that your SPAS-analysis looks good<li>Deploy to server.</ol><h2>Step 1: Choose name for SPAS analysis (can not be changed)</h2>Choose a name/ID for your SPAS analysis. Note that you can never overwrite a SPAS-analysis - you are stuck with what you make, and the name/ID you choose. Please remember to include class/course name as you need to make one SPAS for each class/course.<br><br>' +
        M +
        '<br><div id="spasstep2" style="display:none"><h2>Step 2: Make SPAS illustrations</h2>When you have made sure the points above are fulfilled, you can make SPAS illustrations by pressing the button below. Then allow for up to a few minutes waiting while all images are generated on the server (it may feel like the browser hangs while processing, but please be patient...).<br><br><button id="spasbuttonstep2" onclick="mapviewer.dosavecourse_new2(\'h1000server\',\'nova\',0,-1);">Step 2: Make SPAS illustrations</button></div><div id="makespasprogress"></div><div id="spascontent"></div><hr><br><button onclick="mapviewer.close_fulldialog();">Back to Analysis mode</button>',
      0
    );
    if (z.spasnameid) {
      $("#spasnameid").html(
        "<b>SPAS Name/ID:</b> " +
          chosen_nameid +
          " <i>(Name can not be changed anymore)</i><br><br>"
      );
      $("#spasstep2").show();
    }
  };
  this.dosavecourse_new2 = function (R, O, S, W) {
    var Q = 0;
    if (!R) {
      R = "h1000";
    }
    var M = 700;
    var V = 1000;
    var N = "wh";
    var U = 10 * 1.5;
    var T = 24 * 1.5;
    if (R == "w700h1000") {
    } else {
      if (R == "h1000") {
        M = 0;
        V = 1000;
        N = "h";
        U = 10 * 1.5;
        T = 24 * 1.6;
      } else {
        if (R == "h1200") {
          M = 0;
          V = 1200;
          N = "h";
          U = 10 * 2;
          T = 24 * 2;
        } else {
          if (R == "h1000server") {
            M = 0;
            V = 1000;
            N = "h";
            U = 10 * 1.5;
            T = 24 * 1.6;
            Q = 1;
          }
        }
      }
    }
    mapviewer.savecourse_new2(O, M, V, N, U, T, S, W, Q);
  };
  this.savecourse_new2 = function (ad, ae, ab, X, Z, Y, V, T, R) {
    var S = "";
    var M = "";
    if (R) {
      M = z.spasnameid;
      z.spasimgs = new Array();
    }
    z = mapviewer;
    var ai;
    if (z.map.id == "localimage") {
      ai = z.map.name;
    } else {
      ai = "img";
    }
    ai = ai.replace(/\.jpg/g, "");
    ai = ai.replace(/\.gif/g, "");
    ai = ai.replace(/_\d+/g, "");
    ai = ai.replace(/|/g, "");
    ai = ai.replace(/[\. 骧邃鯻]/g, "");
    var N = 0.2;
    for (var ac = 0; ac < z.coursecoords.length - 1; ac++) {
      if (T == ac || T == -1) {
        z.settings.centerlegnum = ac + 1;
        z.showtags_control(ac + 1);
        if (V == 0) {
          z.centerleg(ac, N);
        }
        var af =
          "leg_" +
          parseInt(z.settings.centerlegnum).toFixed().pad(2, "0") +
          "_" +
          ai;
        if (R) {
          z.spasimgs.push(af);
        }
        var aa;
        for (var W = 1; W <= 3; W++) {
          var ag = 1;
          if (ad == "ABC") {
            if (W == 3) {
              ending = "_A";
              mapviewer.settings.tagging_timealt = 0;
              mapviewer.settings.showtagmode = 0;
              z.settings.mapopacity = 0.8;
            } else {
              if (W == 2) {
                ending = "_B";
                mapviewer.settings.tagging_timealt = 4;
                mapviewer.settings.showtagmode = 1;
                z.settings.mapopacity = 0.5;
              } else {
                if (W == 1) {
                  ending = "_C";
                  mapviewer.settings.tagging_timealt = 0;
                  mapviewer.settings.showtagmode = 1;
                  z.settings.mapopacity = 0.5;
                }
              }
            }
          } else {
            if (ad == "nova") {
              if (W == 3) {
                ending = "_no";
                mapviewer.settings.tagging_timealt = 0;
                mapviewer.settings.showtagmode = 0;
                z.settings.mapopacity = 0.8;
              } else {
                if (W == 2) {
                  ending = "_va";
                  mapviewer.settings.tagging_timealt = 4;
                  mapviewer.settings.showtagmode = 1;
                  z.settings.mapopacity = 0.5;
                } else {
                  if (W == 1) {
                    ending = "";
                    mapviewer.settings.tagging_timealt = 0;
                    mapviewer.settings.showtagmode = 1;
                    z.settings.mapopacity = 0.5;
                  }
                }
              }
            }
          }
          fname = af + ending + ".png";
          if (ag) {
            z.settings.isprinting = 1;
            z.redraw();
            z.play_loop();
            if (W == 1) {
              aa = z.saveshowntags(fname, ae, ab, X, Z, Y, V, R, M);
            } else {
              if (!R) {
                downloadImg(
                  z.savemaprectangle_custom(
                    aa.xn1,
                    aa.yn1,
                    aa.xn2,
                    aa.yn2,
                    aa.targeth,
                    aa.routewidth,
                    aa.txtsize
                  ),
                  fname
                );
                sleep(500);
              } else {
                var aj = z.savemaprectangle_custom(
                  aa.xn1,
                  aa.yn1,
                  aa.xn2,
                  aa.yn2,
                  aa.targeth,
                  aa.routewidth,
                  aa.txtsize
                );
                z.savespasimgtofile(aj, fname, M);
                sleep(200);
              }
            }
            z.settings.isprinting = 0;
          }
        }
      }
      $("#makespasprogress").html("Processing leg " + (ac + 1));
      var ak = "";
      var ah = new Array();
      var Q = new Array();
      for (var O = 0; O < z.tags.length; O++) {
        var U = z.tags[O];
        if (U.type == "route" && U.show) {
          ak += U.name + ";" + parseInt(U.length) + "\n";
          ah.push(U.name);
          Q.push(parseInt(U.length));
        }
      }
      fname = af;
      if (T == ac || T == -1) {
        z.savetxtfile(fname, ak, R, M);
        if (!R) {
          S =
            S +
            ai +
            "|" +
            (ac + 1) +
            "|" +
            af +
            ".png|" +
            ah.join(";") +
            "|" +
            Q.join(";") +
            "|\n";
        } else {
          S =
            S +
            "class|" +
            (ac + 1) +
            "|" +
            af +
            ".png|" +
            ah.join(";") +
            "|" +
            Q.join(";") +
            "|\n";
        }
      }
    }
    if (T == ac || T == -1) {
      z.savetxtfile("config.txt", S, R, M);
    }
    if (R) {
      z.showlastspas();
      $("#makespasprogress").html("");
    }
  };
  this.saveshowntags = function (ab, M, O, ac, ak, ar, X, aD, W) {
    z = mapviewer;
    var ap = [];
    var N = [];
    var aq = parseInt(z.settings.centerlegnum);
    var Y = aq - 1;
    var at = aq;
    var ay = z.coursecoords[Y].split(",");
    var V = parseFloat(ay[0]);
    var T = parseFloat(ay[1]);
    P_screen_from = z.canvas.context.itransformedPoint_rot(V, T);
    var ay = z.coursecoords[at].split(",");
    var R = parseFloat(ay[0]);
    var Q = parseFloat(ay[1]);
    P_screen_to = z.canvas.context.itransformedPoint_rot(R, Q);
    ap.push(P_screen_from.x);
    N.push(P_screen_from.y);
    ap.push(P_screen_to.x);
    N.push(P_screen_to.y);
    ap.push(P_screen_from.x);
    N.push(
      P_screen_from.y + z.settings.controlRadius * z.canvas.zoomfactor * 1.2
    );
    ap.push(P_screen_to.x);
    N.push(
      P_screen_to.y - z.settings.controlRadius * z.canvas.zoomfactor * 1.2
    );
    for (var aF = 0; aF < z.tags.length; aF++) {
      var ae = z.tags[aF];
      if (ae.type == "route" && ae.show == 1) {
        var ai = ae.pointsxy;
        if (ai) {
          for (jj = 0; jj < ai.length; jj++) {
            var S = ai[jj];
            var an = S.split(",");
            var af = parseFloat(an[0]);
            var ad = parseFloat(an[1]);
            P_screen = z.canvas.context.itransformedPoint_rot(af, ad);
            ap.push(P_screen.x);
            N.push(P_screen.y);
            ap.push(P_screen_to.x + (P_screen.x - P_screen_to.x));
            N.push(P_screen.y);
            ap.push(P_screen_to.x - (P_screen.x - P_screen_to.x));
            N.push(P_screen.y);
          }
          var S = ai[Math.floor(ai.length / 2)];
          var an = S.split(",");
          var aC = an[0];
          var aB = an[1];
          var az = parseInt(aC) + ae.offsettxt_x;
          var ax = parseInt(aB) + ae.offsettxt_y;
          var U = "X (99999 m)";
          var aA = z.canvas.context.measureText(U).width * 1.1;
          var aK = 15;
          P_screen = z.canvas.context.itransformedPoint_rot(az, ax);
          P_screen.x = P_screen.x + aA;
          P_screen.y = P_screen.y + aK;
          ap.push(P_screen.x);
          N.push(P_screen.y);
          ap.push(P_screen_to.x + (P_screen.x - P_screen_to.x));
          N.push(P_screen.y);
          ap.push(P_screen_to.x - (P_screen.x - P_screen_to.x));
          N.push(P_screen.y);
          P_screen.x = P_screen.x - 2 * aA;
          P_screen.y = P_screen.y - 2 * aK;
          ap.push(P_screen.x);
          N.push(P_screen.y);
          ap.push(P_screen_to.x + (P_screen.x - P_screen_to.x));
          N.push(P_screen.y);
          ap.push(P_screen_to.x - (P_screen.x - P_screen_to.x));
          N.push(P_screen.y);
        }
      }
    }
    var al = 20;
    if (z.settings.multbufferm) {
      al = al * z.settings.multbufferm;
    }
    var aj = 100;
    var aI = calcdistance(
      mapviewer.map.tolatlng(0, 0).lat,
      mapviewer.map.tolatlng(0, 0).lng,
      mapviewer.map.tolatlng(0, aj).lat,
      mapviewer.map.tolatlng(0, aj).lng
    );
    var ag = parseInt((aj * al) / aI);
    var aa = ap.min() - ag;
    var Z = ap.max() + ag;
    var aL = N.min() - ag;
    var aJ = N.max() + ag;
    var aE = Z - aa;
    var aH = aJ - aL;
    var aw = O;
    if (ac == "wh") {
      newh = (aE * O) / M;
      dh = (newh - aH) / 2;
      y1o = aL;
      y2o = aJ;
      x1o = aa;
      x2o = Z;
      if (dh > 0) {
        aL = aL - dh;
        aJ = aJ + dh;
      } else {
        neww = (aH * M) / O;
        dw = (neww - aE) / 2;
        aa = aa - dw;
        Z = Z + dw;
      }
      console.log(
        "(" +
          x1o +
          "," +
          y1o +
          ") - (" +
          x2o +
          "," +
          y2o +
          ") -> (" +
          aa +
          "," +
          aL +
          ") - (" +
          Z +
          "," +
          aJ +
          ")"
      );
    } else {
      if (ac == "w") {
        newh = ((((aH / O) * M) / aE) * O * O) / M;
        aw = newh;
      } else {
        if (ac == "h") {
        }
      }
    }
    var av = mapviewer.canvas.context.transformedPoint(aa, aL).x;
    var ao = mapviewer.canvas.context.transformedPoint(aa, aL).y;
    var au = mapviewer.canvas.context.transformedPoint(Z, aJ).x;
    var am = mapviewer.canvas.context.transformedPoint(Z, aJ).y;
    if (!aD) {
      downloadImg(z.savemaprectangle_custom(av, ao, au, am, aw, ak, ar), ab);
    } else {
      var aG = z.savemaprectangle_custom(av, ao, au, am, aw, ak, ar);
      z.savespasimgtofile(aG, ab, W);
    }
    var ah = new Object();
    ah.xn1 = av;
    ah.yn1 = ao;
    ah.xn2 = au;
    ah.yn2 = am;
    ah.targeth = aw;
    ah.routewidth = ak;
    ah.txtsize = ar;
    return ah;
  };
  z.savemaprectangle_custom = function (ae, R, ad, Q, S, V, U) {
    x1t = z.canvas.context.itransformedPoint_rot(ae, R).x;
    y1t = z.canvas.context.itransformedPoint_rot(ae, R).y;
    x2t = z.canvas.context.itransformedPoint_rot(ad, Q).x;
    y2t = z.canvas.context.itransformedPoint_rot(ad, Q).y;
    var ab = z.canvas.context.transformedPoint(
      (x1t + x2t) / 2,
      (y1t + y2t) / 2
    ).x;
    var N = z.canvas.context.transformedPoint(
      (x1t + x2t) / 2,
      (y1t + y2t) / 2
    ).y;
    x1tt = z.canvas.context.transformedPoint(x1t, y1t).x;
    y1tt = z.canvas.context.transformedPoint(x1t, y1t).y;
    x2tt = z.canvas.context.transformedPoint(x1t, y2t).x;
    y2tt = z.canvas.context.transformedPoint(x1t, y2t).y;
    x3tt = z.canvas.context.transformedPoint(x2t, y2t).x;
    y3tt = z.canvas.context.transformedPoint(x2t, y2t).y;
    x4tt = z.canvas.context.transformedPoint(x2t, y1t).x;
    y4tt = z.canvas.context.transformedPoint(x2t, y1t).y;
    var M = 0;
    var W = z.canvas.width;
    var ac = z.canvas.height;
    var Y = (x2t - x1t) / z.canvas.zoomfactor;
    var X = (y2t - y1t) / z.canvas.zoomfactor;
    var ah = z.canvas.cx;
    var ag = z.canvas.cy;
    var O = z.canvas.zoomfactor;
    var aa = S;
    var T = aa / Math.abs(X);
    var M = T / z.canvas.zoomfactor;
    if (V) {
      z.settings.routewidth = V;
      z.canvas.outlinetxtsize = U;
    } else {
      z.settings.routewidth = z.settings.routewidth * M;
      z.canvas.outlinetxtsize = z.canvas.outlinetxtsize * M;
    }
    var af = z.settings.menu_isvisible;
    z.settings.menu_isvisible = 0;
    z.settings.isprinting = 1;
    z.canvas.canvaselement.width = Y * T;
    z.canvas.canvaselement.height = X * T;
    z.canvas.zoomfactor = T;
    z.move_mapxy_to_center(ab, N);
    z.canvas.width = Y * T;
    z.canvas.height = X * T;
    z.move_mapxy_to_center(ab, N);
    z.redraw();
    if (0) {
      var Z = z.canvas.canvaselement.toDataURL("image/png");
      var ai = new Image();
      ai.src = Z;
      z.canvas.context.fillStyle = "rgba(255,255,255,1)";
      z.canvas.context.fillRect(
        -2 * z.canvas.width,
        -2 * z.canvas.height,
        4 * z.canvas.width,
        4 * z.canvas.height
      );
      z.canvas.context.globalAlpha = 1;
      z.canvas.context.drawImage(ai, 0, 0);
    }
    type = mapviewer.settings.printscreentype;
    if (type == "jpg") {
      type = "jpeg";
    }
    var ai = mapviewer.canvas.canvaselement.toDataURL("image/" + type, 0.85);
    z.settings.isprinting = 0;
    z.settings.menu_isvisible = af;
    z.settings.routewidth = z.settings.routewidth / M;
    z.canvas.outlinetxtsize = z.canvas.outlinetxtsize / M;
    z.canvas.cx = ah;
    z.canvas.cy = ag;
    z.canvas.zoomfactor = O;
    z.request_redraw();
    return ai;
  };
  this.savemaprectangle = function (ab, R, aa, Q) {
    x1t = z.canvas.context.itransformedPoint_rot(ab, R).x;
    y1t = z.canvas.context.itransformedPoint_rot(ab, R).y;
    x2t = z.canvas.context.itransformedPoint_rot(aa, Q).x;
    y2t = z.canvas.context.itransformedPoint_rot(aa, Q).y;
    var Y = z.canvas.context.transformedPoint(
      (x1t + x2t) / 2,
      (y1t + y2t) / 2
    ).x;
    var N = z.canvas.context.transformedPoint(
      (x1t + x2t) / 2,
      (y1t + y2t) / 2
    ).y;
    x1tt = z.canvas.context.transformedPoint(x1t, y1t).x;
    y1tt = z.canvas.context.transformedPoint(x1t, y1t).y;
    x2tt = z.canvas.context.transformedPoint(x1t, y2t).x;
    y2tt = z.canvas.context.transformedPoint(x1t, y2t).y;
    x3tt = z.canvas.context.transformedPoint(x2t, y2t).x;
    y3tt = z.canvas.context.transformedPoint(x2t, y2t).y;
    x4tt = z.canvas.context.transformedPoint(x2t, y1t).x;
    y4tt = z.canvas.context.transformedPoint(x2t, y1t).y;
    var M = 0;
    var T = z.canvas.width;
    var Z = z.canvas.height;
    var V = (x2t - x1t) / z.canvas.zoomfactor;
    var U = (y2t - y1t) / z.canvas.zoomfactor;
    var ae = z.canvas.cx;
    var ad = z.canvas.cy;
    var O = z.canvas.zoomfactor;
    var X = 1000;
    if (z.settings.multh_download) {
      X = X * z.settings.multh_download;
    }
    var S = X / Math.abs(U);
    var M = S / z.canvas.zoomfactor;
    z.settings.routewidth = z.settings.routewidth * M;
    z.canvas.outlinetxtsize = z.canvas.outlinetxtsize * M;
    var ac = z.settings.menu_isvisible;
    z.settings.menu_isvisible = 0;
    z.settings.isprinting = 1;
    z.canvas.canvaselement.width = V * S;
    z.canvas.canvaselement.height = U * S;
    z.canvas.zoomfactor = S;
    z.move_mapxy_to_center(Y, N);
    z.canvas.width = V * S;
    z.canvas.height = U * S;
    z.move_mapxy_to_center(Y, N);
    z.redraw();
    if (0) {
      var W = z.canvas.canvaselement.toDataURL("image/png");
      var af = new Image();
      af.src = W;
      z.canvas.context.fillStyle = "rgba(255,255,255,1)";
      z.canvas.context.fillRect(
        -2 * z.canvas.width,
        -2 * z.canvas.height,
        4 * z.canvas.width,
        4 * z.canvas.height
      );
      z.canvas.context.globalAlpha = 1;
      z.canvas.context.drawImage(af, 0, 0);
    }
    type = mapviewer.settings.printscreentype;
    if (type == "jpg") {
      type = "jpeg";
    }
    var af = mapviewer.canvas.canvaselement.toDataURL("image/" + type, 0.85);
    z.settings.isprinting = 0;
    z.settings.menu_isvisible = ac;
    z.settings.routewidth = z.settings.routewidth / M;
    z.canvas.outlinetxtsize = z.canvas.outlinetxtsize / M;
    z.canvas.cx = ae;
    z.canvas.cy = ad;
    z.canvas.zoomfactor = O;
    z.request_redraw();
    return af;
  };
  this.loadLogForm = function () {
    var M;
    if (z.editlogmode) {
      M = "../2d/js/AnalysisLogDef.json";
    } else {
      M = "js/AnalysisLogDef.json";
    }
    $.ajax({
      type: "GET",
      url: M,
      dataType: "json",
      error: function (O, Q, N) {
        alert(
          "Unexpected error: Could not read AnalysisLog definition. Please report to info@worldofo.com!"
        );
        return;
      },
      success: function (O) {
        if (O.formdefine) {
          mapviewer.AnalysisLogdef.formdefine = O.formdefine;
          mapviewer.AnalysisLogdef.formdata = O.formdata;
          if (z.editlogmode) {
            var N = null;
            N = dbvals;
            mapviewer.addimg_to_analysislog("", "", "", N);
            $("#analysisLogImgDiv").html(addlogimg);
          }
        } else {
          alert(
            "Unexpected error: Could not read AnalysisLog definition part 2. Please report to info@worldofo.com!"
          );
        }
      },
    });
  };
  this.loadLogNames = function (O) {
    var Q = "";
    var M = "json";
    var R = "";
    var N = true;
    if (window.location.host == "loggator.worldofo.com") {
      Q = "http://3drerun.worldofo.com/2d/";
      R = "&pwd=" + z.pwd + "&uname=" + z.uname;
    } else {
      if (z.editlogmode) {
        Q = "../2d/";
        N = false;
      }
    }
    $.ajax({
      type: "GET",
      url: Q + "loadsavedata.php?loadanalog=1" + R,
      async: N,
      dataType: M,
      error: function (T, U, S) {
        return;
      },
      success: function (S) {
        if (S.lognames) {
          z.AnalysisLogdef.loaded_lognames = S.lognames;
        }
        return;
      },
    });
  };
  this.makeform = function (O, S, W) {
    var V = "";
    for (var X = 0; X < O.length; X++) {
      var T = O[X];
      var M = T.description_input;
      if (z.editlogmode) {
        M = M.replace("Add to Log", "Save changes");
      }
      var N = T.id;
      var Q = T.id_post;
      var U = T.type;
      var R = S[N];
      var Y = "";
      if (U == "select") {
        if (N.match("analysislog_name")) {
          R = "-----   Select an AnalysisLog or define new   -----|" + R;
        } else {
          if (!N.match("multiple")) {
            R = "--------   Keep blank   --------|" + R;
          }
        }
        V += z.printselect(M, N, R, Y, "horlabelwide");
      } else {
        if (U == "text") {
          V += z.printentry(M, N, "text", Y, "horlabelwide");
        } else {
          if (U == "dateselect") {
            if (!R) {
              R = new Date().toString().substr(0, 10);
            }
            V += z.printentry(M, N, "text", R, "horlabelwide");
          } else {
            if (U == "textarea") {
              V += z.printentry(M, N, "textarea", Y, "horlabelwide");
            } else {
              if (U == "html") {
                V += M;
              } else {
                if (U == "startdiv") {
                  V +=
                    "<div id='" +
                    N +
                    "' style='background:#ffff99;border:1px solid #aaa;padding:5px;display:none;margin-bottom:8px;margin-top:3px;'><div style='clear:both;margin-bottom:3px;font-weight:bold;'>" +
                    M +
                    "</div>";
                } else {
                  if (U == "stopdiv") {
                    V += "</div>";
                  }
                }
              }
            }
          }
        }
      }
    }
    return V;
  };
  this.addimg_to_analysislog = function (ah, R, ab, af) {
    if (!af) {
      af = new Array();
    }
    var T = z.AnalysisLogdef.formdefine;
    var X = z.AnalysisLogdef.formdata;
    var M = new Array();
    var V = new Array();
    for (var O = 0; O < z.routes.length; O++) {
      var U = new Date(mapviewer.routes[0].zerotime * 1000)
        .toString()
        .substr(0, 10);
      if (!V[U]) {
        V[U] = 1;
        M.push(U);
      } else {
        V[U]++;
      }
    }
    if (M.length > 0) {
      z.AnalysisLogdef.formdata.analysislog_date = M[0];
    }
    z.AnalysisLogdef.formdata.analysislog_name =
      "New AnalysisLog|My MistakeLog|My GoodPerformanceLog|StuffToRemember";
    if (z.AnalysisLogdef.loaded_lognames) {
      var N =
        z.AnalysisLogdef.formdata.analysislog_name +
        "|" +
        z.AnalysisLogdef.loaded_lognames;
      var Q = N.split(/\|/);
      Q = $.grep(Q, function (aj, ai) {
        return $.inArray(aj, Q) === ai;
      });
      z.AnalysisLogdef.formdata.analysislog_name = Q.join("|");
    }
    z.AnalysisLogdef.img = ah;
    z.AnalysisLogdef.img_blank = R;
    z.AnalysisLogdef.img_alternatives = ab;
    var ad = z.makeform(T, X, null);
    if (z.editlogmode) {
      z.AnalysisLogdef.img = "images/" + af.md5 + ".jpg";
      ah = z.AnalysisLogdef.img;
    }
    if (z.AnalysisLogdef.img) {
      addlogimg = new Image();
      addlogimg.src = ah;
      newh = 350;
      x = addlogimg.width;
      y = addlogimg.height;
      addlogimg.height = newh;
      addlogimg.width = (newh * x) / y;
    }
    var ae = "";
    if (!z.editlogmode) {
      if (z.AnalysisLogdef.img_blank) {
        addlogimg_blank = new Image();
        addlogimg_blank.src = R;
        newh_blank = 100;
        x = addlogimg_blank.width;
        y = addlogimg_blank.height;
        addlogimg_blank.height = newh_blank;
        addlogimg_blank.width = (newh_blank * x) / y;
        ae +=
          '<div id="analysislogimgblankdiv" style="float:left;width:' +
          addlogimg_blank.width +
          ";height:" +
          addlogimg_blank.height +
          '"></div>';
      }
      if (z.AnalysisLogdef.img_alternatives) {
        addlogimg_alternatives = new Image();
        addlogimg_alternatives.src = ab;
        newh_alternatives = 100;
        x = addlogimg_alternatives.width;
        y = addlogimg_alternatives.height;
        addlogimg_alternatives.height = newh_alternatives;
        addlogimg_alternatives.width = (newh_alternatives * x) / y;
        ae +=
          '<div id="analysislogimgalternativesdiv" style="float:left;width:' +
          addlogimg_alternatives.width +
          ";height:" +
          addlogimg_alternatives.height +
          '"></div>';
      }
      if (ae) {
        ae +=
          '<div style="margin-top:8px;margin-bottom:8px;clear:both;"><i><b>Note! Several images are saved but not yet supported in viewer!</b></i></div>';
      }
    }
    if (!z.editlogmode) {
      mapviewer.open_fulldialog(
        "Add entry to AnalysisLog",
        '<for id="analysislogform"><div id="analysisLogImgDiv" style="float:left;width:' +
          addlogimg.width +
          ";height:" +
          addlogimg.height +
          '"></div>' +
          ae +
          '<br><div style="margin-bottom:8px;clear:both;"></div>' +
          ad +
          "</form><br>",
        0
      );
      if (z.AnalysisLogdef.img) {
        $("#analysisLogImgDiv").html(addlogimg);
        if (z.AnalysisLogdef.img_blank) {
          $("#analysislogimgblankdiv").html(addlogimg_blank);
        }
        if (z.AnalysisLogdef.img_alternatives) {
          $("#analysislogimgalternativesdiv").html(addlogimg_alternatives);
        }
      }
    } else {
      if (af.id) {
        if (z.AnalysisLogdef.img) {
          ad =
            '<div id="analysisLogImgDiv" style="width:' +
            addlogimg.width +
            ";height:" +
            addlogimg.height +
            '"></div><br>' +
            ad;
        }
        $("#data").html('<for id="analysislogform"><br>' + ad + "</form><br>");
        if (z.AnalysisLogdef.img) {
          $("#analysisLogImgDiv").html(addlogimg);
          if (addlogimg.width == 0) {
            setTimeout(function () {
              mapviewer.fixwidth(
                $("#analysisLogImgDiv").children("img")[0],
                newh
              );
            }, 600);
          }
        }
      } else {
        $("#data").html(
          "Sorry, something went wrong! Could not load id from the database"
        );
      }
    }
    if (datepickr) {
      datepickr("#analysislog_date", { dateFormat: "Y-m-d" });
    }
    $("#analysislogform").isHappy({
      fields: {
        "#analysislog_entryname": {
          required: true,
          message: "Need AnalysisLog name",
        },
        "#analysislog_runningspeed_pace": {
          test: happy.pace,
          message: "Please use format MM:SS",
        },
      },
      happy: function () {
        mapviewer.addimg_to_analysislog_do(1);
      },
    });
    $("#analysislog_name").bind("change", function (ai, aj) {
      var ak = $("#analysislog_name").val();
      if (ak == "New AnalysisLog") {
        $("#analysislog_newname_div").show();
      } else {
        $("#analysislog_newname_div").hide();
      }
    });
    $("#analysislog_entrytype").bind("change", function (ai, aj) {
      var ak = $("#analysislog_entrytype").val();
      if (ak == "Time loss") {
        $("#analysislog_mistake_div").show();
      } else {
        $("#analysislog_mistake_div").hide();
      }
      if (ak == "Good performance") {
        $("#analysislog_goodperformance_div").show();
      } else {
        $("#analysislog_goodperformance_div").hide();
      }
      if (ak == "Routechoice analysis") {
        $("#analysislog_routechoice_div").show();
      } else {
        $("#analysislog_routechoice_div").hide();
      }
      if (ak == "Running speed analysis") {
        $("#analysislog_runningspeed_div").show();
        if ($("#analysislog_runningspeed_pace").val() == "") {
          $("#analysislog_runningspeed_pace").val(z.findpace());
        }
      } else {
        $("#analysislog_runningspeed_div").hide();
      }
    });
    if (z.editlogmode) {
      var Z = af;
      for (var W = 0; W < T.length; W++) {
        var aa = T[W];
        var ag = aa.description_input;
        var ac = aa.id;
        var S = aa.id_post;
        if (Z[S]) {
          if ($("#" + ac)) {
            $("#" + ac).val(Z[S]);
            $("#" + ac).trigger("change");
          }
        }
      }
    } else {
      if (z.AnalysisLogdef.prevvals.entryname) {
        $("#analysislog_entryname").val(z.AnalysisLogdef.prevvals.entryname);
      } else {
        var Y = mapviewer.map.name;
        if (Y) {
          Y = Y.replace(/\.\w+_\d+/gi, "");
        }
        $("#analysislog_entryname").val(Y);
      }
      if (z.AnalysisLogdef.prevvals.logname) {
        $("#analysislog_name").val(z.AnalysisLogdef.prevvals.logname);
        $("#analysislog_name").trigger("change");
      }
      if (M.length > 0) {
        if (z.AnalysisLogdef.prevvals.entrydate != M[0]) {
          $("#analysislog_date").val(z.AnalysisLogdef.prevvals.entrydate);
        }
      } else {
        if (z.AnalysisLogdef.prevvals.entrydate) {
          $("#analysislog_date").val(z.AnalysisLogdef.prevvals.entrydate);
        }
      }
    }
  };
  this.fixwidth = function (N, O) {
    var M = N.naturalWidth;
    var Q = N.naturalHeight;
    N.width = (O * M) / Q;
  };
  this.addimg_to_analysislog_do = function (S) {
    if (S == 0) {
      $("#analysislogform").submit();
      return;
    }
    var Y = mapviewer.AnalysisLogdef.formdefine;
    var N = mapviewer.AnalysisLogdef.formdata;
    $("#analysislog_saving").show();
    var aa = new Object();
    for (var Q = 0; Q < Y.length; Q++) {
      var W = Y[Q];
      var M = W.description_input;
      var O = W.id;
      var R = W.id_post;
      var X = W.type;
      var Z = "";
      if (
        (X == "select" ||
          X == "text" ||
          X == "textarea" ||
          X == "dateselect") &&
        O != "analysislog_newname"
      ) {
        var S = $("#" + O).val();
        if (O.match(/multiple/) && S) {
          S = S.join("|");
        }
        if (O == "analysislog_name" && S == "New AnalysisLog") {
          S = $("#analysislog_newname").val();
        }
        if (S) {
          if (S.substr(0, 3) == "---") {
            S = "";
          }
        }
        if (S == null) {
          S = "";
        } else {
          S = S.replace(/\n/g, "");
          S = S.replace(/\r/g, "");
          S = S.replace(/"/g, "");
          S = S.replace(/'/g, "");
        }
        aa[R] = S;
      }
    }
    if (!aa.logname) {
      alert("You need to choose an AnalysisLog!");
      $("#analysislog_saving").hide();
      return;
    } else {
      if (!z.editlogmode) {
        aa.img = z.AnalysisLogdef.img;
        if (z.AnalysisLogdef.img_blank) {
          aa.img_blank = z.AnalysisLogdef.img_blank;
        } else {
          aa.img_blank = "";
        }
        if (z.AnalysisLogdef.img_alternatives) {
          aa.img_alternatives = z.AnalysisLogdef.img_alternatives;
        } else {
          aa.img_alternatives = "";
        }
        aa.url = document.URL;
      } else {
        aa.id = dbvals.id;
        aa.img = dbvals.img;
        aa.url_blank = dbvals.url_blank;
        aa.url_alternatives = dbvals.url_alternatives;
        aa.url = dbvals.url;
      }
      this.AnalysisLogdef.prevvals = aa;
      var ab = "json";
      var T = "";
      var U = "";
      var V = "";
      if (window.location.host == "loggator.worldofo.com") {
        T = "http://3drerun.worldofo.com/2d/";
        U = z.pwd;
        V = z.uname;
      }
      if (z.editlogmode) {
        T = "../2d/";
      }
      aa = JSON.stringify(aa);
      $.ajax({
        type: "POST",
        url: T + "loadsavedata.php",
        dataType: ab,
        data: { data: aa, saveanalog: 1, pwd: U, uname: V },
        error: function (ad, ae, ac) {
          z.close_fulldialog();
          z.open_dialog(
            "Unexpexted error",
            "Could not save data! " + ae + " " + ac,
            1
          );
          return;
        },
        success: function (ac) {
          z.close_fulldialog();
          if (ac.status == "OK") {
            if (!z.editlogmode) {
              z.open_dialog(
                "Added to AnalysisLog",
                'See <a target=_blank href="http://3drerun.worldofo.com/analysislog/">all your AnalysisLogs here (opens in new window)</a>',
                1
              );
            } else {
              z.openbaseurl();
            }
          } else {
            z.close_fulldialog();
            z.open_dialog("Error! Could not save data!", ac.status, 1);
          }
        },
      });
    }
  };
  this.deletealltxtonjqplot = function () {
    for (var M = 0; M <= 3; M++) {
      z.settings.graphs[M].graphannotate = new Array();
    }
    z.plotgraphs();
  };
  this.addroutefrombutton = function (M) {
    midid = $("#addroutesselect").val().split("|");
    if (midid[0] != 0) {
      if (M == 0) {
        z.load_3drerunroute_frommd5(midid[0], midid[1], 0);
      } else {
        var N = new Array();
        N.imagelink = midid[2];
        N.quickrouteinfo = midid[3];
        z.load_map_fromdata(N, midid[1]);
      }
    }
  };
  this.addroutefrombutton_info = function () {
    midid = $("#addroutesselect").val().split("|");
    if (midid[0] != 0) {
      var M = z.loadrouteinfo[midid[1]];
      $("#addroutesinfo").html(M);
    }
  };
  this.addroutesfromgpsseuranta = function (M) {
    if (M == 0) {
      $("#addseurantabutton").hide();
      var N = "getseu_events.php";
      $.get(N, function (O) {
        routeinfo = $.parseJSON(O);
        info =
          '<hr><b>Select event</b><br><select onChange="mapviewer.addroutesfromgpsseuranta(1)" id="addroutefromgpsseurantaselect"><option value="0">----------------</option>';
        for (var S = 0; S < routeinfo.events.length; S++) {
          var R = routeinfo.events[S];
          var T = R.id;
          var Q = R.name;
          info += '<option value="' + T + '">' + Q + "</option>";
        }
        info += "</select>";
        info +=
          '<div id="addseurantaroutesinfo" style="font-size:10px;background:yellow;"></div>';
        $("#addseurantadiv").html(info);
      });
    } else {
      $("#addseurantaroutesinfo").html(
        '<img src="loading.gif"><br>Loading ...'
      );
      seurantabaseurl = "http://localhost/ge/localseuranta/";
      seurantaidstr = $("#addroutefromgpsseurantaselect").val();
      mapviewer.loadseu(seurantabaseurl, seurantaidstr);
    }
  };
  this.addroutesfrombutton = function () {
    $("#addroutes").html('<img src="loading.gif">');
    var T;
    var O;
    if (z.map.width != null) {
      var S = mapviewer.map.tolatlng(
        mapviewer.map.width / 2,
        mapviewer.map.height / 2
      );
      T = S.lat;
      O = S.lng;
    }
    if (!T && !O) {
      if (z.routes.length > 0) {
        T = z.routes[0].latarray[0];
        O = z.routes[0].lngarray[0];
      }
    }
    if (T || O) {
      var R = $("#addroutestype").val();
      var Q = $("#addroutestxt").val();
      var N = $("#addroutesdate").val();
      if (N == "any") {
        N = "";
      }
      var M = "";
      if (window.location.host == "localhost") {
        M = "http://localhost/dropbox/gpstrack/geplugin/2d/addroutes.php";
      } else {
        M = "http://3drerun.worldofo.com/2d/addroutes.php";
      }
      $.get(
        M + "?lat=" + T + "&lng=" + O + "&type=" + R + "&s=" + Q + "&date=" + N,
        function (Y) {
          routeinfo = $.parseJSON(Y);
          numall = routeinfo.numroutes;
          var Z = 0;
          if (numall > 0) {
            z.loadrouteinfo = new Array();
            info =
              '<hr><b>Select map/route</b><br><select onChange="mapviewer.addroutefrombutton_info()" id="addroutesselect"><option value="0">----------------</option>';
            for (var ah = 0; ah < routeinfo.routes.length; ah++) {
              var af = routeinfo.routes[ah];
              var V = af.id;
              var X = af.date;
              var ae = af.mid;
              var ac = af.lat;
              var ad = af.lng;
              var ab = parseInt(calcdistance(ac, ad, T, O) / 1000);
              var ag = af.runner;
              var U = af.name;
              var aa = af.course;
              z.loadrouteinfo[V] =
                "Date: " + X + ". Distance: " + ab + " km away. ";
              if (aa) {
                z.loadrouteinfo[V] += "Course: " + aa + ". ";
              }
              if (ab < 20) {
                if (R == "routes") {
                  info +=
                    '<option value="' +
                    ae +
                    "|" +
                    V +
                    '">' +
                    ag +
                    ", " +
                    U +
                    "</option>";
                } else {
                  var W = af.quickrouteinfo;
                  var ai = af.imagelink;
                  info +=
                    '<option value="' +
                    ae +
                    "|" +
                    V +
                    "|" +
                    ai +
                    "|" +
                    W +
                    '">' +
                    ag +
                    ", " +
                    U +
                    "</option>";
                }
                Z++;
              }
            }
            info += "</select>";
            info +=
              '<div id="addroutesinfo" style="font-size:10px;background:yellow;"></div>';
            if (R == "routes") {
              info +=
                '<button onclick="mapviewer.addroutefrombutton(0);">Add route</button>';
            } else {
              info +=
                '<button onclick="mapviewer.addroutefrombutton(1);">Replace map</button>';
            }
          }
          if (Z == 0) {
            $("#addroutes").html("Found no routes");
          } else {
            $("#addroutes").html(info);
          }
        }
      );
    } else {
      alert(
        "Need at least one route or map loaded to find routes/maps in vicinity!"
      );
      $("#addroutes").html("");
    }
  };
  this.togglegraphannotationlayer = function () {
    z = mapviewer;
    var M = parseInt($("#jqtextfront").val());
    for (var N = 0; N <= 3; N++) {
      if (z.settings.graphs[N].acanvas) {
        z.settings.graphs[N].acanvas.style.zIndex = M;
      }
    }
  };
  this.writetxtonjqplot = function (W, Z, Y, R, X, T) {
    if (!z.settings.nowritejqplot) {
      var N = $("#graph-" + (W + 1) + " .jqplot-event-canvas");
      var Q = N.width();
      var M = N.height();
      var O = parseInt(
        $("#graph-" + (W + 1) + " .jqplot-event-canvas").css("top")
      );
      var S = parseInt(
        $("#graph-" + (W + 1) + " .jqplot-event-canvas").css("left")
      );
      var V = Z * Q;
      var U = Y * M;
      mapviewer.settings.graphs[W].acontext.font = T + "px Arial";
      mapviewer.settings.graphs[W].acontext.fillText(R, V, U);
      mapviewer.settings.graphs[W].acontext.strokeText(R, V, U);
    }
  };
  this.lineonjqplot = function (W, Q, X, O, U) {
    var M = $("#graph-" + (W + 1) + " .jqplot-event-canvas");
    var S = M.width();
    var N = M.height();
    var R = parseInt(
      $("#graph-" + (W + 1) + " .jqplot-event-canvas").css("top")
    );
    var T = parseInt(
      $("#graph-" + (W + 1) + " .jqplot-event-canvas").css("left")
    );
    var Q = Q * S;
    var X = X * N;
    var O = O * S;
    var U = U * N;
    var V = mapviewer.settings.graphs[W].acontext;
    V.beginPath();
    V.moveTo(Q, X);
    V.lineTo(O, U);
    V.stroke();
  };
  this.request_redraw = function () {
    this.has_request_redraw = 1;
  };
  this.reset_replaystarttime = function () {
    var M = new Date().getTime();
    this.replaystarttime_localtime_ms = M;
    this.replaystarttime_competitiontime_ms = this.playtime * 1000;
    this.previousdrawstarttime_ms = null;
  };
  this.toggle_rotation = function (M) {
    if (M == 1) {
      var N = z.canvas.rotate_angle;
      z.canvas.context.rotate(-N);
      z.center_drawn_routes();
      z.request_redraw();
    } else {
      if (z.canvas.mouse_rotate) {
        z.canvas.mouse_rotate = 0;
      } else {
        z.canvas.use_rotate = 1;
        z.canvas.mouse_rotate = 1;
      }
    }
    z.updateinfobottomdiv();
  };
  this.redraw = function () {
    if (!m.context) {
      this.canvas.context = this.canvas.canvaselement.getContext("2d");
      this.canvas.canvaselement.width = m.width;
      this.canvas.canvaselement.height = m.height;
    }
    if (isNaN(m.cx) || isNaN(m.cy)) {
      m.cy = 1;
      m.cx = 1;
    }
    var a9;
    var ae;
    if (this.settings.showInfoBelow == "CourseInfo") {
      if ($("#graph-1").length == 0) {
        var bJ = "";
        for (var T = 0; T < z.settings.maxgraphs; T++) {
          bJ +=
            '<div id="graph-' +
            (T + 1) +
            '" style="display:block;border-bottom:1px solid black;"></div>';
        }
        $("#graphholder").html(bJ);
      }
      var aL = 0;
      for (var T = 0; T < z.settings.maxgraphs; T++) {
        var bE = parseInt($("#selectgraph-" + (T + 1)).val());
        if (!z.settings.graphs[T]) {
          z.settings.graphs[T] = new Object();
        }
        z.settings.graphs[T].plottype = bE;
        if (bE == 0) {
          $("#graph-" + (T + 1)).hide();
        } else {
          $("#graph-" + (T + 1)).show();
          aL++;
        }
      }
      if (aL > 0) {
        if (this.showBelowFactor > 0) {
          this.showFractionInfoBelow =
            this.showBelowFactor * (1 - 1 / (aL + 1));
        } else {
          this.showFractionInfoBelow = -this.showBelowFactor;
        }
      } else {
        this.showFractionInfoBelow = 0;
      }
    }
    if (this.settings.showInfoBelow == "Splitsbrowser") {
      this.showFractionInfoBelow = 0.35;
    }
    if (this.settings.showInfoBelow == "Pacecurve") {
      this.showFractionInfoBelow = 0.35;
    }
    if (
      !(
        (z.settings.autoanalysis &&
          z.settings.mode == z.settings.modes.AnalysisMode &&
          z.numsegments > 0) ||
        z.settings.showInfoBelow == "CourseInfo" ||
        z.settings.showInfoBelow == "Pacecurve"
      )
    ) {
      a9 = getBrowserHeight() - 1;
      ae = 0;
    } else {
      if (!this.settings.showInfoBelow) {
        a9 = getBrowserHeight() - 1;
        ae = 0;
      } else {
        if (this.showFractionInfoBelow >= 1) {
          a9 =
            $("#" + o).outerHeight() +
            $("#" + this.menudiv).outerHeight() -
            $("#" + this.menudiv).height();
          ae = getBrowserHeight() - $("#" + o).outerHeight() - 1;
        } else {
          a9 = (1 - this.showFractionInfoBelow) * getBrowserHeight() - 1;
          ae = getBrowserHeight() - a9;
        }
      }
    }
    var aS = getBrowserWidth() - 1;
    var a1;
    if ($("#" + o).is(":visible")) {
      a1 =
        a9 -
        ($("#" + o).outerHeight() +
          $("#" + this.menudiv).outerHeight() -
          $("#" + this.menudiv).height());
    } else {
      a1 = a9;
    }
    var br = getBrowserHeight() - 1;
    var aP =
      getBrowserHeight() -
      1 -
      ($("#" + o).outerHeight() +
        $("#" + this.menudiv).outerHeight() -
        $("#" + this.menudiv).height());
    if (this.settings.isprinting) {
      if (
        Math.floor(this.canvas.width) != Math.floor(aS) ||
        Math.floor(this.canvas.height) != Math.floor(a1)
      ) {
        var aW = mapviewer.canvas.rotate_angle;
        mapviewer.canvas.rotate_angle = 0;
        mapviewer.canvas.context.rotate(aW);
      }
    } else {
      if (
        Math.floor(this.canvas.width) != Math.floor(aS) ||
        Math.floor(this.canvas.height) != Math.floor(a1)
      ) {
        var bt = aS;
        var af = a1;
        this.canvas.width = bt;
        this.canvas.height = af;
        this.canvas.canvaselement.width = bt;
        this.canvas.canvaselement.height = af;
        var aW = mapviewer.canvas.rotate_angle;
        mapviewer.canvas.rotate_angle = 0;
        mapviewer.canvas.context.rotate(aW);
        if (
          this.settings.showInfoBelow == "Splitsbrowser" &&
          z.settings.autoanalysis &&
          z.settings.mode == z.settings.modes.AnalysisMode &&
          z.numsegments > 0
        ) {
          var bt = aS;
          var af = ae;
          var aB = aS - $("#" + mapviewer.menudiv).outerWidth();
          if ($("#splitsbrowser").length == 0) {
            $("#graphholder").html('<canvas id="splitsbrowser"></canvas>');
          }
          $("#splitsbrowser").width(aB);
          $("#splitsbrowser").height(af);
          $("#graphholder").show();
          document.getElementById("splitsbrowser").width = bt;
          document.getElementById("splitsbrowser").height = af;
          z.drawSplitsbrowser();
          bindEvent(
            document.getElementById("splitsbrowser"),
            "click",
            function (bw) {
              x = bw.offsetX || bw.pageX;
              y = bw.offsetY || bw.pageY;
              var bh = 0;
              if (bw.shiftKey) {
                bh = 1;
              }
              if (bw.ctrlKey || bw.metaKey) {
                bh = 2;
              }
              if (bw.altKey) {
                bh = 3;
              }
              if (bw.altKey && bw.shiftKey) {
                bh = 4;
              }
              if (bw.altKey && (bw.ctrlKey || bw.metaKey)) {
                bh = 5;
              }
              z.Splitsbrowseronclick(x, y, bh);
            }
          );
        } else {
          if (this.settings.showInfoBelow == "CourseInfo") {
            $("#" + this.menudiv).height(aP);
            var bt = aS;
            var af = ae;
            var aB = aS - $("#" + mapviewer.menudiv).outerWidth();
            $("#graphholder").height(af);
            for (var T = 0; T < z.settings.maxgraphs; T++) {
              var bE = parseInt($("#selectgraph-" + (T + 1)).val());
              var bs = Math.floor(af / aL);
              if (bE != 0) {
                if (z.printgraph == 1 && T == 0) {
                  $("#graph-" + (T + 1)).height(z.printheight);
                  $("#graph-" + (T + 1)).width(z.printwidth);
                } else {
                  if (z.printgraph == 2 && T == 1) {
                    $("#graph-" + (T + 1)).height(z.printheight);
                    $("#graph-" + (T + 1)).width(z.printwidth);
                  } else {
                    if (this.showFractionInfoBelow == 1) {
                      bs = Math.floor(af / aL);
                    } else {
                      if (this.showFractionInfoBelow == 2) {
                        if (T == 0) {
                          bs = Math.floor(af / aL / 2);
                        } else {
                          bs = Math.floor((af * (1 - 1 / aL / 2)) / (aL - 1));
                        }
                      } else {
                        if (this.showFractionInfoBelow == 3) {
                          if (T == 1) {
                            bs = Math.floor(af / aL / 2);
                          } else {
                            bs = Math.floor((af * (1 - 1 / aL / 2)) / (aL - 1));
                          }
                        }
                      }
                    }
                    $("#graph-" + (T + 1)).height(bs);
                    $("#graph-" + (T + 1)).width(aB);
                  }
                }
              }
            }
            if (aL == 0) {
              $("#graphholder").hide();
            } else {
              $("#graphholder").show();
            }
            if (
              !getURLParameter("noautoreplot") &&
              !z.settings.no_graphreplot_on_resize
            ) {
              z.plotgraphs();
            }
            z.request_redraw();
          } else {
            if (this.settings.showInfoBelow == "Pacecurve") {
              var aS = getBrowserWidth() - 1;
              var bt = aS;
              var af = ae;
              var aB = aS - $("#" + mapviewer.menudiv).outerWidth();
              $("#graphholder").height(af);
              $("#graphholder").width(aB);
            } else {
              $("#graphholder").hide();
              $("#" + this.menudiv).height(a1);
            }
          }
        }
        var bt = aS;
        var af = ae;
        var aB = aS - $("#" + mapviewer.menudiv).width();
        $("#realtimesliderdiv").width(aB);
      }
    }
    if (!this.map.loaded && this.offline) {
      this.canvas.context.fillStyle = "#fff";
      this.canvas.context.fillRect(0, 0, m.width, m.height);
      var aK = parseInt(m.width / 40);
      this.canvas.context.font = aK + "px arial";
      this.canvas.context.fillStyle = "#fff";
      if (xc) {
        if (getURLParameter("gpx")) {
          this.canvas.context.fillText(
            "Starting XCViewer - please wait ...",
            40,
            40
          );
        } else {
          // this.make_dragdrop("Drag GPX-files here to start analysis");
        }
      } else {
        if (courseplanning) {
          if (ismapantcourse) {
            this.make_dragdrop(
              "Drag MapAnt.no file 'mapant-export-[....].png' here"
            );
          } else {
            this.make_dragdrop("1. Drag your map file (JPG/PNG) here to start");
          }
          value = "drawcourse";
          $("#selectmode option[value=" + value + "]").attr(
            "disabled",
            "disabled"
          );
          value = "analyzecourse";
          $("#selectmode option[value=" + value + "]").attr(
            "disabled",
            "disabled"
          );
          value = "savedata";
          $("#selectmode option[value=" + value + "]").attr(
            "disabled",
            "disabled"
          );
        } else {
          if (getURLParameter("gpx")) {
            this.canvas.context.fillText(
              "Starting offline mode - please wait ...",
              40,
              40
            );
          } else {
            // this.make_dragdrop("Drag GPX-files here to start analysis");
          }
        }
      }
      if (getURLParameter("rc") || getURLParameter("loadsession")) {
        loadcourse = -1;
        z.loadRCfromURLParameter();
      }
      if (getURLParameter("coursewithmap")) {
        var aJ = getURLParameter("coursewithmap");
        z.loadcoursewithmap(aJ);
      }
    } else {
      if (!this.map.loaded) {
        this.canvas.context.fillStyle = "#111";
        this.canvas.context.fillRect(0, 0, m.width, m.height);
        var aK = parseInt(m.width / 40);
        this.canvas.context.font = aK + "px arial";
        this.canvas.context.fillStyle = "#fff";
        this.canvas.context.fillText("Loading map - please wait...", 40, 40);
      } else {
        if (this.settings.runningwild && !this.settings.orunningwild.started) {
          if (!globrunningwild) {
            globrunningwild = new Object();
          }
          z.settings.analyzecourse = 0;
          if ($("#" + z.menudiv).css("display") == "block") {
            $("#" + z.canvasid).css("cursor", "crosshair");
            if (isnarrowscreen) {
            } else {
              $("#" + z.infodiv).html(
                "<b>RunningWild! Draw your route - the faster the better!</b>"
              );
            }
            $("#" + z.infodiv).css("background", "#f00");
            $("#" + z.menudiv).css("z-index", -1);
            $("#" + z.menudiv).css("width", 1);
            z.settings.menu_isvisible = 0;
            if (z.routes) {
              for (var T = 0; T < z.routes.length; T++) {
                z.routes[T].show = 0;
              }
            }
            z.request_redraw();
          }
          this.settings.showtagmode = 0;
          this.settings.tagmode = 0;
          this.settings.infotxt = "";
          this.canvas.context.fillStyle = "#55f";
          this.canvas.context.fillRect(
            0,
            0,
            this.canvas.width,
            this.canvas.height
          );
          var aK = parseInt(this.canvas.width / 40);
          this.canvas.context.font = aK + "px arial";
          this.canvas.context.fillStyle = "#00f";
          this.canvas.context.fillText("RunningWild!", aK * 1, aK * 1.2);
          this.canvas.context.fillStyle = "#fff";
          this.canvas.context.fillText(
            "Which route would you choose?",
            aK * 1,
            aK * 2.4
          );
          this.canvas.context.fillText(
            "Choose your route with time pressure!",
            aK * 1,
            aK * 3.4
          );
          this.canvas.context.fillText(
            "Compare with the optimal route afterwards.",
            aK * 1,
            aK * 4.4
          );
          this.canvas.context.fillStyle = "#00f";
          this.canvas.context.fillText(
            "Click mouse to start!",
            aK * 1,
            aK * 6.4
          );
          z.canvas.use_rotate = 1;
          z.canvas.mouse_rotate = 1;
          if (globrunningwild.viewroutes) {
            globrunningwild.viewroutes = 0;
            z.settings.routeopacity = 0.5;
            z.request_redraw();
            z.showrwroutes_direct("");
          }
        } else {
          if (z.center_map_on_runner) {
            if (this.settings.mode == this.settings.modes.ReplayMode) {
              var a4 = z.routes[z.route_to_center];
              var aw = a4.currenttime(z.playtime);
              if (aw < a4.latarray.length && aw > 0) {
                if (
                  aw != z.prev_center_map_ind &&
                  aw < a4.lngarray.length - 3
                ) {
                  z.prev_center_map_ind = aw;
                  ind_int = parseInt(aw);
                  dt = aw - ind_int;
                  if (z.settings.modes.replay_autorotate == 1) {
                    z.canvas.use_rotate = 1;
                    z.canvas.mouse_rotate = 0;
                    var aE = z.canvas.rotate_angle;
                    z.canvas.context.rotate(-aE);
                    var ap = ind_int - z.settings.rotate_averagetime;
                    var am = ind_int + z.settings.rotate_averagetime;
                    if (ap < 0) {
                      ap = 0;
                    }
                    if (am > a4.latarray.length - 1) {
                      am = a4.latarray.length - 1;
                    }
                    var bq = z.map.toxy(a4.latarray[ap], a4.lngarray[ap]);
                    var bo = z.map.toxy(a4.latarray[am], a4.lngarray[am]);
                    var bI = parseFloat(bq.x);
                    var bH = parseFloat(bq.y);
                    var bm = parseFloat(bo.x);
                    var bl = parseFloat(bo.y);
                    var a0 = bm - bI;
                    var aX = bl - bH;
                    var bi = Math.atan2(a0, -aX);
                    if (z.prev_center_map_ind) {
                      aE = z.prev_center_map_angle;
                    }
                    var bv = bi - aE;
                    if (
                      Math.abs(bv) < Math.abs(z.settings.rotate_minanglechange)
                    ) {
                      bi = aE;
                    } else {
                      if (
                        Math.abs(bv) >
                        Math.abs(z.settings.rotate_maxanglechange)
                      ) {
                        bi =
                          aE + Math.sign(bv) * z.settings.rotate_maxanglechange;
                      }
                    }
                    z.canvas.context.rotate(-bi);
                    z.prev_center_map_angle = bi;
                  } else {
                    if (z.settings.modes.replay_autorotate == 2) {
                      z.canvas.use_rotate = 1;
                      z.canvas.mouse_rotate = 0;
                      var aE = z.canvas.rotate_angle;
                      z.canvas.context.rotate(-aE);
                      var N = z.findlegnum(z.route_to_center, ind_int);
                      var aQ = parseInt(N);
                      if (aQ < 0) {
                        aQ = 0;
                      }
                      if (!aQ) {
                        aQ = 0;
                      }
                      if (aQ > z.coursecoords.length - 2) {
                        aQ = z.coursecoords.length - 2;
                      }
                      var X = aQ + 1;
                      var U = z.coursecoords[aQ].split(",");
                      var bI = parseFloat(U[0]);
                      var bH = parseFloat(U[1]);
                      var U = z.coursecoords[X].split(",");
                      var bm = parseFloat(U[0]);
                      var bl = parseFloat(U[1]);
                      var a0 = bm - bI;
                      var aX = bl - bH;
                      var bi = Math.atan2(a0, -aX);
                      if (bi < 3.1415926) {
                        bi = bi + 2 * 3.1415926;
                      }
                      if (bi > 3.1415926) {
                        bi = bi - 2 * 3.1415926;
                      }
                      if (z.prev_center_map_ind) {
                        aE = z.prev_center_map_angle;
                      }
                      if (aE < 3.1415926) {
                        aE = aE + 2 * 3.1415926;
                      }
                      if (aE > 3.1415926) {
                        aE = aE - 2 * 3.1415926;
                      }
                      var bv = bi - aE;
                      var bC = bv;
                      if (bv > 3.1415926) {
                        bv = bv - 2 * 3.1415926;
                      } else {
                        if (bv < -3.1415926) {
                          bv = bv + 2 * 3.1415926;
                        }
                      }
                      if (
                        Math.abs(bv) <
                        Math.abs(z.settings.rotate_minanglechange)
                      ) {
                        bi = aE;
                      } else {
                        if (
                          Math.abs(bv) >
                          Math.abs(z.settings.rotate_maxanglechange)
                        ) {
                          bi =
                            aE +
                            Math.sign(bv) * z.settings.rotate_maxanglechange;
                        }
                      }
                      z.canvas.context.rotate(-bi);
                      z.prev_center_map_angle = bi;
                    }
                  }
                  if (dt > 0) {
                    var bd = interpolate(
                      a4.latarray[ind_int],
                      a4.lngarray[ind_int],
                      a4.latarray[ind_int + 1],
                      a4.lngarray[ind_int + 1],
                      dt
                    );
                    bb = z.map.toxy(bd.xn, bd.yn);
                    al = bb.x;
                    aj = bb.y;
                  } else {
                    var bb = z.map.toxy(
                      a4.latarray[ind_int],
                      a4.lngarray[ind_int]
                    );
                    al = bb.x;
                    aj = bb.y;
                  }
                  z.map_start_x = al;
                  z.map_start_y = aj;
                  z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
                }
              }
            }
          }
          this.canvas.erase_all();
          this.canvas.context.lineCap = "round";
          if (this.settings.makeprettylines) {
            this.canvas.context.shadowBlur = 4;
            this.canvas.context.lineJoin = "round";
          } else {
            this.canvas.context.shadowBlur = 0;
            this.canvas.context.lineJoin = "round";
          }
          if (z.settings.enableprintscreen || courseplanning) {
            this.canvas.context.fillStyle = "#ffffff";
            this.canvas.context.fillRect(
              -m.width * 2,
              -m.height * 2,
              m.width * 4,
              m.height * 4
            );
          }
          var O = this.canvas.width;
          var aV = this.canvas.height;
          var au = this.canvas.cx;
          var ar = this.canvas.cy;
          var aa = this.canvas.zoomfactor;
          var bK = this.map.width;
          var V = this.map.height;
          var an = au - O / 2 / aa;
          var Y = ar - aV / 2 / aa;
          var ak = an + O / aa;
          var W = Y + aV / aa;
          var a2 = 0;
          var at = 0;
          var aY = O;
          var aq = aV;
          var aZ = an < 0;
          var bp = Y < 0;
          var a6 = ak > bK;
          var ac = W > V;
          var bg = aZ ? 0 : an;
          var aT = bp ? 0 : Y;
          var bf = a6 ? bK : ak;
          var aR = ac ? V : W;
          if (aZ) {
            a2 = ((-an * 1) / (ak - an)) * O;
          }
          if (a6) {
            aY = (((bK - an) * 1) / (ak - an)) * O;
          }
          if (bp) {
            at = ((-Y * 1) / (W - Y)) * aV;
          }
          if (ac) {
            aq = (((V - Y) * 1) / (W - Y)) * aV;
          }
          if (!z.canvas.use_rotate) {
            if (!(an > bK - 1 || ak < 1 || Y > V - 1 || W < 1)) {
              this.canvas.drawImage_map(
                this.map.mapobject,
                bg,
                aT,
                bf - bg,
                aR - aT,
                a2,
                at,
                aY - a2,
                aq - at,
                z.settings.mapopacity
              );
            }
          } else {
            if (0) {
              var O = this.canvas.width;
              var aV = this.canvas.height;
              var au = this.canvas.cx;
              var ar = this.canvas.cy;
              var aa = this.canvas.zoomfactor;
              var bK = this.map.width;
              var V = this.map.height;
              var an = au - (2 * O) / 2 / aa;
              var Y = ar - (2 * aV) / 2 / aa;
              var ak = an + (2 * O) / aa;
              var W = Y + (2 * aV) / aa;
              var a2 = -O / 2;
              var at = -aV / 2;
              var aY = (O * 3) / 2;
              var aq = (aV * 3) / 2;
              if (an < 0) {
                bg = 0;
              } else {
                bg = an;
              }
              if (Y < 0) {
                aT = 0;
              } else {
                aT = Y;
              }
              if (ak > bK) {
                bf = bK;
              } else {
                bf = ak;
              }
              if (W > V) {
                aR = V;
              } else {
                aR = W;
              }
              if (an < 0) {
                a2 = -an * aa - O / 2;
              }
              if (ak > bK) {
                aY = (bK - an) * aa - O / 2;
              }
              if (Y < 0) {
                at = -Y * aa - aV / 2;
              }
              if (W > V) {
                aq = (V - Y) * aa - aV / 2;
              }
            } else {
              var aC = O;
              if (aV > aC) {
                aC = aV;
              }
              var O = this.canvas.width;
              var aV = this.canvas.height;
              var bG = 4 * aC;
              var ay = 4 * aC;
              var au = this.canvas.cx;
              var ar = this.canvas.cy;
              var aa = this.canvas.zoomfactor;
              var bK = this.map.width;
              var V = this.map.height;
              var an = au - bG / 2 / aa;
              var Y = ar - ay / 2 / aa;
              var ak = an + bG / aa;
              var W = Y + ay / aa;
              var a2 = -bG / 2 + O / 2;
              var at = -ay / 2 + aV / 2;
              var aY = bG / 2 + O / 2;
              var aq = ay / 2 + aV / 2;
              if (an < 0) {
                bg = 0;
              } else {
                bg = an;
              }
              if (Y < 0) {
                aT = 0;
              } else {
                aT = Y;
              }
              if (ak > bK) {
                bf = bK;
              } else {
                bf = ak;
              }
              if (W > V) {
                aR = V;
              } else {
                aR = W;
              }
              if (an < 0) {
                a2 = -an * aa - (bG / 2 - O / 2);
              }
              if (ak > bK) {
                aY = (bK - an) * aa - (bG / 2 - O / 2);
              }
              if (Y < 0) {
                at = -Y * aa - (ay / 2 - aV / 2);
              }
              if (W > V) {
                aq = (V - Y) * aa - (ay / 2 - aV / 2);
              }
            }
            this.canvas.drawImage_map(
              this.map.mapobject,
              bg,
              aT,
              bf - bg,
              aR - aT,
              a2,
              at,
              aY - a2,
              aq - at,
              z.settings.mapopacity
            );
          }
          var aM = 1;
          if (m.PanInProgress && this.showrouteswhilepanning == 0) {
            aM = 0;
          }
          if (z.settings.isprinting_blank) {
            aM = 0;
          }
          if (z.settings.runningwild) {
            z.settings.showcoursecontrolnumbers = 0;
            if (!z.settings.orunningwild.finished) {
              var bA = new Date().getTime();
              var R = bA - z.settings.orunningwild.previousdraw;
              z.settings.orunningwild.previousdraw = bA;
              var be = 0;
              var ax = z.settings.orunningwild.x;
              var av = z.settings.orunningwild.y;
              if (z.settings.orunningwild.futurepoints.length > 0) {
                if (
                  z.settings.orunningwild.futurepoints.length >
                  z.settings.orunningwild.maxfuturepointsbeforeeat
                ) {
                  var M = z.settings.orunningwild.futurepoints.shift(1);
                  var aF = M.split(",");
                  var al = Math.floor(aF[0]);
                  var aj = Math.floor(aF[1]);
                  z.settings.orunningwild.x = al;
                  z.settings.orunningwild.y = aj;
                  z.settings.orunningwild.linestr +=
                    z.settings.orunningwild.x +
                    "," +
                    z.settings.orunningwild.y +
                    " ";
                  z.settings.orunningwild.prevdistpoint = 1e99;
                  be = 1;
                } else {
                  var aF = z.settings.orunningwild.futurepoints[0].split(",");
                  var al = aF[0];
                  var aj = aF[1];
                  var aA =
                    (al - z.settings.orunningwild.x) *
                      (al - z.settings.orunningwild.x) +
                    (aj - z.settings.orunningwild.y) *
                      (aj - z.settings.orunningwild.y);
                  if (aA > z.settings.orunningwild.prevdistpoint || aA < 1) {
                    z.settings.orunningwild.futurepoints.shift(1);
                    z.settings.orunningwild.prevdistpoint = 1e99;
                    be = 1;
                    if (0) {
                      if (
                        z.settings.orunningwild.futurepoints.length ==
                        z.settings.orunningwild.maxfuturepoints - 1
                      ) {
                        $("#" + z.canvasid).css("cursor", "crosshair");
                      }
                      if (z.settings.orunningwild.futurepoints.length == 0) {
                        $("#" + z.canvasid).css("cursor", "progress");
                      }
                    }
                  } else {
                    z.settings.orunningwild.prevdistpoint = aA;
                  }
                }
              }
              if (z.settings.orunningwild.futurepoints.length == 0) {
                z.settings.orunningwild.angle = null;
              } else {
                if (be || z.settings.orunningwild.angle == null) {
                  prevx = z.settings.orunningwild.x;
                  prevy = z.settings.orunningwild.y;
                  var aF = z.settings.orunningwild.futurepoints[0].split(",");
                  var al = aF[0];
                  var aj = aF[1];
                  dx = al - prevx;
                  dy = aj - prevy;
                  ddy = -dy;
                  if (dy != 0) {
                    ai = Math.abs(dx / dy);
                  } else {
                    ai = 1e99;
                  }
                  organgle = (Math.atan(ai) * 180) / 3.1415926;
                  if (dx >= 0 && ddy >= 0) {
                    addangle = 0;
                  } else {
                    if (dx >= 0 && ddy < 0) {
                      addangle = 180;
                      organgle = -organgle;
                    } else {
                      if (dx < 0 && ddy < 0) {
                        addangle = 180;
                      } else {
                        if (dx < 0 && ddy > 0) {
                          addangle = 0;
                          organgle = -organgle;
                        } else {
                          addangle = 0;
                        }
                      }
                    }
                  }
                  z.settings.orunningwild.angle = organgle + addangle;
                }
              }
              if (z.settings.orunningwild.futurepoints.length > 0) {
                var bD = (R / 1000) * z.settings.orunningwild.speed * 10;
                z.settings.orunningwild.x =
                  z.settings.orunningwild.x +
                  bD *
                    Math.sin((z.settings.orunningwild.angle / 180) * 3.1415926);
                z.settings.orunningwild.y =
                  z.settings.orunningwild.y -
                  bD *
                    Math.cos((z.settings.orunningwild.angle / 180) * 3.1415926);
              } else {
                if (this.settings.orunningwild.maxfuturepointsbeforeeat > 0) {
                  z.settings.orunningwild.overtime += R / 1000;
                }
              }
              var bn =
                " " +
                Math.floor((bA - z.settings.orunningwild.starttime) / 10) / 100;
              while (bn.length < 7) {
                bn += "0";
              }
              var bB =
                " " + Math.floor(z.settings.orunningwild.overtime * 100) / 100;
              while (bB.length < 7) {
                bB += "0";
              }
              $("#" + z.infodiv).html(
                "<center><b>Time: " +
                  bn +
                  " s. Penalty time: " +
                  bB +
                  " s</b></center>"
              );
              z.canvas.setLineStyle("0000ff", 1, 4);
              var bj =
                z.settings.orunningwild.x +
                "," +
                z.settings.orunningwild.y +
                " ";
              for (
                var Q = 0;
                Q < z.settings.orunningwild.futurepoints.length;
                Q++
              ) {
                var aF = z.settings.orunningwild.futurepoints[Q].split(",");
                var al = aF[0];
                var aj = aF[1];
                if (z.settings.orunningwild.drawfuturecircles) {
                  z.canvas.drawCircle(al, aj, 4);
                }
                bj += al + "," + aj + " ";
                ax = al;
                av = aj;
              }
              if (z.settings.orunningwild.futurepoints.length > 0) {
                z.canvas.setLineStyle("0000ff", 0.7, 8);
                m.drawPoly(bj);
                paccol = "005500";
              } else {
                paccol = "880000";
              }
              z.canvas.setLineStyle("ff0000", 0.5, 10);
              if (bA - z.settings.orunningwild.previousline >= 500) {
                z.settings.orunningwild.linestr +=
                  z.settings.orunningwild.x +
                  "," +
                  z.settings.orunningwild.y +
                  " ";
                m.drawPoly(z.settings.orunningwild.linestr);
                z.settings.orunningwild.previousline = bA;
              } else {
                var bF =
                  z.settings.orunningwild.linestr +
                  z.settings.orunningwild.x +
                  "," +
                  z.settings.orunningwild.y +
                  " ";
                m.drawPoly(bF);
              }
              z.canvas.setLineStyle(paccol, 1, 8);
              if (globrunningwild.usePac) {
                z.settings.orunningwild.usePac = 1;
              } else {
                z.settings.orunningwild.usePac = 0;
              }
              if (!z.settings.orunningwild.showcourse) {
                z.settings.showcourse = 0;
              }
              if (z.settings.orunningwild.usePac) {
                z.canvas.setLineStyle(paccol, 1, 12);
                z.canvas.drawPac(
                  z.settings.orunningwild.x,
                  z.settings.orunningwild.y,
                  10,
                  z.settings.orunningwild.angle
                );
              } else {
                z.canvas.drawCircle(
                  z.settings.orunningwild.x,
                  z.settings.orunningwild.y,
                  6
                );
              }
              if (z.settings.orunningwild.currentcontrol > 0) {
                if (
                  z.settings.orunningwild.currentcontrol < z.coursecoords.length
                ) {
                  var U =
                    z.coursecoords[
                      z.settings.orunningwild.currentcontrol
                    ].split(",");
                  var bk = parseFloat(U[0]);
                  var by = parseFloat(U[1]);
                  var ag = ax;
                  var ad = av;
                  var ai = Math.sqrt(
                    (ag - bk) * (ag - bk) + (ad - by) * (ad - by)
                  );
                  if (!z.settings.orunningwild.controlpointpixels) {
                    z.settings.orunningwild.controlpointpixels = 15;
                  }
                  if (!z.settings.orunningwild.splits) {
                    z.settings.orunningwild.splits = new Array();
                  }
                  if (ai <= z.settings.orunningwild.controlpointpixels) {
                    z.settings.orunningwild.futurepoints.push(bk + "," + by);
                    z.settings.orunningwild.allpoints.push(bk + "," + by);
                    z.settings.orunningwild.splits[
                      z.settings.orunningwild.currentcontrol
                    ] = z.settings.orunningwild.allpoints.length;
                    z.settings.orunningwild.currentcontrol++;
                    if (
                      z.settings.orunningwild.currentcontrol >=
                      z.coursecoords.length
                    ) {
                      z.runningwild_finished();
                    } else {
                      if (z.settings.orunningwild.autorotate) {
                        z.centerleg(
                          z.settings.orunningwild.currentcontrol - 1,
                          0.3
                        );
                      } else {
                        z.move_mapxy_to_center(bk, by);
                      }
                    }
                  }
                } else {
                  z.runningwild_finished();
                }
              }
              if (z.settings.orunningwild.center) {
                z.map_start_x = z.settings.orunningwild.x;
                z.map_start_y = z.settings.orunningwild.y;
                z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
              }
            } else {
              if (z.settings.orunningwild.diffroutes) {
                z.canvas.setLineStyle("0000ff", 0.6, 10);
                for (
                  var ab = 0;
                  ab <
                  z.settings.orunningwild.diffroutes.corr_diffroutes.length;
                  ab++
                ) {
                  m.drawPoly(
                    z.settings.orunningwild.diffroutes.corr_diffroutes[ab]
                  );
                }
                z.canvas.setLineStyle("0000ff", 0.8, 2);
                for (
                  var ab = 0;
                  ab <
                  z.settings.orunningwild.diffroutes.corr_sameroutes.length;
                  ab++
                ) {
                  m.drawPoly(
                    z.settings.orunningwild.diffroutes.corr_sameroutes[ab]
                  );
                }
                z.canvas.setLineStyle("ff0000", 0.6, 10);
                for (
                  var ab = 0;
                  ab <
                  z.settings.orunningwild.diffroutes.this_diffroutes.length;
                  ab++
                ) {
                  m.drawPoly(
                    z.settings.orunningwild.diffroutes.this_diffroutes[ab]
                  );
                }
                z.canvas.setLineStyle("ff000000", 0.8, 2);
                for (
                  var ab = 0;
                  ab <
                  z.settings.orunningwild.diffroutes.this_sameroutes.length;
                  ab++
                ) {
                  m.drawPoly(
                    z.settings.orunningwild.diffroutes.this_sameroutes[ab]
                  );
                }
              } else {
                if (z.settings.orunningwild.variants) {
                  for (
                    var T = 0;
                    T < z.settings.orunningwild.variants.length;
                    T++
                  ) {
                    if (z.settings.orunningwild.variants[T].show == 1) {
                      var a4 =
                        z.settings.orunningwild.rwroutes[
                          z.settings.orunningwild.variants[T].members[0]
                        ];
                      z.canvas.setLineStyle(
                        z.linecolors[T],
                        z.settings.routeopacity,
                        z.settings.routewidth
                      );
                      z.canvas.drawPoly(a4.drawpoints);
                    } else {
                      if (z.settings.orunningwild.variants[T].show == 2) {
                        for (
                          var ah = 0;
                          ah <
                          z.settings.orunningwild.variants[T].members.length;
                          ah++
                        ) {
                          var a4 =
                            z.settings.orunningwild.rwroutes[
                              z.settings.orunningwild.variants[T].members[ah]
                            ];
                          z.canvas.setLineStyle(
                            z.linecolors[T],
                            z.settings.routeopacity,
                            z.settings.routewidth
                          );
                          z.canvas.drawPoly(a4.drawpoints);
                        }
                      }
                    }
                  }
                } else {
                  if (
                    z.settings.orunningwild.ideal_lat &&
                    z.settings.orunningwild.ideal_show
                  ) {
                    z.draw_latlngline(
                      z.settings.orunningwild.ideal_lat,
                      z.settings.orunningwild.ideal_lng,
                      z.settings.orunningwild.ideal_startpos,
                      z.settings.orunningwild.ideal_endpos,
                      z.settings.orunningwild.ideal_color
                    );
                  }
                  if (z.settings.orunningwild.rwroutes) {
                    for (
                      var T = 0;
                      T < z.settings.orunningwild.rwroutes.length;
                      T++
                    ) {
                      if (z.settings.orunningwild.rwroutes[T].show) {
                        var a4 = z.settings.orunningwild.rwroutes[T];
                        z.canvas.setLineStyle(
                          a4.color,
                          z.settings.routeopacity,
                          z.settings.routewidth
                        );
                        z.canvas.drawPoly(a4.drawpoints);
                      }
                    }
                  }
                }
              }
            }
          }
          if (z.settings.shownorthlines) {
            z.canvas.drawNorthLines();
          }
          if (
            z.settings.mode == z.settings.modes.DrawCourseMode ||
            z.settings.analyzecourse == 1 ||
            z.settings.orunningwild.showcourse ||
            z.settings.alwaysshowcourse ||
            z.settings.showcourse ||
            z.settings.mode == z.settings.modes.SaveDataMode ||
            z.settings.mode == z.settings.modes.AddRoutesMode
          ) {
            if (
              z.settings.showcourse ||
              z.settings.mode == z.settings.modes.SaveDataMode ||
              z.settings.mode == z.settings.modes.AddRoutesMode ||
              z.settings.mode == z.settings.modes.DrawCourseMode
            ) {
              if (!z.settings.hidecourse) {
                this.drawcourse();
              }
            }
          }
          if (aM) {
            if (
              (this.settings.mode == this.settings.modes.GraphMode) &
              (z.courseinfo.coursetype != "o")
            ) {
              if (1) {
                if (this.settings.showcoursepointnumber) {
                  this.WriteCoursePointNumber();
                }
              }
            } else {
              if (
                this.settings.autoanalysis &&
                z.settings.mode == z.settings.modes.AnalysisMode &&
                this.numsegments > 0
              ) {
                this.DrawAutOanalysis();
              } else {
                if (
                  this.settings.detailedanalysis &&
                  z.settings.mode == z.settings.modes.DetailedMode
                ) {
                  this.DrawDetailedanalysis();
                } else {
                  if (
                    z.settings.mode == z.settings.modes.AnalysisMode &&
                    z.settings.definecourse == 1 &&
                    z.settings.coursedefinition_mode >= 1 &&
                    z.settings.coursedefinition_mode <= 2
                  ) {
                    z.compare_route_to_course();
                  } else {
                    if (z.settings.draw_selected_routeparts) {
                      z.draw_selected_routeparts();
                    } else {
                      this.drawroutes();
                    }
                  }
                }
              }
            }
            if (z.settings.showprintbox) {
              z.canvas.drawXimage();
              z.canvas.drawPrintBox();
            }
            if (
              z.settings.showtagmode &&
              z.settings.mode != z.settings.modes.DrawCourseMode &&
              z.settings.mode != z.settings.modes.AddRoutesMode &&
              z.settings.mode != z.settings.modes.SaveDataMode
            ) {
              var aI = new Array();
              for (var T = 0; T < z.routes.length; T++) {
                aI[z.routes[T].md5] = T;
              }
              for (var T = 0; T < z.tags.length; T++) {
                var Z = z.tags[T];
                if (Z.type == "route") {
                  if (Z == z.currenttag) {
                  } else {
                    if (Z.show && Z.pointsxy.length > 0) {
                      var bx = Z.pointsxy;
                      var ao = "";
                      for (var aO = 0; aO < bx.length; aO++) {
                        ao = ao + bx[aO] + " ";
                      }
                      z.canvas.setLineStyle(
                        Z.color,
                        z.settings.routeopacity,
                        z.settings.routewidth
                      );
                      z.canvas.drawPoly(ao);
                      var bb = bx[Math.floor(bx.length / 2)];
                      var bz = bb.split(",");
                      var a7 = bz[0];
                      var a5 = bz[1];
                      var bu = "";
                      if (z.settings.tagging_timealt == 3) {
                        var aH = Z.angle;
                        z.canvas.writeTextOutlined(
                          parseInt(a7) + 15 + Z.offsettxt_x,
                          parseInt(a5) + Z.offsettxt_y,
                          Z.color,
                          Z.name,
                          null,
                          null,
                          aH
                        );
                      } else {
                        if (z.settings.tagging_timealt == 4) {
                          var aH = Z.angle;
                          if (Z.name == "A") {
                            z.canvas.writeTextOutlined(
                              parseInt(a7) + 15 + Z.offsettxt_x,
                              parseInt(a5) + Z.offsettxt_y,
                              Z.color,
                              Z.name +
                                " (" +
                                parseInt(Z.length) +
                                " m" +
                                bu +
                                ")",
                              null,
                              null,
                              aH
                            );
                          } else {
                            z.canvas.writeTextOutlined(
                              parseInt(a7) + 15 + Z.offsettxt_x,
                              parseInt(a5) + Z.offsettxt_y,
                              Z.color,
                              Z.name,
                              null,
                              null,
                              aH
                            );
                          }
                        } else {
                          if (z.settings.tagging_timealt) {
                            bu = " / " + Z.totalup + " m up";
                          }
                          var aH = Z.angle;
                          z.canvas.writeTextOutlined(
                            parseInt(a7) + 15 + Z.offsettxt_x,
                            parseInt(a5) + Z.offsettxt_y,
                            Z.color,
                            Z.name +
                              " (" +
                              parseInt(Z.length) +
                              " m" +
                              bu +
                              ")",
                            null,
                            null,
                            aH
                          );
                        }
                      }
                    }
                  }
                } else {
                  if (Z.type == "deleted") {
                  } else {
                    var S = Z.md5;
                    var bL = aI[S];
                    if (z.routes[bL].show) {
                      var a3 =
                        z.routes[bL].currenttime(z.playtime) -
                        z.routes[bL].taillength;
                      var bc = z.routes[bL].currenttime(z.playtime);
                      if (Z.ind >= a3 && Z.ind <= bc) {
                        z.canvas.setLineStyle(
                          z.routes[bL].color,
                          z.settings.routeopacity,
                          6
                        );
                        z.canvas.drawCircle(Z.x, Z.y, 6);
                        z.canvas.setLineStyle(
                          "000000",
                          z.settings.routeopacity,
                          5
                        );
                        z.canvas.drawCircle(Z.x, Z.y, 4);
                        al = Z.x + 10;
                        aj = Z.y;
                        if (Z.type == "segment" && Z.tox) {
                          z.canvas.drawLine(Z.x, Z.y, Z.tox, Z.toy);
                          z.canvas.setLineStyle(
                            z.routes[bL].color,
                            z.settings.routeopacity,
                            6
                          );
                          z.canvas.drawCircle(Z.tox, Z.toy, 6);
                          z.canvas.setLineStyle(
                            "000000",
                            z.settings.routeopacity,
                            5
                          );
                          z.canvas.drawCircle(Z.tox, Z.toy, 4);
                          al = (Z.x + Z.tox) / 2 + 10;
                          aj = (Z.y + Z.toy) / 2;
                        }
                        var aN = z.canvas.outlinetxtsize;
                        z.canvas.outlinetxtsize = 14;
                        z.canvas.setLineStyle(
                          z.routes[bL].color,
                          z.settings.routeopacity,
                          6
                        );
                        var aH = Z.angle;
                        z.canvas.writeTextOutlined(
                          al,
                          aj,
                          this.routes[bL].color,
                          Z.name + " (" + Z.timeinfo + ")",
                          null,
                          null,
                          aH
                        );
                        z.canvas.outlinetxtsize = aN;
                      }
                    }
                  }
                }
              }
            }
            if (this.currenttag) {
              if (this.currenttag.type == "route") {
                var bx = this.currenttag.pointsxy;
                var ao = "";
                for (var aO = 0; aO < bx.length; aO++) {
                  ao = ao + bx[aO] + " ";
                }
                z.canvas.setLineStyle("ff0000", z.settings.routeopacity, 4);
                z.canvas.drawPolyCircle(ao);
                z.canvas.drawCircle(this.currenttag.x, this.currenttag.y, 5);
                altdifffield = "";
                if (z.settings.tagging_timealt == 1) {
                  altdifffield =
                    " / " +
                    this.currenttag.totalup +
                    " m up (" +
                    this.currenttag.currentalt +
                    ")";
                } else {
                  if (z.settings.tagging_timealt == 2) {
                    altdifffield =
                      " / " +
                      tominsec(this.currenttag.currenttime) +
                      "  (-> " +
                      tominsec(
                        this.currenttag.currenttime + this.currenttime_delta
                      ) +
                      ")";
                  }
                }
                var Z = this.currenttag;
                var aH = Z.angle;
                z.canvas.writeTextOutlined(
                  this.currenttag.x + Z.offsettxt_x,
                  this.currenttag.y + Z.offsettxt_y,
                  "ff0000",
                  parseInt(this.currenttag.length) + " m" + altdifffield,
                  null,
                  null,
                  aH
                );
                if (
                  !this.currenttag.opened_dialog &&
                  this.currenttag.ready_for_dialog == 1
                ) {
                  if (courseplanning) {
                    this.currenttag.opened_dialog = 0;
                    this.currenttag.ready_for_dialog = 0;
                    z.addrouteTag(1);
                  } else {
                    z.open_dialog("routetag");
                    this.currenttag.opened_dialog = 0;
                    this.currenttag.ready_for_dialog = 0;
                  }
                }
              } else {
                if (this.currenttag.type == "deleted") {
                } else {
                  z.canvas.drawCircle(this.currenttag.x, this.currenttag.y, 10);
                  if (
                    this.currenttag.type == "segment" &&
                    this.currenttag.tox
                  ) {
                    z.canvas.drawCircle(
                      this.currenttag.tox,
                      this.currenttag.toy,
                      10
                    );
                  }
                  if (
                    !this.currenttag.opened_dialog &&
                    this.currenttag.ready_for_dialog == 1
                  ) {
                    z.open_dialog("tag", this.currenttag.runnername);
                    this.currenttag.opened_dialog = 1;
                  }
                }
              }
            }
          }
          if (z.settings.calibrationmode) {
            this.showcalibrationpoints();
          }
          if (z.visualize_point) {
            z.canvas.setLineStyle("000000", 1, 8);
            z.canvas.drawCircle(
              z.visualize_point.x,
              z.visualize_point.y,
              8 / z.canvas.zoomfactor
            );
          }
          if (z.specialized_drawfunction) {
            z.specialized_drawfunction();
          }
          if (z.settings.modifyroutes) {
            for (var T = 0; T < z.routes.length; T++) {
              var a4 = z.routes[T];
              if (a4.show && a4.modifyroute_stablepoints) {
                for (
                  var ah = 0;
                  ah < a4.modifyroute_stablepoints.length;
                  ah++
                ) {
                  var ba = a4.modifyroute_stablepoints[ah];
                  var aD = z.map.toxy(ba.P.lat, ba.P.lng);
                  z.canvas.drawCircle(aD.x, aD.y, 8 / z.canvas.zoomfactor);
                }
              }
            }
          }
          if (
            (this.IsLive || this.realtime) &&
            z.settings.mode == z.settings.modes.ReplayMode
          ) {
            z.canvas.context.strokeStyle = "rgba(255,0,0,1)";
            z.canvas.context.fillStyle = "rgba(255,0,0,1)";
            if (this.realtime) {
              z.canvas.writeTextabs(
                "RealTime " + new Date(z.playtime * 1000).toString(),
                50,
                50
              );
            } else {
              z.canvas.writeTextabs(
                "LIVE " + new Date(z.playtime * 1000).toString(),
                50,
                50
              );
            }
          }
          if (z.settings.colormode != z.settings.modes.colorbyorg) {
            if (z.settings.colormode == z.settings.modes.colorbypace) {
              var aU = mapviewer.settings.pacecoloring.minpace;
              var az = mapviewer.settings.pacecoloring.maxpace;
              if (
                z.settings.pacecoloring.type <= 4 ||
                z.settings.pacecoloring.type == 6
              ) {
                if (z.settings.lastcolorlegendmaxwidth > 0) {
                  x0 =
                    z.canvas.width / 2 - z.settings.lastcolorlegendmaxwidth / 2;
                  z.canvas.use_translated_coordinates = 0;
                  z.canvas.drawWhiteBackgroundBox(
                    x0 - 15,
                    0,
                    z.settings.lastcolorlegendmaxwidth + 30,
                    this.canvas.outlinetxtsize * 2,
                    0.6
                  );
                  z.canvas.use_translated_coordinates = 1;
                } else {
                  x0 = 10;
                }
                y0 = 10;
                h = this.canvas.outlinetxtsize;
                w = h * 1.5;
              }
              if (
                z.settings.pacecoloring.type == 0 ||
                z.settings.pacecoloring.type == 1 ||
                z.settings.pacecoloring.type == 6
              ) {
                var aG = new Array(
                  "008000",
                  "40A000",
                  "80C000",
                  "C0E000",
                  "FFFF00",
                  "FFC000",
                  "FF8000",
                  "FF4000",
                  "FF0000"
                );
                z.canvas.use_translated_coordinates = 0;
                xb = x0;
                yb = y0;
                xt = xb + w * 1.5;
                yt = yb + this.canvas.outlinetxtsize;
                this.canvas.drawColorBox(xb, yb, w, h, aG[0]);
                var a8;
                if (z.settings.pacecoloring.type == 6) {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    parseInt(aU * 10) / 10
                  );
                } else {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    tominsec(aU * 60)
                  );
                }
                xb = xt + a8 + w * 2;
                yb = y0;
                xt = xb + w * 1.5;
                yt = yb + this.canvas.outlinetxtsize;
                this.canvas.drawColorBox(
                  xb,
                  yb,
                  w,
                  h,
                  aG[Math.floor(aG.length / 2)]
                );
                if (z.settings.pacecoloring.type == 6) {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    parseInt(((aU + (az - aU) * 0.5) * 10) / 10)
                  );
                } else {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    tominsec(
                      (aU +
                        ((az - aU) * Math.floor(aG.length / 2)) / aG.length) *
                        60
                    )
                  );
                }
                xb = xt + a8 + w * 2;
                yb = y0;
                xt = xb + w * 1.5;
                yt = yb + this.canvas.outlinetxtsize;
                this.canvas.drawColorBox(xb, yb, w, h, aG[aG.length - 1]);
                if (z.settings.pacecoloring.type == 6) {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    parseInt(az * 10) / 10
                  );
                } else {
                  a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    tominsec(az * 60)
                  );
                }
                z.canvas.use_translated_coordinates = 1;
                z.settings.lastcolorlegendmaxwidth = xt + a8 - x0;
              } else {
                if (z.settings.pacecoloring.type == 2) {
                  z.canvas.use_translated_coordinates = 0;
                  xb = x0;
                  yb = y0;
                  xt = xb + w * 1.5;
                  yt = yb + this.canvas.outlinetxtsize;
                  this.canvas.drawColorBox(xb, yb, w, h, "880000");
                  var a8 = z.canvas.writeTextOutlined(
                    xt,
                    yt,
                    "000000",
                    "Thick line for pace outside " +
                      tominsec(aU * 60) +
                      " and " +
                      tominsec(az * 60)
                  );
                  z.canvas.use_translated_coordinates = 1;
                  z.settings.lastcolorlegendmaxwidth = xt + a8 - x0;
                } else {
                  if (z.settings.pacecoloring.type == 4) {
                    z.canvas.use_translated_coordinates = 0;
                    xb = x0;
                    yb = y0;
                    xt = xb + w * 1.5;
                    yt = yb + this.canvas.outlinetxtsize;
                    this.canvas.drawColorBox(xb, yb, w, h, "880000");
                    var a8 = z.canvas.writeTextOutlined(
                      xt,
                      yt,
                      "000000",
                      "Thick line for pace between " +
                        tominsec(aU * 60) +
                        " and " +
                        tominsec(az * 60)
                    );
                    z.canvas.use_translated_coordinates = 1;
                    z.settings.lastcolorlegendmaxwidth = xt + a8 - x0;
                  } else {
                    if (z.settings.pacecoloring.type == 3) {
                      var aG = new Array("00b400", "ffb400", "ff0000");
                      z.canvas.use_translated_coordinates = 0;
                      xb = x0;
                      yb = y0;
                      xt = xb + w * 1.5;
                      yt = yb + this.canvas.outlinetxtsize;
                      this.canvas.drawColorBox(xb, yb, w, h, aG[0]);
                      var a8 = z.canvas.writeTextOutlined(
                        xt,
                        yt,
                        "000000",
                        "Pace < " + tominsec(aU * 60)
                      );
                      xb = xt + a8 + w * 2;
                      yb = y0;
                      xt = xb + w * 1.5;
                      yt = yb + this.canvas.outlinetxtsize;
                      this.canvas.drawColorBox(
                        xb,
                        yb,
                        w,
                        h,
                        aG[Math.floor(aG.length / 2)]
                      );
                      var a8 = z.canvas.writeTextOutlined(
                        xt,
                        yt,
                        "000000",
                        "Pace between " +
                          tominsec(aU * 60) +
                          " and " +
                          tominsec(az * 60)
                      );
                      xb = xt + a8 + w * 2;
                      yb = y0;
                      xt = xb + w * 1.5;
                      yt = yb + this.canvas.outlinetxtsize;
                      this.canvas.drawColorBox(xb, yb, w, h, aG[aG.length - 1]);
                      var a8 = z.canvas.writeTextOutlined(
                        xt,
                        yt,
                        "000000",
                        "Pace > " + tominsec(az * 60)
                      );
                      z.canvas.use_translated_coordinates = 1;
                      z.settings.lastcolorlegendmaxwidth = xt + a8 - x0;
                    }
                  }
                }
              }
            }
          }
          if (z.settings.infotxt) {
            z.canvas.use_translated_coordinates = 0;
            this.canvas.writeTextOutlined(
              10,
              this.canvas.outlinetxtsize * 1.1,
              "005500",
              z.settings.infotxt
            );
            z.canvas.use_translated_coordinates = 1;
          }
        }
      }
    }
    if (z.is_save_animation) {
      z.capturer.capture(z.canvas.canvaselement);
      z.numframe_save_animation++;
      if (z.numframe_save_animation > z.settings.savevideo.maxframes) {
        z.stop_save_animation();
      }
    }
  };
  this.start_save_animation = function () {
    if (z.settings.savevideo.format == 0) {
      z.capturer = new CCapture({
        format: "gif",
        workersPath: "js/",
        framerate: z.settings.savevideo.framespersec,
      });
    } else {
      z.capturer = new CCapture({
        format: "webm",
        framerate: z.settings.savevideo.framespersec,
      });
    }
    z.capturer.start();
    z.is_save_animation = 1;
    z.last_save_animation = 0;
    z.numframe_save_animation = 0;
    z.play_speed = parseInt(
      (z.settings.savevideo.speed * 25) / z.settings.savevideo.framespersec
    );
    if (isNaN(z.play_speed)) {
      z.play_speed = 10;
    }
    z.reset_replaystarttime();
  };
  this.stop_save_animation = function () {
    z.is_save_animation = 0;
    z.capturer.stop();
    z.play_speed = parseInt($("#playspeedr").val());
    if (isNaN(z.play_speed)) {
      z.play_speed = 10;
    }
    z.capturer.save(function (N) {
      var M = document.createElement("a");
      M.text = "Download last animation";
      if (z.settings.savevideo.format == 0) {
        M.download = "animation.gif";
      } else {
        M.download = "animation.webm";
      }
      M.href = N;
      z.settings.savevideo.a = M;
      M.click();
    });
  };
  this.make_dragdrop = function (O) {
    this.canvas.setLineStyle("222222", 0.8, 3);
    this.canvas.context.setLineDash([4]);
    var R = 20;
    var N = this.canvas.width;
    if (mapviewer.settings.menu_isvisible) {
      N = N - $("#" + mapviewer.menudiv).width();
    }
    var Q = R;
    var M = R;
    var T = N - R;
    var S = this.canvas.height - R;
    this.canvas.use_translated_coordinates = 0;
    this.canvas.drawPoly(
      Q +
        "," +
        M +
        " " +
        Q +
        "," +
        S +
        " " +
        T +
        "," +
        S +
        " " +
        T +
        "," +
        M +
        " " +
        Q +
        "," +
        M
    );
    this.canvas.use_translated_coordinates = 1;
    var U = (30 * (T - Q)) / 830;
    if (U > 30) {
      U = 30;
    }
    this.canvas.context.font = U + "pt Calibri";
    this.canvas.context.textAlign = "center";
    this.canvas.setLineStyle("cccccc", 0.5, 3, "dddddd", 0.5);
    this.canvas.context.fillRect(Q, M, T - Q, S - M);
    this.canvas.setLineStyle("222222", 0.8, 3);
    this.canvas.context.fillText(O, (Q + T) / 2, (M + S) / 2);
    this.canvas.context.setLineDash([0]);
    this.canvas.context.textAlign = "left";
  };
  this.makeppt = function (M, Q, T) {
    z = mapviewer;
    if (T) {
      outname = M;
    } else {
      outname = "xcviewer_overall";
    }
    z.printgraph = 1;
    z.printwidth = 940;
    z.printheight = 210;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    filename = "elevation.png";
    $("#selectgraph-1").val("4");
    $("#selectgraph-2").val("0");
    mapviewer.plotgraphs();
    z.saveimage(1, filename);
    z.printgraph = 1;
    z.printwidth = 940;
    z.printheight = 490;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    names = new Array();
    for (var S = 0; S < z.routes.length; S++) {
      name = z.routes[S].runnername;
      tmp = name.split(" - ");
      fname = tmp[0];
      ok = 0;
      for (var R = 0; R < names.length; R++) {
        if (names[R] == fname) {
          ok = 1;
        }
      }
      if (!ok) {
        names.push(fname);
      }
    }
    var N = new Array();
    for (var R = 0; R < names.length; R++) {
      name = names[R];
      for (var S = 0; S < z.routes.length; S++) {
        tname = z.routes[S].runnername;
        tmp = tname.split(" - ");
        fname = tmp[0];
        if (fname == name) {
          z.routes[S].show = 1;
        } else {
          z.routes[S].show = 0;
        }
      }
      if (!T || name == M) {
        filename = name + "_time.png";
        $("#selectgraph-1").val("1");
        mapviewer.plotgraphs();
        z.saveimage(1, filename);
        N.push(filename);
        filename = name + "_pulse.png";
        $("#selectgraph-1").val("5");
        mapviewer.plotgraphs();
        z.saveimage(1, filename);
        N.push(filename);
      }
    }
    tname = M + " - 1";
    tmp = tname.split(" - ");
    name1 = tmp[0];
    for (var R = 0; R < names.length; R++) {
      for (var O = 1; O <= Q; O++) {
        name = names[R];
        for (var S = 0; S < z.routes.length; S++) {
          tname = z.routes[S].runnername;
          tmp = tname.split(" - ");
          fname = tmp[0];
          lap = tmp[1];
          if ((fname == name || fname == name1) && lap == O) {
            z.routes[S].show = 1;
          } else {
            z.routes[S].show = 0;
          }
        }
        filename = name1 + "_vs_" + name + "_lap" + O + "_time.png";
        if (name != name1) {
          $("#selectgraph-1").val("1");
          mapviewer.plotgraphs();
          z.saveimage(1, filename);
          N.push(filename);
        } else {
        }
      }
    }
    $.ajax({ url: "makeppt.php?out=" + outname + "&image=" + N.join(",") });
    z.printgraph = 0;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
  };
  this.makeppt_fromtxtarea = function () {
    var N = $("#savefilename").val();
    var M = $("#savedfiles").val();
    M = M.replace(/\n/, ",");
    $.ajax({ url: "makeppt.php?out=" + N + "&image=" + M });
  };
  this.saveimage = function (N, M) {
    data = $("#graph-" + N).jqplotToImageStr({});
    if (typeof use_exeoutput != "undefined") {
      exeoutput.SetGlobalVariable("name", M, false);
      exeoutput.SetGlobalVariable("data", data, false);
    }
    $.ajax({
      type: "POST",
      url: "saveImage.php",
      dataType: "text",
      data: { data: data, name: M },
    });
  };
  this.saveimage_size = function (R, O, Q, M) {
    if (!Q) {
      if (O.substr(0, 9) == "elevation") {
        z.printwidth = 940;
        z.printheight = 210;
      } else {
        z.printwidth = 940;
        z.printheight = 490;
        if (
          mapviewer.datafieldtypes[
            mapviewer.settings.graphs[R - 1].plottype - 5
          ]
        ) {
          if (
            mapviewer.datafieldtypes[
              mapviewer.settings.graphs[R - 1].plottype - 5
            ].substr(6) == "break"
          ) {
            z.printwidth = 940;
            z.printheight = 345;
          }
        }
      }
    } else {
      z.printwidth = Q;
      z.printheight = M;
    }
    var N = O;
    z.printgraph = 1;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    z.saveimage(1, N);
    z.printgraph = 0;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
  };
  this.downloadimage_size = function (R, O, Q, M) {
    if (!Q) {
      if (O.substr(0, 9) == "elevation") {
        z.printwidth = 940 * 1.5;
        z.printheight = 210 * 1.5;
      } else {
        z.printwidth = 940 * 1.5;
        z.printheight = 490 * 1.5;
      }
    } else {
      z.printwidth = Q;
      z.printheight = M;
    }
    z.printgraph = R;
    var N = O;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    data = $("#graph-" + R).jqplotToImageStr({});
    downloadImg(data, N);
    z.printgraph = 0;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
  };
  this.compare_route_to_course = function () {
    z = mapviewer;
    var T;
    if (z.settings.coursedefinition_mode == 1) {
      T = "lapdata";
    } else {
      T = "lapdata_failed";
    }
    var M = z.routes[z.settings.coursefit_rnr];
    if (M) {
      var aa = M[T][z.settings.coursefit_lnr];
      if (aa) {
        var X = aa.times;
        var Y = X[0];
        var Q = X[X.length - 1];
        var af = X.length - 1;
        while (isNaN(Q) && af > 0) {
          af--;
          Q = X[af];
        }
        var V = z.settings.routewidth * z.courseinfo.routewidthfactor;
        z.canvas.setLineStyle("000099", 0.3, 4);
        for (var ai = Y; ai < Q; ai++) {
          if (T == "lapdata_failed") {
            if (ai < Q - 30) {
              z.canvas.setLineStyle("000099", 0.3, 1);
            } else {
              z.canvas.setLineStyle("000099", 0.3, 4);
            }
          }
          S = z.map.toxy(M.latarray[ai], M.lngarray[ai]);
          R = z.map.toxy(M.latarray[ai + 1], M.lngarray[ai + 1]);
          z.canvas.drawLine(S.x, S.y, R.x, R.y);
        }
        if (T == "lapdata_failed") {
          var N = Math.floor(Q) + 30;
          if (N > M.latarray.length) {
            N = M.latarray.length;
          }
          z.canvas.setLineStyle("990000", 0.5, 4);
          for (var ai = Math.floor(Q); ai < N; ai++) {
            S = z.map.toxy(M.latarray[ai], M.lngarray[ai]);
            R = z.map.toxy(M.latarray[ai + 1], M.lngarray[ai + 1]);
            z.canvas.drawLine(S.x, S.y, R.x, R.y);
          }
        }
        var U = "ff0000";
        var W = 0;
        var ad = 0;
        for (var ai = 0; ai < X.length; ai++) {
          thistime1 = Math.floor(X[ai]);
          thistime2 = Math.ceil(X[ai]);
          P1a = z.map.toxy(M.latarray[thistime1], M.lngarray[thistime1]);
          P1b = z.map.toxy(M.latarray[thistime2], M.lngarray[thistime2]);
          x1a = P1a.x;
          y1a = P1a.y;
          x1b = P1b.x;
          y1b = P1b.y;
          var Z = X[ai] - Math.floor(X[ai]);
          x1 = x1a * (1 - Z) + x1b * Z;
          y1 = y1a * (1 - Z) + y1b * Z;
          var ah = 0;
          var O = 0;
          if (z.coursecoords[ai]) {
            var aj = z.coursecoords[ai].split(",");
            ah = parseFloat(aj[0]);
            O = parseFloat(aj[1]);
          }
          var ac = V / 2;
          var ab = V / 4;
          if (U == "ff0000") {
            U = "0000ff";
          } else {
            U = "ff0000";
          }
          z.canvas.setLineStyle(U, 0.5, 1);
          z.canvas.drawLine(x1, y1, ah, O);
          z.canvas.drawCircle(x1, y1, ac);
          z.canvas.drawCircle(ah, O, ab);
          var S = z.map.tolatlng(x1, y1);
          var R = z.map.tolatlng(ah, O);
          var ae = calcdistance(S.lat, S.lng, R.lat, R.lng);
          W = W + ae;
          ad++;
        }
        if (T == "lapdata_failed") {
          for (var ai = X.length - 1; ai < z.coursecoords.length; ai++) {
            var aj = z.coursecoords[ai].split(",");
            ah = parseFloat(aj[0]);
            O = parseFloat(aj[1]);
            U = "000000";
            z.canvas.setLineStyle(U, 1, 2);
            z.canvas.drawCircle(ah, O, V * 4);
          }
        }
        var ag = M.runnername + " ";
        if (aa.fitinfo) {
          ag += aa.fitinfo + ". ";
        }
        avgdist = W / ad;
        if (T != "lapdata_failed") {
          ag += "Average offset " + parseInt(aa.average_offset) / 10 + " m";
        } else {
          if (!isNaN(avgdist)) {
            ag += "Average offset " + parseInt(avgdist * 10) / 10 + " m";
          }
        }
        z.canvas.writeTextOutlined(x, y, this.settings.highlightcolor, ag);
      }
    }
  };
  this.showrwroutes_direct = function (N) {
    var M = 0;
    if (N) {
      N = $("#password").val();
      if (z.settings.orunningwild.password == N) {
        M = 1;
        z.close_dialog();
      } else {
        alert(
          'Sorry! Wrong password! Please try again, or click "OK" and draw your route.'
        );
      }
    } else {
      M = 1;
    }
    if (M) {
      z.settings.orunningwild.finished = 0;
      z.settings.orunningwild.started = 1;
      z.prepare_finished_runningwild();
      z.settings.orunningwild.finished = 1;
      if (isnarrowscreen) {
      } else {
        $("#" + z.infodiv).html("<b>RunningWild Analysis</b>");
      }
      z.request_redraw();
      div = "togglerightmenu";
      $("#" + z.menudiv).css("z-index", 10);
      $("#" + z.menudiv).css("width", 200);
      z.settings.menu_isvisible = 1;
      $("#" + div).html("Hide menu");
      z.settings.orunningwild.ideal_show = 0;
      z.settings.orunningwild.equal_percent = -1;
      this.settings.showtagmode = 0;
      this.settings.tagmode = 0;
      this.settings.infotxt = "";
      z.canvas.use_rotate = 1;
      z.canvas.mouse_rotate = 1;
      z.loadotherrw();
    }
  };
  this.play_loop = function () {
    if (
      (this.playing || this.has_request_redraw || z.settings.runningwild) &&
      z.canvas.context
    ) {
      f++;
      this.has_request_redraw = 0;
      var M = new Date().getTime();
      var N = this.previousdrawstarttime_ms - M;
      this.previousdrawstarttime_ms = M;
      if (this.playing) {
        this.playtime =
          ((M - this.replaystarttime_localtime_ms) / 1000) * this.play_speed +
          this.replaystarttime_competitiontime_ms / 1000;
      }
      if (!g) {
        g = 1;
        this.redraw();
        this.lastDrawTime = new Date().getTime() - M;
        g = 0;
      }
    }
  };
  this.make_canalysis_div = function () {
    var M =
      "<h4>Corridor evaluation</h4><font size=1>Instructions: 1. Draw a couse along the corridor using 'Draw course' functionality. 2. Selected athletes and parts of the routes to evaluate. 3. Adjust corridor width to fit the actual corridor. 4. Click 'Evaluate corridor'. You can change corridor width and see live updated results without new calculations.</font><br><br>";
    M += z.printquickbutton_updown(
      "Width",
      "&lt;",
      "mapviewer.change_canalysis_setting('corrwidth',-1);",
      "&gt;",
      "mapviewer.change_canalysis_setting('corrwidth',1);",
      parseInt(z.settings.corridorwidth) + " m",
      "Choose corridor width",
      "id_changecorrwidth"
    );
    M += z.printquickbutton_toggle(
      null,
      "Show eval.",
      "id_showcorreval",
      "mapviewer.change_canalysis_setting('corrtoggle')",
      z.settings.corridoranalysis,
      "Show/hide corridor evaluation. Only applies when corridor evaluated."
    );
    M +=
      '<button onclick="mapviewer.check_corridors();">Evaluate corridor</button> <button onclick="mapviewer.otech_showresults(\'corridor\');">R</button> <div id="corridor_isworking"></div><p>';
    M +=
      "<hr><h4>Compass evaluation</h4><font size=1>Instructions: 1. Draw the course using the 'Draw course' functionality. 2. Selected athletes and parts of the routes to evaluate. 3. Choose compass evaluation criteria. Minimum offset and angle defines a corridor the athlete has to be within. 4. Click 'Evaluate compass'. You need to re-evaluate when you change criteria. Note! If you need to move control points for runners this is done under 'Analyze course'.</font><br><br>";
    M += z.printquickbutton_updown(
      "Min offset",
      "&lt;",
      "mapviewer.change_canalysis_setting('compasswidth',-1);",
      "&gt;",
      "mapviewer.change_canalysis_setting('compasswidth',1);",
      parseInt(z.settings.compasswidth) + " m",
      "Choose minimum width of evaluation corridor for compass evaluation",
      "id_changecompasswidth"
    );
    M += z.printquickbutton_updown(
      "Angle",
      "&lt;",
      "mapviewer.change_canalysis_setting('compassangle',-1);",
      "&gt;",
      "mapviewer.change_canalysis_setting('compassangle',1);",
      parseInt(z.settings.compassangle) + " deg",
      "Choose angle for corridor for compass evaluation",
      "id_changecompassangle"
    );
    M += '<div id="compass_selectlegsdiv" style="height:80px"></div>';
    M += z.printquickbutton_toggle(
      null,
      "Show eval.",
      "id_showcompasseval",
      "mapviewer.change_canalysis_setting('compasstoggle')",
      z.settings.corridoranalysis,
      "Show/hide corridor evaluation. Only applies when corridor evaluated."
    );
    M += z.printquickbutton_toggle(
      null,
      "Show splitpos",
      "id_showcompasssplits",
      "mapviewer.change_canalysis_setting('compasssplits')",
      z.settings.compassanalysis_showsplits,
      "Show/hide identified controls used for analysis. Positions must be changed under 'Analyze course'"
    );
    M +=
      '<button onclick="mapviewer.check_compasses();">Evaluate compass</button> <button onclick="mapviewer.otech_showresults(\'compass\');">R</button> <div id="compass_isworking"></div><p>';
    return M;
  };
  this.otech_showresults = function (S) {
    if (S == "compass") {
      z = mapviewer;
      var T =
        '<div style="-webkit-user-select: all;-ms-user-select: all;-moz-user-select: all;">';
      T +=
        '<h4>Results Compass Evaluation</h4><table class="table" border=1 cellpadding=3 cellspacing=0>';
      T += "<tr><th>Name</th>";
      T += "<th>Result</th>";
      for (var R = 1; R < z.coursecoords.length; R++) {
        if ($.inArray(R, z.otechinfo.compass_includelegs) >= 0) {
          T += "<th>" + R + "</th>";
        }
      }
      T += "</tr>";
      for (var Q = 0; Q < z.routes.length; Q++) {
        var M = z.routes[Q];
        if (M.show) {
          var O = M.runnername;
          T = T + "<tr><td>" + O + "</td>";
          var N = M.results;
          if (N) {
            if (N.compass_overall) {
              T = T + "<td>" + Math.round(N.compass_overall) + "%</td>";
              for (var R = 1; R < z.coursecoords.length; R++) {
                if ($.inArray(R, z.otechinfo.compass_includelegs) >= 0) {
                  thisscore = N.compass.score[R];
                  thisoffset = N.compass.max_offset[R];
                  T =
                    T +
                    "<td>" +
                    Math.round(thisscore) +
                    "%<br><font size=1>Max " +
                    Math.round(thisoffset) +
                    "m</font></td>";
                }
              }
            }
          }
          T = T + "</tr>";
        }
      }
      T = T + "</table></div>";
      z.open_dialog("Results Compass Evaluation", T);
    } else {
      if (S == "corridor") {
        z = mapviewer;
        var T =
          '<div style="-webkit-user-select: all;-ms-user-select: all;-moz-user-select: all;">';
        T +=
          '<h4>Results Corridor Evaluation</h4><table class="table" border=1 cellpadding=3 cellspacing=0>';
        T += "<tr><th>Name</th>";
        T += "<th>Overall score</th>";
        T += "<th>Time score</th>";
        T += "<th>Length score</th>";
        T += "</tr>";
        for (var Q = 0; Q < z.routes.length; Q++) {
          var M = z.routes[Q];
          if (M.show) {
            var O = M.runnername;
            T = T + "<tr><td>" + O + "</td>";
            var N = M.results;
            if (N) {
              if (N.corridor_overall) {
                T =
                  T +
                  "<td>" +
                  Math.round(M.results.corridor_overall) +
                  "%</td><td>" +
                  Math.round(M.results.corridor_time) +
                  "%</td><td>" +
                  Math.round(M.results.corridor_length) +
                  "%</td></tr>";
              }
            }
            T = T + "</tr>";
          }
        }
        T = T + "</table></div>";
        z.open_dialog("Results Corridor Evaluation", T);
      }
    }
  };
  this.update_canalysis_div = function () {
    var N = new Array();
    var Q = new Array();
    if (!z.otechinfo) {
      z.otechinfo = new Object();
    }
    if (!z.otechinfo.compass_includelegs) {
      z.otechinfo.compass_includelegs = new Array();
      for (var R = 1; R < z.coursecoords.length; R++) {
        z.otechinfo.compass_includelegs.push(R);
      }
    }
    if (z.coursecoords.length > 0) {
      for (var R = 1; R < z.coursecoords.length; R++) {
        N.push(R + ":Leg " + R);
        if ($.inArray(R, z.otechinfo.compass_includelegs) >= 0) {
          Q.push(R);
        }
      }
      var M = N.join("|");
      var O = z.printselect(
        "Include legs:",
        "compass_selectlegs_multiple",
        M,
        Q,
        "horlabel",
        "",
        "mapviewer.change_canalysis_setting('compasslegselect',0)"
      );
      $("#compass_selectlegsdiv").html(O);
    } else {
      $("#compass_selectlegsdiv").html(
        "<font color='#ff0000'>Define a course to use compass evaluation</font>"
      );
    }
  };
  this.change_canalysis_setting = function (N, Q) {
    if (N == "compasslegselect") {
      if ($("#compass_selectlegs_multiple")) {
        z.otechinfo.compass_includelegs = $(
          "#compass_selectlegs_multiple"
        ).val();
        for (var O = 0; O < z.otechinfo.compass_includelegs.length; O++) {
          z.otechinfo.compass_includelegs[O] = parseInt(
            z.otechinfo.compass_includelegs[O]
          );
        }
      }
    } else {
      if (N == "compasssplits") {
        if (z.settings.compassanalysis_showsplits == 1) {
          z.settings.compassanalysis_showsplits = 0;
        } else {
          z.settings.compassanalysis_showsplits = 1;
          z.settings.compassanalysis = 1;
          $("#id_showcompasseval").prop("checked", true);
          if (z.settings.corridoranalysis == 1) {
            z.settings.corridoranalysis = 0;
            $("#id_showcorreval").prop("checked", false);
          }
        }
        z.request_redraw();
      } else {
        if (N == "corrwidth") {
          z.settings.corridorwidth = z.settings.corridorwidth + Q;
          if (z.settings.corridorwidth < 1) {
            z.settings.corridorwidth = 1;
          }
          $("#id_changecorrwidth_val").html(z.settings.corridorwidth + " m");
          for (var M = 0; M < z.routes.length; M++) {
            z.routes[M].calc_corridor_results();
          }
        }
        if (N == "compasswidth") {
          z.settings.compasswidth = z.settings.compasswidth + Q;
          if (z.settings.compasswidth < 1) {
            z.settings.compasswidth = 1;
          }
          $("#id_changecompasswidth_val").html(z.settings.compasswidth + " m");
          $("#compass_isworking").html(
            "<font color='#ff0000'>Note! Evaluation criteria changed - need to re-evaluate!</font>"
          );
          $("#compass_isworking").show();
        }
        if (N == "compassangle") {
          z.settings.compassangle = z.settings.compassangle + Q;
          if (z.settings.compassangle < 0) {
            z.settings.compassangle = 0;
          }
          $("#id_changecompassangle_val").html(
            z.settings.compassangle + " deg"
          );
          $("#compass_isworking").html(
            "<font color='#ff0000'>Note! Evaluation criteria changed - need to re-evaluate!</font>"
          );
          $("#compass_isworking").show();
        }
        if (N == "corrtoggle") {
          if (z.settings.corridoranalysis == 1) {
            z.settings.corridoranalysis = 0;
          } else {
            z.settings.corridoranalysis = 1;
            if (z.settings.corridoranalysis == 1) {
              z.settings.compassanalysis = 0;
              $("#id_showcompasseval").prop("checked", false);
            }
          }
        }
        if (N == "compasstoggle") {
          if (z.settings.compassanalysis == 1) {
            z.settings.compassanalysis = 0;
          } else {
            z.settings.compassanalysis = 1;
            if (z.settings.corridoranalysis == 1) {
              z.settings.corridoranalysis = 0;
              $("#id_showcorreval").prop("checked", false);
            }
          }
        }
        z.update_routediv(false);
        z.request_redraw();
      }
    }
  };
  this.xcmenu = function () {
    if (xclight) {
      M = this.xclightmenu();
      return M;
    }
    var M = "";
    M = M + "<hr><b>Graphs</b><br>";
    selectgraphtype = "";
    selectgraphtype += '<option value="0">No graph</option>';
    selectgraphtype += '<option value="1">Time</option>';
    selectgraphtype += '<option value="2">Speed</option>';
    selectgraphtype += '<option value="3">Pace</option>';
    if (z.courseinfo.coursetype != "o") {
      selectgraphtype += '<option value="4">XC elevation</option>';
      var Q = z.datafieldtypes;
      for (var N = 0; N < Q.length; N++) {
        fieldval = N + 5;
        fieldname = Q[N];
        fielddisplay = z.datafieldtypes_display[N];
        selectgraphtype +=
          '<option value="' +
          fieldval +
          '">' +
          fielddisplay.capitalize() +
          "</option>";
      }
      selectgraphtype += '<option value="101">Pulse %ofmax</option>';
      selectgraphtype += '<option value="999">Animation</option>';
    } else {
      selectgraphtype += '<option value="4">Elevation</option>';
      selectgraphtype += '<option value="101">Pulse</option>';
      selectgraphtype += '<option value="102">Distance from line</option>';
      selectgraphtype += '<option value="103">Extra distance</option>';
    }
    for (var O = 0; O < z.settings.maxgraphs; O++) {
      M +=
        '<select name="selectgraph-' +
        (O + 1) +
        '" id="selectgraph-' +
        (O + 1) +
        '">' +
        selectgraphtype +
        '</select> <a href="javascript:void(0);" onclick="mapviewer.graphsettings(' +
        O +
        ',false);" title="Advanced graph settings for graph ' +
        (O + 1) +
        '"><img src="js/advanced.png" height=15></a><br>';
    }
    M =
      M +
      ' <button onclick="mapviewer.doplotcoursegraph();return false;">Plot</button><br>';
    M =
      M +
      "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.toggle_graphs();'>Graphs on/off</a><br>";
    if (0) {
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' title='Plots segmentgraph using the field type chosen under the first graph and the first two shown athletes' onclick='mapviewer.plotsegmentoverview();'>Segmentgraph (experimental)</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Uphill\",0);'>Compare all Uphill unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Uphill\",1);'>Compare all Uphill sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Downhill\",0);'>Compare all Downhill unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Downhill\",1);'>Compare all Downhill sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Flat\",0);'>Compare all Flat unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Flat\",1);'>Compare all Flat sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Course\",0);'>Compare all Course unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"Course\",1);'>Compare all Course sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Slower|1|Uphill\",0);'>Compare slowest Uphills unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Faster|1|Uphill\",1);'>Compare fastest Uphills sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Faster|1|Uphill\",0);'>Compare fastest Uphills unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Slower|1|Uphill\",1);'>Compare slowest Uphills sorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Faster|1|Course\",0);'>Compare fastest Course unsorted</a><br>";
      M =
        M +
        "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.plotsegmentinfo(\"CMP|Slower|1|Course\",0);'>Compare slowest Course unsorted</a><br>";
    }
    M =
      M +
      "<font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.exportgraphdata(1);'>Export graph data</a> <a href='javascript:void(0);' onclick='mapviewer.exportgraphdata(2);'>New</a> <a href='javascript:void(0);' onclick='mapviewer.exportgraphdata(3);'>3D</a> <a href='javascript:void(0);' onclick='mapviewer.set_prettygraphsettings();'>.</a> <a href='javascript:void(0);' onclick='mapviewer.ploteleprofile_popup_scaled()'>S</a><br>";
    M =
      M +
      "<font size=1>&raquo; Graph height: <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=.25;mapviewer.request_redraw();'>.25</a> <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=.5;mapviewer.request_redraw();'>.5</a> <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=.75;mapviewer.request_redraw();'>.75</a> <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=1;mapviewer.request_redraw();'>1</a><a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=1.5;mapviewer.request_redraw();'>1.5</a> <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=-1;mapviewer.request_redraw();mapviewer.canvas.width=mapviewer.canvas.width-1;'>S</a> <a href='javascript:void(0);' onclick='mapviewer.showBelowFactor=-2;;mapviewer.canvas.width=mapviewer.canvas.width-1;mapviewer.request_redraw();'>X</a><br>";
    M = M + "</font>";
    return M;
  };
  this.xclightmenu = function () {
    var M = "";
    M =
      M +
      "<div style='padding-bottom:8px;font-size:18px;color:#006600;'><b>XCviewer Light</b></div>";
    M =
      M +
      '<b>Instructions</b><font size=1><br>1. Drag GPX-files onto browser<br>2. Define course in course definition mode<br>3. Click \'Plot\' to compare athletes.<p>Recommended: Use <b>\'Split routes by lap\'</b> below after you are happy with your course definition to be able to plot/change color for single laps (no undo!).<p></p>See <a href="https://www.youtube.com/watch?v=Hduwn6hRYA8" target="_blank">Help video 1</a> / <a href="https://www.youtube.com/watch?v=nPUwxoaxvIg" target="_blank">Help video 2</a></font><p>';
    selectgraphtype = "";
    selectgraphtype += '<option value="1">Time</option>';
    selectgraphtype += '<option value="101">Pulse</option>';
    selectgraphtype += '<option value="998">Lap times</option>';
    selectgraphtype += '<option value="999">Animation</option>';
    j = 0;
    M +=
      '<div style="padding-bottom: 5px"><select style="width:150px" name="selectgraph-' +
      (j + 1) +
      '" id="selectgraph-' +
      (j + 1) +
      '">' +
      selectgraphtype +
      "</select></div>";
    M += '<input type="hidden" id="selectgraph-2" value="4">';
    M += '<input type="hidden" id="selectgraph-3" value="0">';
    M += '<input type="hidden" id="selectgraph-4" value="0">';
    M =
      M +
      ' <button onclick="mapviewer.doplotcoursegraph();return false;">Plot</button>';
    M =
      M +
      " <button onclick=\" $('#selectmode').val('definecourse');$('#selectmode').change();\">Define course</button>";
    M =
      M +
      '<br><button id="splitroutesbutton" onclick="mapviewer.splitunsplitroutes();">Split routes by lap</button>';
    M = M + "<br>";
    return M;
  };
  this.addbutton = function (U, T, M, S) {
    var O = T.split("|");
    var N = O[1];
    var Q = "";
    var R = "";
    if (S) {
      R = ' style="cursor:help" title="' + S + '"';
    }
    if (N) {
      Q = " class='" + N + "'";
    }
    $("#" + U).append(
      "<button " + R + ' id="' + O[0] + '"' + Q + ">" + M + "</button>"
    );
  };
  var m;
  var K;
  this.colorcounter = 0;
  this.timer = null;
  this.playtime = null;
  this.infodiv = o;
  this.menudiv = D;
  this.canvasid = F;
  this.coursecoords = new Array();
  this.coursecontrolcoords = new Array();
  this.courseeditor_data = null;
  this.courseinfo = new Object();
  this.courseinfo.arrowspacing = 60;
  this.courseinfo.coursecolortype = 2;
  this.courseinfo.eachdistmark = 500;
  this.courseinfo.showdistmarkers = 1;
  this.courseinfo.maxantflat = 10;
  this.courseinfo.routewidthfactor = 0.3;
  this.courseinfo.min_eleopposite_allowed = 1;
  this.courseinfo.min_antupdown_for_hill = 6;
  this.courseinfo.distarray = new Array();
  this.courseinfo.usegradedelevation = 0;
  this.courseinfo.distmarkercol = "0000ff";
  this.courseinfo.neednewsnap = 1;
  this.courseinfo.coursetype = "xc";
  this.courseinfo.biathlonvariables = new Array();
  this.courseinfo.splitpos = new Array();
  this.coursecoords_alongline = new Array();
  this.routes = new Array();
  this.maps = new Array();
  this.zerotime = 1e99;
  this.maxtime = -1e99;
  this.playing = false;
  this.playtime_onmousedown = null;
  this.marker_onmousedown = null;
  this.control_onmousedown = null;
  this.tagpoint_onmousedown = null;
  if (!isnarrowscreen) {
    $("#" + z.menudiv).html(
      "<div id='toprightmenu'></div><div id='addroutediv'></div><div id='routemenu'></div><div id='routedesc'></div><div id='infobottomdiv'></div><div id='xinfodiv'></div>"
    );
  } else {
    $("#" + z.menudiv).html(
      "<div id='toprightmenu'></div><div id='addroutediv'></div><div id='routemenu'></div><div id='routedesc'></div><div id='infobottomdiv' style='overflow-y:scroll;'></div>"
    );
  }
  this.toprightmenu = "toprightmenu";
  this.routemenudiv = "routemenu";
  this.routedescdiv = "routedesc";
  this.addroutediv = "addroutediv";
  this.infobottomdiv = "infobottomdiv";
  $("#routemenu").html(
    '<center><p>Loading routes<p><img src="loading.gif"><p>Be patient<center>'
  );
  $("#" + this.addroutediv).hide();
  if (
    window.location.host != "localhost" &&
    window.location.host != "3drerun.worldofo.com"
  ) {
    $("#" + this.addroutediv).html(
      '<div id="search3drerun" style="display:hidden"></div>'
    );
  } else {
    $("#" + this.addroutediv).html(
      '<div id="search3drerun" style="display:none"><b>Search 3DRerun</b><br><font size=1>Search for routes/maps in this area.</font><br><select id="addroutestype"><option value="routes">Routes</option><option value="maps">Maps</option></select><br><select id="addroutesdate"><option value="any">Any date</option></select><br><font size=1>Free text (can be empty)</font><br><input id="addroutestxt" size=20><button onclick="mapviewer.addroutesfrombutton();">Search 3DRerun</button><br><hr><div id="addroutes"></div></div><hr>'
    );
  }
  if (z.routes.length > 0 || z.maps.id || getURLParameter("dragdrop")) {
    $("#search3drerun").show();
  }
  if (courseplanning) {
    if (ismapantcourse) {
      $("#" + this.addroutediv).html(
        $("#" + this.addroutediv).html() +
          '<h4>Load map</h4><font size=1>Choose a MapAnt.no file (png with name <i>mapant-export-[....].png</i>) here to start.<br></font><br><form style="display:none"><input type="file" id="fileinput" accept=".jpg,.png,.gif" multiple style="display:none"></form><button onclick="$(\'#fileinput\').trigger(\'click\');">Browse</button><br><hr>'
      );
    } else {
      $("#" + this.addroutediv).html(
        $("#" + this.addroutediv).html() +
          '<h4>Load map</h4><font size=1>Choose a JPG/PNG to load map (or replace current map if you already loaded a map).<br></font><br><form style="display:none"><input type="file" id="fileinput" accept=".jpg,.png,.gif" multiple style="display:none"></form><button onclick="$(\'#fileinput\').trigger(\'click\');">Browse</button><br><hr>'
      );
    }
  } else {
    $("#" + this.addroutediv).html(
      $("#" + this.addroutediv).html() +
        '<b>From harddisk</b><br><font size=1>Choose routes to add and/or map to replace current map.</font><br><form style="display:none"><input type="file" id="fileinput" accept=".gpx" multiple style="display:none"></form><button onclick="$(\'#fileinput\').trigger(\'click\');">Browse</button><br><hr>'
    );
  }
  $("#fileinput").bind("change", function (M) {
    mapviewer.uploadfiles(M.originalEvent.target.files, "all");
  });
  if (window.location.host == "localhost" && !courseplanning) {
    $("#" + this.addroutediv).html(
      $("#" + this.addroutediv).html() +
        '<hr><b>From GPSSeuranta</b><br><button id="addseurantabutton" onclick="mapviewer.addroutesfromgpsseuranta(0);">Load GPSSeuranta events</button><div id="addseurantadiv"></div><hr>'
    );
  }
  $("#" + this.addroutediv).append(
    '<div id="setscalediv"><hr><h4>Set Scale/DPI</h4><font size=1>Set scale and DPI to get correct course/route lengths. Tip: If you are not sure about the DPI, draw a course with known length and change DPI until the length fits.<br></font><table cellpadding=1><tr><td><font size=1><b>Scale:</b></font></td><td><input size=6 id="mapscale" value="' +
      z.settings.scale +
      '"></td></tr><tr><td><font size=1><b>DPI:</b></font></td><td><input size=6 id="dpi" value="' +
      z.settings.dpi +
      '"></td></tr></table><button onclick="mapviewer.setdpiscale_frominput();">Set Scale/DPI</button></div>'
  );
  if (!courseplanning) {
    $("#" + this.addroutediv).append(
      "<font size=1 color='#ff0000'>Warning! Setting scale/DPI for an already calibrated map will remove the calibration and place the map in a different place. All lengths for routes in course planning mode will then be wrong.</font>"
    );
  }
  if (courseplanning) {
    if (!z.map) {
      $("#setscalediv").hide();
    }
    $("#" + this.addroutediv).append(
      '<div id="mapsize"></div><div id="courseplanning_courselength" style="display:none;"><span id="showcourselength_planning"></span></div>'
    );
  }
  var u = "";
  if (!xclight) {
    u +=
      "<b>Instructions</b><br>Click 'Plot' to compare athletes. Use 'Split routes by lap' below to be able to plot/change color for single laps (no undo!).<p>";
  }
  u +=
    "&raquo; <a title='The routes which are shown now will be used as Average Joe' href='javascript:void(0);' onclick='for (var kk=0;kk<mapviewer.routes.length;kk++) { if (mapviewer.routes[kk].show) {  mapviewer.settings.exclude_averagejoe[mapviewer.routes[kk].runnername]=0;  } else { mapviewer.settings.exclude_averagejoe[mapviewer.routes[kk].runnername]=1;  } };'>Define Average Joe</a><br>&raquo; Sort by <a href='javascript:void(0);' onclick='mapviewer.settings.sortxcresults=0;mapviewer.update_routediv(false);'>time</a>/<a href='javascript:void(0);' onclick='mapviewer.settings.sortxcresults=1;mapviewer.update_routediv(false);'>start</a>/<a href='javascript:void(0);' onclick='mapviewer.settings.sortxcresults=2;mapviewer.update_routediv(false);'>alpha</a><br><div id='cmplapnumberdiv'></div>";
  if (xc == 0) {
    this.courseinfo.coursetype = "o";
    var J = "";
    if (
      (window.location.host == "localhost" || getURLParameter("dragdrop")) &&
      !courseplanning
    ) {
      J = '<option value="graph">Graph mode</option>';
    }
    if (!courseplanning) {
      var q = '<option value="canalysis">O-tech evaluation</option>';
      J += q;
    }
    var E = "";
    if (courseplanning) {
      E = '<option value="addroutes">Load map</option>';
    } else {
      if (1) {
        E = '<option value="addroutes">Add routes/Change map</option>';
      }
    }
    if (courseplanning) {
      $("#" + this.toprightmenu).append(
        '<select id="selectmode">' +
          E +
          '<option value="drawcourse">Draw course</option><option value="analyzecourse">Draw routechoices</option><option value="savedata">Load/save data</option></select>'
      );
    } else {
      $("#" + this.toprightmenu).append(
        '<select id="selectmode"><option selected value="replay">Replay mode</option><option value="analysis">Split analysis</option><option value="dotanalysis">Dot analysis</option><option value="autoanalysis">AutOanalysis</option><option value="drawcourse">Draw course</option><option value="analyzecourse">Analyze course</option><option value="detailedanalysis">DetailedAnalysis</option>' +
          J +
          '<option value="calibrate">Map calibration</option>' +
          E +
          "</select>"
      );
    }
    $("#selectmode").change(function () {
      if ($("#selectmode").val() != "calibrate") {
        z.settings.calibrationmode = 0;
      }
      if ($("#selectmode").val() != "addroutes") {
        $("#addroutediv").hide();
        $("#" + z.routemenudiv).show();
      }
      z.showtags_control(-1);
      if ($("#selectmode").val() != "graph") {
        z.settings.showInfoBelow = "";
        z.request_redraw();
      }
      if ($("#selectmode").val() != "canalysis") {
        z.settings.otechanalysis = 0;
        $("#canalysis").hide();
      }
      if ($("#selectmode").val() == "replay") {
        $("#playspeedr").show();
        $("#realtime").show();
        $("#playcontrol").show();
        $("#autobutton").hide();
        $("#graphcontrol").hide();
        $("#autoanalysis_adjust").hide();
        $("#detailedanalysis_settings").hide();
        if (z.IsLive) {
          if (z.playing) {
            z.toggleplay();
          }
          z.IsLive = 0;
        }
        z.settings.mode = z.settings.modes.ReplayMode;
        z.request_redraw();
      }
      if ($("#selectmode").val() == "calibrate") {
        z.settings.calibrationmode = 1;
        z.setup_start_recalibration();
        z.Draw_all_full_routes(0);
        z.settings.mode = z.settings.modes.CalibrationMode;
        $("#playspeedr").hide();
        $("#realtime").hide();
        $("#playcontrol").hide();
        $("#autobutton").hide();
        $("#graphcontrol").hide();
        $("#autoanalysis_adjust").hide();
        $("#detailedanalysis_settings").hide();
        z.settings.showdrawdots = 0;
        z.settings.autoanalysis = 0;
        z.settings.detailedanalysis = 0;
        z.settings.analyzecourse = 0;
        z.IsLive = 0;
        if (z.playing) {
          z.toggleplay();
        }
        z.request_redraw();
      }
      if ($("#selectmode").val() == "live") {
        $("#playspeedr").hide();
        $("#realtime").hide();
        $("#playcontrol").hide();
        $("#autobutton").hide();
        $("#graphcontrol").hide();
        $("#autoanalysis_adjust").hide();
        $("#detailedanalysis_settings").hide();
        z.startLive();
        z.settings.mode = z.settings.modes.LiveMode;
        z.request_redraw();
      } else {
        if ($("#selectmode").val() == "analysis") {
          z.realtime = 0;
          $("#playspeedr").hide();
          $("#realtime").hide();
          $("#playcontrol").hide();
          $("#graphcontrol").hide();
          $("#autobutton").hide();
          $("#autoanalysis_adjust").hide();
          $("#detailedanalysis_settings").hide();
          z.settings.mode = z.settings.modes.AnalysisMode;
          z.settings.showdrawdots = 0;
          z.settings.autoanalysis = 0;
          z.settings.detailedanalysis = 0;
          z.settings.analyzecourse = 0;
          z.IsLive = 0;
          if (z.playing) {
            z.toggleplay();
          }
        } else {
          if ($("#selectmode").val() == "canalysis") {
            z.realtime = 0;
            $("#playspeedr").hide();
            $("#realtime").hide();
            $("#playcontrol").hide();
            $("#graphcontrol").hide();
            $("#autobutton").hide();
            $("#autoanalysis_adjust").hide();
            $("#detailedanalysis_settings").hide();
            $("#canalysis").show();
            z.settings.mode = z.settings.modes.AnalysisMode;
            z.settings.showdrawdots = 0;
            z.settings.otechanalysis = 1;
            z.settings.autoanalysis = 0;
            z.settings.detailedanalysis = 0;
            z.settings.analyzecourse = 0;
            z.IsLive = 0;
            if (z.playing) {
              z.toggleplay();
            }
            z.request_redraw();
            z.update_canalysis_div();
            if (!mapviewer.settings.autosplits_calculated) {
              mapviewer.calculate_autosplits();
            }
          } else {
            if ($("#selectmode").val() == "dotanalysis") {
              z.realtime = 0;
              $("#playspeedr").hide();
              $("#realtime").hide();
              $("#playcontrol").hide();
              $("#autobutton").hide();
              $("#graphcontrol").hide();
              $("#autoanalysis_adjust").hide();
              $("#detailedanalysis_settings").hide();
              z.settings.mode = z.settings.modes.AnalysisMode;
              z.settings.showdrawdots = 1;
              z.settings.analyzecourse = 0;
              z.IsLive = 0;
              z.settings.autoanalysis = 0;
              z.settings.detailedanalysis = 0;
              if (z.playing) {
                z.toggleplay();
              }
              z.request_redraw();
            } else {
              if ($("#selectmode").val() == "autoanalysis") {
                z.realtime = 0;
                $("#playspeedr").hide();
                $("#realtime").hide();
                $("#playcontrol").hide();
                $("#autobutton").show();
                $("#graphcontrol").hide();
                $("#autoanalysis_adjust").show();
                $("#detailedanalysis_settings").hide();
                z.settings.mode = z.settings.modes.AnalysisMode;
                z.settings.analyzecourse = 0;
                z.IsLive = 0;
                z.settings.showdrawdots = 0;
                z.settings.autoanalysis = 1;
                z.settings.detailedanalysis = 0;
                z.segments = new Array();
                z.numsegments = 0;
                if (z.playing) {
                  z.toggleplay();
                }
                z.request_redraw();
              } else {
                if ($("#selectmode").val() == "detailedanalysis") {
                  z.realtime = 0;
                  $("#playspeedr").hide();
                  $("#realtime").hide();
                  $("#playcontrol").hide();
                  $("#autobutton").hide();
                  $("#graphcontrol").hide();
                  $("#autoanalysis_adjust").hide();
                  $("#detailedanalysis_settings").show();
                  z.settings.mode = z.settings.modes.DetailedMode;
                  z.settings.analyzecourse = 0;
                  z.IsLive = 0;
                  z.settings.showdrawdots = 0;
                  z.settings.autoanalysis = 0;
                  z.settings.detailedanalysis = 1;
                  z.segments = new Array();
                  z.numsegments = 0;
                  if (z.playing) {
                    z.toggleplay();
                  }
                  z.request_redraw();
                } else {
                  if ($("#selectmode").val() == "drawcourse") {
                    z.realtime = 0;
                    $("#playspeedr").hide();
                    $("#realtime").hide();
                    $("#playcontrol").hide();
                    $("#graphcontrol").hide();
                    z.settings.mode = z.settings.modes.DrawCourseMode;
                    z.settings.analyzecourse = 0;
                    z.settings.tagmode = 0;
                    z.settings.showdrawdots = 0;
                    z.settings.autoanalysis = 0;
                    z.settings.detailedanalysis = 0;
                    z.IsLive = 0;
                    if (z.playing) {
                      z.toggleplay();
                    }
                    z.request_redraw();
                    z.settings.autosplits_calculated = 0;
                  } else {
                    if ($("#selectmode").val() == "savedata") {
                      z.realtime = 0;
                      $("#playspeedr").hide();
                      $("#realtime").hide();
                      $("#playcontrol").hide();
                      $("#graphcontrol").hide();
                      z.settings.mode = z.settings.modes.SaveDataMode;
                      z.settings.analyzecourse = 0;
                      z.settings.tagmode = 0;
                      z.settings.showdrawdots = 0;
                      z.settings.autoanalysis = 0;
                      z.settings.detailedanalysis = 0;
                      z.IsLive = 0;
                      if (z.playing) {
                        z.toggleplay();
                      }
                      z.request_redraw();
                    } else {
                      if ($("#selectmode").val() == "analyzecourse") {
                        z.realtime = 0;
                        if (!courseplanning) {
                          $("#autobutton").show();
                        }
                        $("#playspeedr").hide();
                        $("#realtime").hide();
                        $("#playcontrol").hide();
                        $("#graphcontrol").hide();
                        z.settings.mode = z.settings.modes.AnalysisMode;
                        z.settings.analyzecourse = 1;
                        z.IsLive = 0;
                        z.settings.showdrawdots = 0;
                        z.settings.autoanalysis = 0;
                        z.settings.detailedanalysis = 0;
                        if (z.playing) {
                          z.toggleplay();
                        }
                        if (!z.settings.autosplits_calculated) {
                          z.calculate_autosplits();
                        }
                        if (z.settings.centerlegnum && !z.settings.showtagall) {
                          z.drawroutechoice_leg(
                            z.settings.centerlegnum,
                            z.playing
                          );
                        } else {
                          if (z.settings.showtagall) {
                            z.showtags_control(-1);
                          }
                        }
                        z.request_redraw();
                      } else {
                        if ($("#selectmode").val() == "graph") {
                          z.realtime = 0;
                          $("#playspeedr").hide();
                          $("#realtime").hide();
                          $("#playcontrol").hide();
                          $("#autobutton").hide();
                          $("#autoanalysis_adjust").hide();
                          $("#detailedanalysis_settings").hide();
                          z.snaproutesto_o_course();
                          z.settings.mode = z.settings.modes.GraphMode;
                          z.settings.showdrawdots = 0;
                          z.settings.autoanalysis = 0;
                          z.settings.detailedanalysis = 0;
                          z.settings.analyzecourse = 0;
                          z.settings.definecourse = 0;
                          $("#definecourseslider").hide();
                          if (z.playing) {
                            z.toggleplay();
                          }
                          z.request_redraw();
                          z.settings.showInfoBelow = "CourseInfo";
                          z.request_redraw();
                          $("#graphcontrol").show();
                          $("#" + z.infobottomdiv).html(u);
                        } else {
                          if ($("#selectmode").val() == "addroutes") {
                            z.settings.mode = z.settings.modes.AddRoutesMode;
                            $("#playspeedr").hide();
                            $("#realtime").hide();
                            $("#playcontrol").hide();
                            $("#addroutediv").show();
                            $("#autobutton").hide();
                            $("#graphcontrol").hide();
                            $("#autoanalysis_adjust").hide();
                            $("#detailedanalysis_settings").hide();
                            if (z.routes.length > 0 || z.maps.id) {
                              $("#search3drerun").show();
                            }
                            var Q = '<option value="any">Any date</option>';
                            var M = new Array();
                            for (var O = 0; O < z.routes.length; O++) {
                              var N = new Date(
                                mapviewer.routes[0].zerotime * 1000
                              )
                                .toString()
                                .substr(0, 10);
                              if (!M[N]) {
                                M[N] = 1;
                                Q +=
                                  '<option value="' +
                                  N +
                                  '">' +
                                  N +
                                  "</option>";
                              }
                            }
                            $("#addroutesdate").html(Q);
                            $("#" + z.routemenudiv).hide();
                            z.settings.showdrawdots = 0;
                            z.settings.autoanalysis = 0;
                            z.settings.detailedanalysis = 0;
                            z.settings.analyzecourse = 0;
                            z.IsLive = 0;
                            if (z.playing) {
                              z.toggleplay();
                            }
                            z.request_redraw();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      z.update_routediv(false);
    });
  } else {
    if (xclight) {
      gcommands = "";
      gcommands =
        gcommands + '<input type="hidden" id="courseprofiletype" value=2>';
      gcommands =
        gcommands + '<input type="hidden" id="timegraphtype" value=3>';
      gcommands =
        gcommands + '<input type="hidden" id="graph_compare_winner" value=1>';
      gcommands += "<hr>";
      gcommands +=
        "<div style='padding-bottom:8px;font-size:14px;color:#006600;'><b>Save/load data</b></div>";
      gcommands +=
        "<button onclick='mapviewer.save_graph_plus_elevation();return false;'>Save Figure to file</button><br>";
      gcommands +=
        "<button onclick=\"mapviewer.open_dialog('savecourseserver',null);;return false;\">Save session to server</button><br>";
      gcommands +=
        "<button onclick=\"mapviewer.open_dialog('loadcourseserver',null);;return false;\">Load session from server</button><p>";
      gcommands +=
        "<hr><div style='padding-bottom:8px;font-size:14px;color:#006600;'><b>Virtual splits</b></div>";
      gcommands +=
        '<button onclick="mapviewer.calc_xc_splitpos(1)">Splits table detailed</button><br>';
      gcommands +=
        '<button onclick="mapviewer.calc_xc_splitpos(4)">Splits table simple</button>';
      gcommands +=
        '<button onclick="mapviewer.autogensplits()">Auto-splits</button><hr>';
      gcommands +=
        "<hr><div style='padding-bottom:8px;font-size:14px;color:#006600;'><b>Clear all data</b></div>";
      gcommands +=
        "<button onclick=\"window.open('?restart=1');\">Restart XCviewer Light</button><br>";
      gcommands +=
        "<hr><div style='padding-bottom:8px;font-size:14px;color:#006600;'><b>Advanced functions</b></div>";
      gcommands +=
        '<button onclick="mapviewer.saveCourse(null,null,1);return false;">Export session to file</button><br>';
      gcommands +=
        '<button onclick="mapviewer.saveCourse(null,null,0);return false;">Export course to file</button><br>';
      gcommands +=
        ' <button id="plot3d" onclick="mapviewer.exportgraphdata(2);">Export session to Excel</button><br>';
      gcommands +=
        ' <button id="plot3d" onclick="mapviewer.exportgraphdata(3);">3D plot</button><br>';
      gcommands +=
        "<button onclick='mapviewer.downloadimage_size(1,\"image.png\");return false;'>Save main Figure to file</button><p>";
      u += gcommands;
    } else {
      gcommands = "";
      gcommands =
        gcommands + "<hr><font size=1>Options for timeplots</font><br>";
      gcommands =
        gcommands +
        '<select id="graph_compare_winner" onChange=\'if ($("#graph_compare_winner").val()==0) {$("#cmplapnumber").prop("disabled", "disabled");} else {$("#cmplapnumber").prop("disabled", false);}\';> <option value=0>Compare to virtual leader</option> <option value=1 selected>Compare to selection</option></select>';
      var A = "";
      for (var j = 1; j < 20; j = j + 1) {
        var G = "";
        if (j == z.datafieldtypes_basic_avpoints[1]) {
          G = " selected ";
        }
        A +=
          "<option " +
          G +
          " value=" +
          j +
          ">Time averaging: " +
          j +
          " sec</option>";
      }
      gcommands =
        gcommands +
        '<select id="graph_time_averaging" onChange="mapviewer.datafieldtypes_basic_avpoints[1] = parseInt($(\'#graph_time_averaging\').val());for (var kk=0;kk<mapviewer.routes.length;kk++) {  mapviewer.routes[kk].calc_averages_course();}; mapviewer.plotgraphs();">' +
        A +
        "</select>";
      gcommands =
        gcommands +
        '<select id="timegraphtype"> <option value=0>No hillsegment info</option> <option value=2>Show hills with boxes</option> <option value=1>Show hills with columns 1</option> <option value=3 selected>Show hills with columns 2</option> </select>';
      gcommands =
        gcommands +
        '<select id="timegraphgridlines" onChange="mapviewer.plotgraphs();return(false);"> <option value=1>Show grid</option> <option value=0>Hide grid</option><option value=2>Only y-grid</option><option selected value=3>Only x-grid</option></select>';
      gcommands =
        gcommands +
        '<select id="timegraphfilled" onChange="mapviewer.plotgraphs();return(false);">  <option value=0>Only lines</option><option value=1>Fill under graph</option></select>';
      gcommands =
        gcommands +
        '<select id="timegraphlimit"> <option value=0>Show all losses</option> <option value=1>Text for &gt; 1 second</option> <option value=2 selected>Text for &gt; 2 second</option> <option value=3>Text for &gt; 3 second</option> <option value=4>Text for &gt; 4 second</option> <option value=5>Text for &gt; 5 second</option> <option value=10>Text for &gt; 10 second</option> <option value=20>Text for &gt; 20 second</option> <option value=100>Never show text</option> </select>';
      gcommands =
        gcommands +
        '<select id="courseprofiletype" onChange="mapviewer.plotgraphs();return(false);">  <option value=2>Standard HillProfile</option><option value=0>Simple HillProfile</option></select><br>';
      gcommands =
        gcommands +
        '<select id="courseprofilegrade" onChange="mapviewer.plotgraphs();return(false);">  <option value=0>No grade on HillProfile</option><option value=1>Grade on HillProfile</option></select><br>';
      gcommands =
        gcommands +
        ' <button onclick="mapviewer.doplotcoursegraph();return false;">Plot</button><br>';
      gcommands =
        gcommands +
        " <button onclick=\"$('#timegraphtype').val(1);$('#timegraphgridlines').val(0);$('#timegraphfilled').val(0);$('#timegraphlimit').val(2);mapviewer.doplotcoursegraph();return false;\">Preset 1</button><br>";
      gcommands =
        gcommands +
        " <button onclick=\"$('#timegraphtype').val(3);$('#timegraphgridlines').val(3);$('#timegraphfilled').val(0);$('#timegraphlimit').val(5);mapviewer.doplotcoursegraph();return false;\">Preset 2</button><br>";
      gcommands =
        gcommands +
        "<hr><font size=1>Write text on plot (experimental)</font><br>";
      gcommands =
        gcommands +
        '<select id="jqtextfront" onChange="mapviewer.togglegraphannotationlayer();return(false);"> <option value=0>Annotations in back</option> <option value=999999999>Annotate graph</option></select>';
      gcommands =
        gcommands +
        '<textarea onkeypress="return noenter()" id="addtextval"></textarea><br>';
      gcommands =
        gcommands +
        '<button onclick="mapviewer.deletealltxtonjqplot();return false;">Delete all text</button><br>';
      if (typeof saveppt == "undefined") {
        saveppt = 0;
      }
      gcommands = gcommands + "<hr><font size=1>Save graph to png</font><br>";
      gcommands =
        gcommands +
        "<input id=\"savefilename\" value=\"\"></input><br><button onclick=\"mapviewer.saveimage_size(1,$('#savefilename').val()+'.png');$('#savedfiles').val($('#savedfiles').val()+'\\n'+$('#savefilename').val()+'.png');\">Save Graph 1</button>";
      if (saveppt) {
        gcommands = gcommands + '<textarea id="savedfiles"></textarea><br>';
        gcommands =
          gcommands +
          '<button onclick="mapviewer.makeppt_fromtxtarea();">Make PPT</button><br>';
        gcommands =
          gcommands +
          "<button onclick=\"$('#savedfiles').val('Please wait ...');mapviewer.xc_savegraphs()\">Make autoanalysis (exp)</button><br><font size=1>Remember split routes by lap before autoanalysis to get all graphs!</font><br>";
        gcommands = gcommands + "<hr><font size=1>Statistics</font><br>";
        gcommands =
          gcommands + '<textarea rows=10 id="statdiv"></textarea><br>';
      } else {
        gcommands =
          gcommands +
          '<textarea style="display:none" id="savedfiles"></textarea><br>';
      }
      u += gcommands;
      u +=
        "<hr><button onclick=\"mapviewer.open_dialog('saveroutesandcourse',null);return false;\">Save routes and course</button>";
      u +=
        '<hr><button onclick="mapviewer.calc_xc_splitpos(1)">Splits table</button> <a href="javascript:void(0);" onclick="mapviewer.autogensplits()">ASplit</a>';
      u += '<hr><button onclick="mapviewer.calc_xc_splitpos(2)">S2</button>';
      u += ' <button onclick="mapviewer.calc_xc_splitpos(3)">S3</button>';
      u += ' <button onclick="mapviewer.calc_xc_splitpos(4)">S4</button>';
      var p =
        '<select id="select_maxpulseselector" onChange=\'mapviewer.settings.userelativepulse=parseInt($("#select_maxpulseselector").val());\'><option value=0>Abs HR</option><option value=1>Rel HR</option></select>';
      u +=
        "<hr><button onclick='mapviewer.plotupdownflat()'>Plot acc. up/down/flat</button>";
      u +=
        '<hr><button onclick="mapviewer.make_biathlon_results_table()">B</button><button onclick="mapviewer.make_biathlon_shoot_ppt()">AB</button>' +
        p +
        '<select id="biabetween"><option value="0">-</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select><br><select id="biastatsort"><option value="0">- Set Bia Stat Sort -</option><option value="0">Sort by athlete/lap</option><option value="Time_total">Time_total</option><option value="Time_shooting">Time_shooting</option><option value="Time_after">Time_after</option><option value="HR_before_range">HR_before_range</option><option value="HR_before_shooting">HR_before_shooting</option><option value="HR_after_shooting">HR_after_shooting</option></select>';
    }
    this.courseinfo.coursetype = "xc";
    this.settings.taillength = 5;
    xinfo = '<option value="calibrate">Backmap calibration</option>';
    if (xclight) {
      $("#" + this.toprightmenu).append(
        '<select style="display:none" id="selectmode"><option selected value="graph">Graph mode</option><option value="definecourse">Course & Route definition</option></select>'
      );
    } else {
      $("#" + this.toprightmenu).append(
        '<select id="selectmode"><option selected value="graph">Graph mode</option><option value="replay">Replay mode</option><option value="definecourse">Course & Route definition</option>' +
          xinfo +
          "</select>"
      );
    }
    $("#selectmode").change(function () {
      if ($("#selectmode").val() != "calibrate") {
        z.settings.calibrationmode = 0;
      }
      if ($("#selectmode").val() == "replay") {
        $("#playspeedr").show();
        $("#realtime").show();
        $("#playcontrol").show();
        $("#definecourseslider").hide();
        for (var O = 0; O < z.routes.length; O++) {
          z.routes[O].setlapstart(0, z.playtime);
        }
        z.settings.showInfoBelow = "";
        z.request_redraw();
        z.settings.coursedefinition_mode = 0;
        z.settings.mode = z.settings.modes.ReplayMode;
        z.settings.definecourse = 0;
        var M =
          "<b>Instructions</b><br>Click anywhere on the course to move all athletes to that point. Then click 'Play' to start. Click the key 'C' to auto-center on athlete while playing - the key 'B' to toggle which athlete the auto-centering works on.";
        M =
          M +
          "<p><font size=1>&raquo; <a href='javascript:void(0);' onclick='mapviewer.toggle_graphs();'>Graphs on/off</a> (graphs must first be set up in Graph mode)<br><br>";
        M =
          M +
          "<p>&raquo; <a href='javascript:void(0);' onclick='mapviewer.makelaproutes();'>Split routes by lap (Experimental)</a><br>";
        $("#" + z.infobottomdiv).html(M);
        $("#graphcontrol").hide();
        $("#xccoursecontrol").hide();
      } else {
        if ($("#selectmode").val() == "graph") {
          z.realtime = 0;
          $("#playspeedr").hide();
          $("#realtime").hide();
          $("#playcontrol").hide();
          z.settings.mode = z.settings.modes.GraphMode;
          z.settings.showdrawdots = 0;
          z.settings.autoanalysis = 0;
          z.settings.detailedanalysis = 0;
          z.settings.analyzecourse = 0;
          z.settings.definecourse = 0;
          $("#definecourseslider").hide();
          if (z.playing) {
            z.toggleplay();
          }
          z.request_redraw();
          z.settings.coursedefinition_mode = 0;
          z.settings.showInfoBelow = "CourseInfo";
          z.request_redraw();
          $("#graphcontrol").show();
          $("#xccoursecontrol").hide();
          $("#" + z.infobottomdiv).html(u);
        } else {
          if ($("#selectmode").val() == "definecourse") {
            $("#definecourseslider").show();
            $("#ShowCoursePoints").val(0);
            $("#course-slider").slider(
              "values",
              $("#course-slider").slider("values")
            );
            $("#playspeedr").hide();
            $("#realtime").hide();
            $("#playcontrol").hide();
            $("#graphcontrol").hide();
            $("#xccoursecontrol").show();
            z.routes[0].show = 1;
            for (var N = 1; N < z.routes.length; N++) {
              z.routes[N].show = 0;
            }
            z.settings.mode = z.settings.modes.AnalysisMode;
            z.settings.definecourse = 1;
            var M =
              "<font size=2><b>Instructions</b><br>Select part of a route using the <b>slider</b>, and click 'Define new course' when happy with the course. Check the course profile and that all laps are fitted for all athletes. Then proceed to 'Plot graph'</font>'";
            if (!xclight) {
              M =
                M +
                "<p>Biathlon definitions: <a href='javascript:void(0);' onclick='mapviewer.defpointoncourse_biathlon(\"intorange\");'>IR</a>  <a href='javascript:void(0);' onclick='mapviewer.defpointoncourse_biathlon(\"outofrange\");'>OR</a>  <a href='javascript:void(0);' onclick='mapviewer.defpointoncourse_biathlon(\"afterpenalty\");'>AP</a> <a href='javascript:void(0);' onclick='mapviewer.defpointoncourse_biathlon(\"inpenalty\");'>IP</a> <a href='javascript:void(0);' onclick='mapviewer.defpointoncourse_biathlon(\"beforerange\");'>BR</a> <br><div style=\"margin:8px;font-size:8px;\" id=\"biathlon_defpoints\"></div>";
            }
            if (xclight) {
              M =
                M +
                "<p><button onclick=\"$('#selectmode').val('graphmode');$('#selectmode').change();mapviewer.close_dialog();return false\"  id=\"plotgraph_button2\">Plot graph</button><p>";
            }
            M =
              M +
              "<p><a href='javascript:void(0);' onclick='mapviewer.ploteleprofile_popup_scaled()'>Print eleprofile with grades</a>";
            $("#" + z.infobottomdiv).html(M);
            z.settings.showInfoBelow = "";
            z.request_redraw();
            z.coursefittoggle(0);
          } else {
            if ($("#selectmode").val() == "calibrate") {
              z.settings.calibrationmode = 1;
              z.setup_start_recalibration();
              z.Draw_all_full_routes(0);
              z.settings.showInfoBelow = "";
              $("#definecourseslider").hide();
              $("#playspeedr").hide();
              $("#realtime").hide();
              $("#playcontrol").hide();
              $("#graphcontrol").hide();
              $("#xccoursecontrol").show();
              z.routes[0].show = 1;
              for (var N = 1; N < z.routes.length; N++) {
                z.routes[N].show = 0;
              }
              z.settings.definecourse = 0;
              z.settings.mode = z.settings.modes.CalibrationMode;
            }
          }
        }
      }
      z.update_routediv(false);
    });
  }
  if (!isnarrowscreen) {
    $("#" + this.toprightmenu).append(
      '<select id="playspeedr"><option value="1">1x</option><option value="2">2x</option><option value="3">3x</option><option value="4">4x</option><option value="5">5x</option><option value="6">6x</option><option selected value="10">10x</option><option value="20">20x</option><option value="50">50x</option></select>'
    );
    $("#" + this.toprightmenu).append(
      '<select id="realtime"><option value="off">RealTime off</option><option value="on">RealTime on</option></select>'
    );
    $("#playspeedr").change(function () {
      z.play_speed = parseInt($("#playspeedr").val());
      if (isNaN(z.play_speed)) {
        z.play_speed = 10;
      }
      z.reset_replaystarttime();
    });
    $("#realtime").change(function () {
      if (!z.realtime) {
        z.Routes_set_realtime();
        z.realtime = 1;
      } else {
        for (var M = 0; M < z.routes.length; M++) {
          z.routes[M].offset = 0;
        }
        z.update_routediv(false);
        z.request_redraw();
        z.realtime = 0;
      }
      z.request_redraw();
    });
    $("#" + this.toprightmenu).append('<br><div id="playcontrol"></div>');
    $("#" + this.toprightmenu).append(
      '<div id="graphcontrol" style="display:none"></div>'
    );
    $("#" + this.toprightmenu).append(
      '<div id="xccoursecontrol" style="display:none"></div>'
    );
    $("#" + this.toprightmenu).append(
      '<div id="canalysis" style="font-size:10px;display:none"></div>'
    );
    this.addbutton("playcontrol", "backr", "<");
    $("#backr").bind("click", function (M, N) {
      z.playtime -= 60;
      z.reset_replaystarttime();
      z.request_redraw();
    });
    this.addbutton("playcontrol", "playr", "Play/Pause");
    $("#playr").bind("click", function (M, N) {
      z.toggleplay();
    });
    this.addbutton("playcontrol", "forwr", ">");
    $("#forwr").bind("click", function (M, N) {
      z.playtime += 60;
      z.reset_replaystarttime();
      z.request_redraw();
    });
    var B = "";
    if (z.settings.showdrawdots) {
      B = "checked";
    }
    $("#playcontrol").append(
      '<input type="checkbox" ' +
        B +
        ' id="replaydots" title="Select for dotmode">'
    );
    $("#replaydots").bind("click", function (M, N) {
      if ($("#replaydots").is(":checked")) {
        z.settings.showdrawdots = 1;
        z.reset_taillengths();
      } else {
        z.settings.showdrawdots = 0;
      }
      z.request_redraw();
    });
    this.addbutton(this.toprightmenu, "autobutton", "Calculate AutOanalysis");
    $("#autobutton").hide();
    $("#autobutton").bind("click", function (M, N) {
      z.AutOanalysis();
    });
    $("#autobutton").attr("title", help.autoanalysis_button);
    $("#" + z.toprightmenu).append(
      '<div id="autoanalysis_adjust"><b>Adjust:</b> <select id="autoanalysis_adjust_ch"><option selected value="0">None</option><option value="1">By same route</option><option value="2">By all route</option><option value="3">Show different</option><option value="4">Show significant</option><option value="5">Show significant+</option><option value="6">Show pace (exp)</option><option value="7">Show pacetxt (exp)</option></select></div>'
    );
    $("#" + z.toprightmenu).append(
      '<div id="detailedanalysis_settings">Detailed analysis options</div>'
    );
    $("#" + z.toprightmenu).append(
      '<div id="autoanalysis_adjust2" style="display:none;"><b>Show:</b> <select id="autoanalysis_adjust_ch2"><option value="lg-15">Loss/Gain>15 s</option><option selected value="lg-30">Loss/Gain>30 s</option><option  value="lg-60">Loss/Gain>60 s</option><option  value="lg-90">Loss/Gain>90 s</option><option  value="lg-120">Loss/Gain>120 s</option><option  value="l-15">Loss>15 s</option><option  value="l-30">Loss>30 s</option><option  value="l-60">Loss>60 s</option><option  value="l-90">Loss>90 s</option><option  value="l-120">Loss>120 s</option><option  value="g-15">Gain>15 s</option><option  value="g-30">Gain>30 s</option><option  value="g-60">Gain>60 s</option><option  value="g-90">Gain>90 s</option><option  value="g-120">Gain>120 s</option></select></div>'
    );
    $("#autoanalysis_adjust").hide();
    $("#detailedanalysis_settings").hide();
    $("#autoanalysis_adjust_ch").change(function () {
      z.settings.autoanalysis_adjusted = parseInt(
        $("#autoanalysis_adjust_ch").val()
      );
      if (
        z.settings.autoanalysis_adjusted >= 4 &&
        z.settings.autoanalysis_adjusted <= 5
      ) {
        $("#autoanalysis_adjust2").show();
      } else {
        $("#autoanalysis_adjust2").hide();
      }
      z.request_redraw();
    });
    $("#autoanalysis_adjust_ch2").change(function () {
      z.request_redraw();
    });
    this.updateinfobottomdiv();
  } else {
    $("#" + this.toprightmenu).append('<div id="playcontrol"></div>');
    this.addbutton(this.toprightmenu, "autobutton", "Calculate AutOanalysis");
    $("#autobutton").hide();
    $("#autobutton").bind("click", function (M, N) {
      z.AutOanalysis();
    });
    $("#autobutton").attr("title", help.autoanalysis_button);
    this.updateinfobottomdiv();
  }
  if (xc) {
    $("#playspeedr").hide();
    $("#realtime").hide();
    $("#playcontrol").hide();
    $("#graphcontrol").show();
    z.settings.mode = z.settings.modes.GraphMode;
    z.settings.showdrawdots = 0;
    z.settings.autoanalysis = 0;
    z.settings.detailedanalysis = 0;
    z.settings.analyzecourse = 0;
    var I = z.xcmenu();
    $("#graphcontrol").html(I);
    z.settings.drawsmoothlines = 1;
    z.settings.showcourse = 2;
    accuracy =
      ' <select id="AutoCourseSep"><option value="2">ca. 2 m</option><option value="5">ca. 5 m</option><option selected value="10">ca. 10 m</option><option value="15">ca. 15 m</option><option value="20">ca. 20 m</option><option value="25">ca. 25 m</option><option value="30">ca. 30 m</option><option value="40">ca. 40 m</option><option value="50">ca. 50 m</option><option value="100">ca. 100 m</option><option value="1000">ca. 1000 m</option></select>';
    if (xclight) {
      accuracy = ' <input type="hidden" id="AutoCourseSep" value="10">';
    }
    $("#definecourseslider").html(
      "<div id=\"course-slider\"></div><p><center><button id='definecoursebutton' onclick='mapviewer.auto_makecourse(1);mapviewer.snaproutestocourse();mapviewer.update_routediv(false);'>Define course from route</button>" +
        accuracy +
        ' <button id=\'definecoursebutton\' onclick=\'mapviewer.courseeditor_start();\'>Course editor</button> <select onChange="mapviewer.settings.coursedefinition_mode=parseInt($(\'#ShowCoursePoints\').val());mapviewer.coursefittoggle(0);mapviewer.request_redraw();" id="ShowCoursePoints"><option selected value="0">Course definition mode</option><option value="1">Coursefit check laps</option><option value="2">Coursefit check failed</option><option value="3">Route edit mode</option></select> <div style="display:inline" id="coursefitdata"><div style="display:inline;background:#ffffff;padding-left:20px;padding-right:20px;" id="coursefitinfo"></div><button onclick="mapviewer.coursefittoggle(1);">Compare next lap/route</button><button id="courserefit" onclick="mapviewer.refit();mapviewer.snaproutestocourse();mapviewer.request_redraw();$(\'#courserefit\').hide();">Refit routes to modified course</button></div> <select onChange="mapviewer.routeedit_changemode();" id="routeedit_select" style="display:none"><option value="3">Straight-line part</option><option selected value="1">Remove part</option><option value="2">Move points</option></select> <div id="routeedit_execute" style="display:inline"><div id="routeedit_select_part1" style="display:inline"><button onclick="mapviewer.trimroute();">Trim shown (shortens time, no undo!)</button></div><div id="routeedit_select_part2" style="background:white;border:1px solid black;padding:2px;font-size:10px;display:none">Use SHIFT to move points</div><div id="routeedit_select_part3" style="display:none"><button onclick="mapviewer.straightroute_part();">Interpolate to straight (no undo!)</button></div></div><button onclick="$(\'#selectmode\').val(\'graphmode\');$(\'#selectmode\').change();mapviewer.close_dialog();return false"  id="plotgraph_button">Plot graph</button></center>'
    );
    $("#course-slider").slider({
      range: true,
      min: 0,
      max: 10000,
      values: [0, 1000],
      change: function (M, N) {
        z.setcourseslider(N);
      },
      slide: function (M, N) {
        z.setcourseslider(N);
      },
    });
    $("#" + z.infobottomdiv).html(u);
    $("#courseprofiletype").val(z.courseinfo.coursecolortype);
    $("#courseprofilegrade").val(parseInt(z.settings.courseprofileshowgrade));
    $("#xccoursecontrol").html("");
  } else {
    $("#graphcontrol").hide();
    var I = z.xcmenu();
    $("#graphcontrol").html(I);
    $("#canalysis").html(z.make_canalysis_div());
  }
  if (isinternetexplorer) {
    bindEvent(
      document,
      "keydown",
      function (M) {
        z.onkeypress(M);
      },
      true
    );
  } else {
    bindEvent(
      window,
      "keydown",
      function (M) {
        z.onkeypress(M);
      },
      true
    );
  }
  this.canvas = new Canvas(F);
  m = this.canvas;
  if (xc) {
    $("#selectgraph-1").val(1);
    $("#selectgraph-2").val(4);
    $("#selectgraph-3").val(0);
    $("#selectgraph-4").val(0);
    z.showBelowFactor = -3;
    z.canvas.width = z.canvas.width - 1;
  }
  this.map = new Mapp();
  this.maps[0] = this.map;
  m.onmouseup = function (N, R, Q, M) {
    var O = new Date().getTime() - z.canvas.starttime_mousemove;
    if (
      O < 250 &&
      z.canvas.distance_px_mousemove < 50 &&
      z.canvas.distance_px_mousemove > 0
    ) {
      m.onmouseclick(N, R, Q);
      z.canvas.context.translate(-z.canvas.dragged_x, -z.canvas.dragged_y);
      z.request_redraw();
    }
    if (mapviewer.settings.is_sketching_mousedown) {
      mapviewer.settings.is_sketching_mousedown = 0;
      mapviewer.settings.is_sketching = 0;
      mapviewer.updateinfobottomdiv();
      return;
    }
    if (Q >= 3) {
      z.settings.movetagnum = null;
      if (0) {
        if (z.settings.movetagnum >= 0) {
          z.tags[z.settings.movetagnum].offsettxt_basex =
            z.tags[z.settings.movetagnum].offsettxt_x;
          z.tags[z.settings.movetagnum].offsettxt_basey =
            z.tags[z.settings.movetagnum].offsettxt_y;
        }
        z.settings.movetagnum = null;
      }
      if (
        z.settings.legendtype == z.settings.modes.SingleLegend ||
        z.settings.legendtype == z.settings.modes.SingleLegend2 ||
        z.settings.legendtype == z.settings.modes.SingleLegend3
      ) {
        if (z.settings.legendroutenum >= 0) {
          z.routes[z.settings.legendroutenum].legendoffset_basex =
            z.routes[z.settings.legendroutenum].legendoffset_x;
          z.routes[z.settings.legendroutenum].legendoffset_basey =
            z.routes[z.settings.legendroutenum].legendoffset_y;
        }
      } else {
        z.settings.legendoffset_basex = z.settings.legendoffset_x;
        z.settings.legendoffset_basey = z.settings.legendoffset_y;
      }
      z.visualize_point = null;
      z.request_redraw();
      z.settings.legendroutenum = -1;
    }
    z.highlight_route(-1);
    z.update_routediv(false);
    z.request_redraw();
    if (mapviewer.waitfordrag == 1) {
      mapviewer.waitfordrag_finishfunction();
      return;
    }
    if (0) {
      if (!M && istouchscreen && !z.playing) {
        m.onmouseclick(N, R, Q);
        z.request_redraw();
      } else {
        if (!M && istouchscreen && z.playing) {
          m.onmouseclick(N, R, Q);
          z.request_redraw();
        }
      }
    }
  };
  this.onkeypress = function (M) {
    z.keypress(M);
  };
  this.keypress = function (W) {
    if (W.keyCode == 27) {
      mapviewer.waitfordrag_dragging = 0;
      mapviewer.waitfordrag_dragpoint = null;
      mapviewer.waitfordrag = 0;
      z.request_redraw();
    }
    if (!W.keyCode) {
      tmpevt = W;
      keyCode = W.charCodeAt(0);
      W = new Object();
      W.keyCode = keyCode;
      W.shiftKey = tmpevt.shiftKey;
      W.altKey = tmpevt.altKey;
      W.ctrlKey = tmpevt.ctrlKey;
      W.metaKey = tmpevt.metaKey;
      W.preventDefault = function () {};
    }
    var Q = z.dialogbox.dialog("isOpen");
    if ($(W.target).is("input, textarea")) {
      return;
    }
    if (!Q) {
      if (
        W.keyCode >= 16 &&
        W.keyCode <= 18 &&
        (W.shiftKey || W.altKey || W.ctrlKey || W.metaKey)
      ) {
      }
      if (z.settings.runningwild) {
        if (
          !z.settings.orunningwild.finished &&
          W.keyCode == "R".charCodeAt(0)
        ) {
          z.runningwild_finished();
        } else {
          if (
            !z.settings.orunningwild.finished &&
            W.keyCode == "A".charCodeAt(0)
          ) {
            if (z.settings.orunningwild.autorotate) {
              z.settings.orunningwild.autorotate = 0;
            } else {
              z.settings.orunningwild.autorotate = 1;
            }
            var R = z.canvas.rotate_angle;
            z.canvas.context.rotate(-R);
            z.request_redraw();
          } else {
            if (
              !z.settings.orunningwild.finished &&
              W.keyCode == "C".charCodeAt(0)
            ) {
              if (z.settings.orunningwild.center) {
                z.settings.orunningwild.center = 0;
              } else {
                z.settings.orunningwild.center = 1;
              }
            } else {
              if (W.keyCode == 38) {
              } else {
                if (W.keyCode == 40) {
                } else {
                  if (W.keyCode == 37) {
                  } else {
                    if (W.keyCode == 39) {
                    } else {
                      if (W.keyCode == 187) {
                        z.canvas.zoom(1, "key");
                      } else {
                        if (W.keyCode == 189) {
                          z.canvas.zoom(-1, "key");
                        } else {
                          if (W.keyCode == "8".charCodeAt(0) && W.shiftKey) {
                            z.increaserouteopacity();
                          } else {
                            if (W.keyCode == "9".charCodeAt(0) && W.shiftKey) {
                              z.reducerouteopacity();
                            } else {
                              if (W.keyCode == "8".charCodeAt(0)) {
                                W.preventDefault();
                                z.settings.mapopacity =
                                  z.settings.mapopacity - 0.1;
                                if (z.settings.mapopacity < 0) {
                                  z.settings.mapopacity = 0;
                                }
                                z.request_redraw();
                              } else {
                                if (W.keyCode == "9".charCodeAt(0)) {
                                  W.preventDefault();
                                  z.settings.mapopacity =
                                    z.settings.mapopacity + 0.1;
                                  if (z.settings.mapopacity > 1) {
                                    z.settings.mapopacity = 1;
                                  }
                                  z.request_redraw();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (!W.shiftKey && !W.altKey && !W.ctrlKey && !W.metaKey) {
          switch (W.keyCode) {
            case 187:
              z.canvas.zoom(1, "key");
              break;
            case 107:
              z.canvas.zoom(1, "key");
              break;
            case 171:
              z.canvas.zoom(1, "key");
              break;
            case 189:
              z.canvas.zoom(-1, "key");
              break;
            case 109:
              z.canvas.zoom(-1, "key");
              break;
            case 173:
              z.canvas.zoom(-1, "key");
              break;
            case "-".charCodeAt(0):
              z.canvas.zoom(-1, "key");
              break;
            case "+".charCodeAt(0):
              z.canvas.zoom(1, "key");
              break;
            case 38:
              z.canvas.context.translate(0, 10);
              z.request_redraw();
              W.preventDefault();
              break;
            case 40:
              z.canvas.context.translate(0, -10);
              z.request_redraw();
              W.preventDefault();
              break;
            case 37:
              z.canvas.context.translate(10, 0);
              z.request_redraw();
              W.preventDefault();
              break;
            case 39:
              z.canvas.context.translate(-10, 0);
              z.request_redraw();
              W.preventDefault();
              break;
            case 80:
              z.toggleplay();
              break;
            case 76:
              if (this.settings.mapreadingmode) {
                z.settings.routewidthmapreading++;
              } else {
                z.settings.routewidth++;
                z.map.markerRadius = Math.round(z.settings.routewidth / 4) + 2;
              }
              z.request_redraw();
              z.updateinfobottomdiv();
              break;
            case 75:
              if (this.settings.mapreadingmode) {
                z.settings.routewidthmapreading--;
                if (z.settings.routewidthmapreading < 1) {
                  z.settings.routewidthmapreading = 1;
                }
              } else {
                z.settings.routewidth--;
                z.map.markerRadius--;
                if (z.settings.routewidth < 1) {
                  z.settings.routewidth = 1;
                }
                z.map.markerRadius = Math.round(z.settings.routewidth / 4) + 2;
                if (z.map.markerRadius < 1) {
                  z.map.markerRadius = 1;
                }
              }
              z.request_redraw();
              z.updateinfobottomdiv();
              break;
            case 88:
              if (z.showallinfo == 0) {
                z.showallinfo = 1;
                z.updateinfobottomdiv();
              } else {
                z.showallinfo = 0;
                z.updateinfobottomdiv();
              }
              z.update_routediv(true);
              break;
            case 79:
              if (!z.realtime) {
                z.Routes_set_realtime();
                $("#realtime").val("on");
              } else {
                for (var N = 0; N < z.routes.length; N++) {
                  z.routes[N].offset = 0;
                }
                z.update_routediv(false);
                z.request_redraw();
                z.realtime = 0;
                $("#realtime").val("off");
              }
              z.request_redraw();
              break;
            case 84:
              z.settings.taillength = z.settings.taillength + 10;
              z.reset_taillengths();
              z.updateinfobottomdiv();
              z.request_redraw();
              break;
            case "A".charCodeAt(0):
              z.change_legendtype(1);
              break;
            case "S".charCodeAt(0):
              W.preventDefault();
              z.open_dialog("savestate", null);
              break;
            case "8".charCodeAt(0):
              W.preventDefault();
              z.settings.mapopacity = z.settings.mapopacity - 0.1;
              if (z.settings.mapopacity < 0) {
                z.settings.mapopacity = 0;
              }
              z.request_redraw();
              z.updateinfobottomdiv();
              break;
            case "9".charCodeAt(0):
              W.preventDefault();
              z.settings.mapopacity = z.settings.mapopacity + 0.1;
              if (z.settings.mapopacity > 1) {
                z.settings.mapopacity = 1;
              }
              z.request_redraw();
              z.updateinfobottomdiv();
              break;
            case 82:
              z.settings.taillength = z.settings.taillength - 10;
              if (z.settings.taillength <= 0) {
                z.settings.taillength = -1;
              }
              z.reset_taillengths();
              z.updateinfobottomdiv();
              z.request_redraw();
              break;
            case "Z".charCodeAt(0):
              z.togglerightmenu("togglerightmenu");
              break;
            case "M".charCodeAt(0):
              if (!z.IsLive) {
                z.playtime += 10;
                z.reset_replaystarttime();
                z.request_redraw();
              }
              break;
            case "N".charCodeAt(0):
              if (!z.IsLive) {
                z.playtime -= 10;
                z.reset_replaystarttime();
                z.request_redraw();
              }
              break;
            case "C".charCodeAt(0):
              if (z.center_map_on_runner == 0) {
                z.center_map_on_runner = 1;
              } else {
                z.center_map_on_runner = 0;
              }
              z.request_redraw();
              z.updateinfobottomdiv();
              break;
            case "V".charCodeAt(0):
              z.centernextroute(-1);
              break;
            case "H".charCodeAt(0):
              z.open_videodialog("Play video", null);
              break;
            case "B".charCodeAt(0):
              z.centernextroute(1);
              break;
            case "Y".charCodeAt(0):
              if (this.IsLive) {
                this.IsLive = 0;
              } else {
                this.startLive();
              }
              break;
            case "F".charCodeAt(0):
              if (this.PanTimeFactor < 16) {
                this.PanTimeFactor = this.PanTimeFactor * 2;
              } else {
                this.PanTimeFactor = 1;
              }
              break;
            case "G".charCodeAt(0):
              if (z.settings.mapreadingmode) {
                z.settings.routewidth = 7;
                z.map.markerRadius = 5;
                z.settings.mapreadingmode = 0;
              } else {
                z.settings.routewidth = 2;
                z.map.markerRadius = 5;
                z.settings.mapreadingmode = 1;
              }
              break;
            case "Q".charCodeAt(0):
              if (z.settings.showInfoBelow != "Splitsbrowser") {
                z.settings.showInfoBelow = "Splitsbrowser";
                if (!$("#splitsbrowser")) {
                  $("#graphholder").html(
                    '<canvas id="splitsbrowser"></canvas>'
                  );
                }
                if (!Segment_to_SplitsBrowser()) {
                  z.open_dialog(
                    "No data to plot",
                    "No autOanalysis data to make SplitsBrowser from!",
                    1
                  );
                }
              } else {
                z.settings.showInfoBelow = false;
                z.request_redraw();
              }
              break;
            case "0".charCodeAt(0):
              z.Draw_all_full_routes(1);
              break;
            case "1".charCodeAt(0):
              z.Draw_pace_graph();
              break;
            case "2".charCodeAt(0):
              z.OpenSettings();
              break;
            case "3".charCodeAt(0):
              z.toggleColormode(1);
              break;
            case "7".charCodeAt(0):
              if (z.settings.tagmode == 0) {
                z.settings.tagmode = 1;
                z.settings.showtagmode = 1;
                z.currenttag = null;
                z.request_redraw();
                z.settings.infotxt = "Annotation mode - point";
                alert("Start annotation mode - point");
              } else {
                if (z.settings.tagmode == 1) {
                  z.settings.tagmode = 2;
                  z.settings.showtagmode = 1;
                  z.currenttag = null;
                  z.request_redraw();
                  z.settings.infotxt = "Annotation mode - segment";
                  alert("Start annotation mode - segment");
                } else {
                  if (z.settings.tagmode == 2) {
                    z.settings.tagmode = 3;
                    z.settings.showtagmode = 1;
                    z.currenttag = null;
                    z.request_redraw();
                    z.settings.infotxt = "";
                    alert(
                      "Start annotation mode - new route. Draw a route using the left mouse button. Delete a point by holding shift while clicking left mouse button. Finish route by holding alt while clicking left mouse button."
                    );
                  } else {
                    z.settings.tagmode = 0;
                    z.currenttag = null;
                    z.request_redraw();
                    alert("Stop annotation mode");
                    z.settings.infotxt = "";
                  }
                }
              }
              break;
            case "6".charCodeAt(0):
              if (z.settings.showtagmode == 0) {
                z.settings.showtagmode = 1;
              } else {
                z.settings.showtagmode = 0;
              }
              z.request_redraw();
              break;
            case "5".charCodeAt(0):
              z.Show_tag_all_overview();
              break;
            case "4".charCodeAt(0):
              z.Show_tag_segment_overview();
              break;
            case "W".charCodeAt(0):
              W.preventDefault();
              z.Show_splits_overview();
              break;
          }
        } else {
          if (W.shiftKey) {
            if (W.keyCode == "T".charCodeAt(0)) {
            }
            if (W.keyCode == "E".charCodeAt(0)) {
              z.showeleprofiles(0);
            }
            if (W.keyCode == "F".charCodeAt(0)) {
              if (document.webkitFullscreenElement) {
                document.webkitExitFullscreen();
              } else {
                document.documentElement.webkitRequestFullScreen();
              }
            }
            if (W.keyCode == "1".charCodeAt(0)) {
              mapviewer.settings.showInfoBelow = "";
              $("#graphholder").hide();
              mapviewer.request_redraw();
            }
            if (W.keyCode == "8".charCodeAt(0)) {
              z.increaserouteopacity();
            }
            if (W.keyCode == "9".charCodeAt(0)) {
              z.reducerouteopacity();
            }
            if (W.keyCode == "3".charCodeAt(0)) {
              z.toggleColorAnalysismode(1);
            }
            if (W.keyCode == "P".charCodeAt(0)) {
              if (this.settings.makeprettylines) {
                mapviewer.settings.minbezierlength =
                  mapviewer.settings.minbezierlength * 2;
                if (mapviewer.settings.minbezierlength > 300) {
                  mapviewer.settings.minbezierlength = 15;
                  this.settings.makeprettylines = 0;
                  alert("Setting prettylines to 0");
                }
                z.request_redraw();
              } else {
                this.settings.makeprettylines = 1;
                z.request_redraw();
              }
            }
            if (W.keyCode == "R".charCodeAt(0)) {
              var M = -1;
              var U = -1;
              if (z.routes) {
                for (var N = 0; N < z.routes.length; N++) {
                  if (z.routes[N].show) {
                    M = N;
                    userouteid = z.routes[N].id;
                    useroutename = z.routes[N].runnername;
                    N = z.routes.length + 1;
                  }
                }
              }
              var X = z.map.id;
              if (M >= 0 && X != 0) {
                W.preventDefault();
                z.open_dialog(
                  "Recalibrate map",
                  "Click 'Recalibrate map' below to recalibrate the current map using the first shown route (" +
                    useroutename +
                    ")<p><form action=\"index.php\"><input type=hidden name='id' value='" +
                    X +
                    "," +
                    userouteid +
                    "'><input type=hidden name='a' value='recalibrate'><input type='submit' value='Recalibrate map'></form>",
                  0
                );
              } else {
                alert("Could not recalibrate map. Missing map or route.");
              }
            }
            if (W.keyCode == "W".charCodeAt(0)) {
              if (!z.settings.sketchmode) {
                z.sketchmode_toggle();
              }
              z.sketchmode_startstopsketch();
            }
            if (W.keyCode == "S".charCodeAt(0)) {
              W.preventDefault();
              z.startsaverw();
            }
            if (W.keyCode == "C".charCodeAt(0)) {
              W.preventDefault();
              z.open_dialog("savecourse", null);
            }
            if (W.keyCode == "M".charCodeAt(0)) {
              W.preventDefault();
              if (z.settings.modifyroutes) {
                z.settings.modifyroutes = 0;
              } else {
                z.settings.modifyroutes = 1;
                for (var N = 0; N < z.routes.length; N++) {
                  z.routes[N].modifyroute_stablepoints = new Array();
                }
              }
            }
            if (W.keyCode == "H".charCodeAt(0)) {
              W.preventDefault();
              if (!this.settings.drawsmoothlines) {
                this.settings.drawsmoothlines = 1;
                this.settings.splitlaps_outside_distance = 21;
                this.settings.splitlaps_inside_distance = 10;
              } else {
                this.settings.drawsmoothlines = 0;
                this.settings.splitlaps_outside_distance = 51;
                this.settings.splitlaps_inside_distance = 30;
              }
              z.request_redraw();
            }
            if (W.keyCode == "J".charCodeAt(0)) {
              W.preventDefault();
              var S = z.xcmenu();
              $("#" + z.infobottomdiv).html(S);
              $("#" + z.infobottomdiv).append(
                '&raquo; <a href="javascript:void(0);" onclick="mapviewer.auto_makecourse(1)">Make auto-course</a><br>&raquo; <a href="javascript:void(0);" onclick="mapviewer.add_dragdrop()">Enable drag/drop</a><br>&raquo; <a href="javascript:void(0);" onclick="mapviewer.settings.showcourse=0;">Hide course</a><br>&raquo; <a href="javascript:void(0);" onclick="mapviewer.settings.showpulse_map=1;">Show pulse on play</a><br>&raquo; <a href="javascript:void(0);" onclick="mapviewer.savemistakes();">Print mistake figures</a><br>&raquo; <a href="javascript:void(0);" onclick="mapviewer.savesplitanalysis();">Print splitanalysis figures</a><p>'
              );
            }
            if (W.keyCode == "D".charCodeAt(0)) {
              if (z.settings.tagging_deletemode) {
                z.settings.tagging_deletemode = 0;
                alert("No longer deleting tags");
              } else {
                z.settings.tagging_deletemode = 1;
                alert("Now deleting tags");
              }
            }
            if (W.keyCode == "A".charCodeAt(0)) {
              z.autoname_tags();
            }
            if (W.keyCode == "X".charCodeAt(0)) {
              if (mapviewer.settings.enableprintscreen) {
                mapviewer.savecompletemap();
              } else {
                alert("Could not save - printscreen not enabled!");
              }
            }
            if (W.keyCode == "B".charCodeAt(0)) {
              if (z.settings.variants_showmode) {
                z.settings.variants_showmode = 0;
                alert("Normal mode");
              } else {
                z.settings.variants_showmode = 1;
                alert(
                  "Showing only runners not assigned to a variant for this split"
                );
              }
            }
            if (W.keyCode == "L".charCodeAt(0)) {
              mapviewer.analysislog_entry();
            } else {
              if (W.keyCode == 38) {
                var T = 100;
                z.settings.centerlegnum = parseInt(z.settings.centerlegnum);
                var O =
                  "leg_" +
                  parseInt(z.settings.centerlegnum).toFixed().pad(2, "0") +
                  "_.png";
                z.settings.isprinting = 1;
                console.log("Zoom for save: " + parseFloat(T / 100));
                z.savearea_zoom(parseFloat(T / 100), O);
                z.settings.isprinting = 0;
              } else {
                if (W.keyCode == 40) {
                  if (!z.settings.printtype) {
                    z.settings.printtype = 0;
                  }
                  z.settings.printtype++;
                  if (z.settings.printtype > 6) {
                    z.settings.printtype = 1;
                  }
                  if (z.settings.printtype == 1) {
                    z.showroutes(0);
                  }
                  if (z.settings.printtype == 2) {
                    z.showroutes(3);
                  } else {
                    if (z.settings.printtype == 3) {
                      z.showroutes(6);
                    } else {
                      if (z.settings.printtype == 4) {
                        z.showroutes(10);
                      } else {
                        if (z.settings.printtype == 5) {
                          z.showroutes(999);
                        } else {
                          if (z.settings.printtype == 6) {
                            mapviewer.toggle_autoselect();
                          }
                        }
                      }
                    }
                  }
                  z.recolorbysplit();
                } else {
                  if (W.keyCode == 39 || W.keyCode == 37) {
                    var V = z.settings.centerlegnum;
                    if (W.keyCode == 39) {
                      V++;
                    } else {
                      V--;
                    }
                    if (V >= z.coursecoords.length) {
                      V = 1;
                    }
                    z.settings.centerlegnum = V;
                    z.centerleg_frominput(V);
                  } else {
                    if (W.keyCode == 187) {
                      z.canvas.zoom(0.05, "key");
                    } else {
                      if (W.keyCode == 189) {
                        z.canvas.zoom(-0.05, "key");
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (W.ctrlKey || W.metaKey) {
              if (W.keyCode == "Q".charCodeAt(0)) {
                if (!z.is_save_animation) {
                  z.start_save_animation();
                  if (!z.playing) {
                    z.toggleplay();
                  }
                } else {
                  z.stop_save_animation();
                  if (z.playing) {
                    z.toggleplay();
                  }
                }
              }
              if (W.keyCode == "A".charCodeAt(0)) {
                z.canvas.outlinetxtsize++;
                if (z.canvas.outlinetxtsize > 50) {
                  z.canvas.outlinetxtsize = 10;
                }
                z.request_redraw();
              }
              if (W.keyCode >= 37 && W.keyCode <= 40) {
                timechange = 0;
                if (W.keyCode == 38) {
                  timechange = 5;
                } else {
                  if (W.keyCode == 40) {
                    timechange = -5;
                  } else {
                    if (W.keyCode == 37) {
                      timechange = -1;
                    } else {
                      if (W.keyCode == 39) {
                        timechange = 1;
                      }
                    }
                  }
                }
                if (timechange != 0) {
                  z.currenttime_delta += timechange;
                  if (z.currenttime_delta < 0) {
                    z.currenttime_delta = 0;
                  }
                  z.request_redraw();
                  z.updateinfobottomdiv();
                }
              }
            } else {
              if (W.altKey) {
              }
            }
          }
        }
      }
    }
  };
  this.lengthtab = function () {
    z = mapviewer;
    var ad = "";
    ad = ad + "Leg;Length (m);Shortest variant;Length shortest (m)\n";
    for (var ae = 1; ae < z.coursecoords.length; ae++) {
      ad = ad + ae + ";";
      lstr = "";
      sstr = "";
      shortest = 1e99;
      var X = z.coursecoords[ae - 1];
      if (!X) {
      }
      var V = X.split(",");
      var S = V[0];
      var ac = V[1];
      var X = z.coursecoords[ae];
      if (!X) {
      } else {
      }
      if (X) {
        var V = X.split(",");
        var ag = V[0];
        var U = V[1];
        for (var O = 0; O < z.tags.length; O++) {
          var W = z.tags[O];
          if (W.type == "route") {
            var aa = W.pointsxy;
            if (aa) {
              if (aa.length > 0) {
                var X = aa[0];
                var V = X.split(",");
                var R = V[0];
                var N = V[1];
                var X = aa[aa.length - 1];
                var V = X.split(",");
                var ah = V[0];
                var af = V[1];
                var ab = (R - S) * (R - S) + (N - ac) * (N - ac);
                var Z = (ah - ag) * (ah - ag) + (af - U) * (af - U);
                if (ab < 800 && Z < 800) {
                  lstr = lstr + W.name + ";" + Math.round(W.length) + ";";
                  if (W.length < shortest) {
                    shortest = W.length;
                    sstr = W.name + ";" + Math.round(W.length) + ";";
                  }
                } else {
                }
              }
            }
          }
        }
      }
      tmp = z.coursecoords[ae - 1].split(",");
      var T = z.map.tolatlng(tmp[0], tmp[1]);
      tmp = z.coursecoords[ae].split(",");
      var Q = z.map.tolatlng(tmp[0], tmp[1]);
      var M = calcdistance(T.lat, T.lng, Q.lat, Q.lng);
      var Y = Math.round(M) + ";";
      ad = ad + Y + sstr + lstr + "\n";
    }
    downloadTxt(ad, "variantlengths.csv");
  };
  this.showeleprofiles = function (ah) {
    if (!ah) {
      z.current_eleprofiles = new Array();
      var Y = 5;
      var N = -1;
      var Z = "";
      var ai;
      for (var O = 0; O < z.routes.length; O++) {
        if (z.routes[O].show) {
          N = O;
          ai = z.routes[O];
          O = z.routes.length + 1;
        }
      }
      if (N != -1) {
        endtime = z.playtime;
        var M = 0;
        for (var O = 0; O < z.routes.length; O++) {
          if (z.routes[O].show && M < 100) {
            var ad = new Array();
            M++;
            ai = z.routes[O];
            taillength = ai.taillength;
            if (taillength > 0) {
              var T = endtime - taillength;
              to = ai.findTimeIndex(endtime + ai.offset);
              from = ai.findTimeIndex(T + ai.offset);
              step = 1;
              if (step < 1) {
                step = 1;
              }
              for (var ag = from; ag <= to; ag = ag + step) {
                var ac = {
                  lat: parseFloat(ai.latarray[ag]),
                  lng: +parseFloat(ai.lngarray[ag]),
                };
                ad.push(ac);
              }
              var ae = interpolate_path_regular_distance(ad, Y);
              var af = ae.interp_path_string;
              if (M > 1) {
                Z = Z + "|";
              }
              Z = Z + af;
              M++;
              var aa = new Object();
              aa.type = "route";
              aa.num = O;
              aa.id = ai.id;
              aa.time = taillength;
              aa.name = ai.runnername;
              aa.color = ai.color;
              aa.segment = [from, to];
              aa.patharr_interp_data = ae;
              aa.patharr = ad;
              z.current_eleprofiles.push(aa);
            }
          }
        }
      } else {
        var M = 0;
        for (var O = 0; O < z.tags.length; O++) {
          if (z.tags[O].show) {
            thistag = z.tags[O];
            var ad = new Array();
            for (var ag = 0; ag < thistag.points.length; ag++) {
              thislatlng = thistag.points[ag].split(",");
              var ac = {
                lat: parseFloat(thislatlng[0]),
                lng: +parseFloat(thislatlng[1]),
              };
              ad.push(ac);
            }
            var ae = interpolate_path_regular_distance(ad, Y);
            var af = ae.interp_path_string;
            if (M > 0) {
              Z = Z + "|";
            }
            Z = Z + af;
            M++;
            var aa = new Object();
            aa.type = "tag";
            aa.num = O;
            aa.color = thistag.color;
            aa.id = null;
            aa.time = null;
            aa.name = thistag.name;
            aa.segment = null;
            aa.patharr_interp_data = ae;
            aa.patharr = ad;
            z.current_eleprofiles.push(aa);
          }
        }
      }
      if (Z.length > 0) {
        if (z.elevationparser) {
          console.log("Using elevation parser");
          for (var O = 0; O < z.current_eleprofiles.length; O++) {
            var ab = new Array();
            var aa = z.current_eleprofiles[O];
            var S = aa.patharr_interp_data.interp_path;
            var X = 0;
            for (var ag = 0; ag < S.length; ag++) {
              var Q = z.elevationparser.PCSToImage(S[ag].lng, S[ag].lat);
              var V = Q[1];
              var U = Q[2];
              var W = z.elevationparser.getPixelValueOnDemand(V, U);
              if (W) {
                ab[ag] = W[0];
              } else {
                ab[ag] = -1;
              }
            }
            z.current_eleprofiles[O].elevation = ab;
          }
          z.plotcurreleprofiles();
        } else {
          var R = "lidarprofile/lidarprofile.php";
          $.ajax({
            type: "post",
            url: R,
            dataType: "text",
            data: { paths: Z },
            error: function (ak, aj) {
              alert("Could not make elevation profile - error! ");
            },
            success: function (an, ap, am) {
              tmptmp3 = an;
              var aj = new Array();
              var al = an.split("\n");
              for (var ak = 0; ak < al.length; ak++) {
                var ao = al[ak].split(" ");
                if (ao[2] > 0) {
                  if (!aj[ao[0]]) {
                    aj[ao[0]] = new Array();
                  }
                  aj[ao[0]].push(parseFloat(ao[2]));
                }
              }
              for (var ak = 0; ak < aj.length; ak++) {
                z.current_eleprofiles[ak].elevation = aj[ak];
              }
              z.plotcurreleprofiles();
            },
          });
        }
      }
    } else {
      var N = -1;
      var Z = "";
      var ai;
      for (var O = 0; O < z.routes.length; O++) {
        if (z.routes[O].show) {
          N = O;
          ai = z.routes[O];
          O = z.routes.length + 1;
        }
      }
      if (N != -1) {
        endtime = z.playtime;
        var M = 0;
        cols = [];
        namess = [];
        for (var O = 0; O < z.routes.length; O++) {
          if (z.routes[O].show && M < 3) {
            var ad = new Array();
            M++;
            ai = z.routes[O];
            taillength = ai.taillength;
            if (taillength > 0) {
              var T = endtime - taillength;
              to = ai.findTimeIndex(endtime + ai.offset);
              from = ai.findTimeIndex(T + ai.offset);
              step = parseInt((to - from) / 150);
              if (step < 1) {
                step = 1;
              }
              for (var ag = from; ag <= to; ag = ag + step) {
                ad.push(
                  parseInt(ai.latarray[ag] * 10000) / 10000 +
                    "," +
                    parseInt(ai.lngarray[ag] * 10000) / 10000
                );
              }
              if (M > 1) {
                Z = Z + "|";
              }
              Z = Z + ad.join(";");
              cols.push(ai.color);
              namess.push(ai.runnername);
            }
          }
        }
      } else {
        var ad = new Array();
        thistag = z.tags[z.tags.length - 1];
        step = parseInt(thistag.points.length / 150);
        if (step < 1) {
          step = 1;
        }
        for (var ag = 0; ag < thistag.points.length; ag = ag + step) {
          thislatlng = thistag.points[ag].split(",");
          ad.push(
            parseInt(thislatlng[0] * 10000) / 10000 +
              "," +
              parseInt(thislatlng[1] * 10000) / 10000
          );
        }
        Z = ad.join(";");
      }
      if (Z.length > 0) {
        col = "['#" + cols.join("','#") + "']";
        names = "['" + namess.join("','") + "']";
        z.open_dialog(
          "Elevation profile",
          '<iframe src="showelevation.php?col=' +
            encodeURIComponent(col) +
            "&path=" +
            Z +
            "&names=" +
            encodeURIComponent(names) +
            '" height=700 width=690 frameborder=1></iframe>'
        );
      }
    }
  };
  this.centernextroute = function (O) {
    var M = 0;
    var N = z.route_to_center;
    while (M < z.routes.length + 1) {
      M++;
      N = N + O;
      if (N > z.routes.length - 1) {
        N = 0;
      }
      if (N < 0) {
        N = z.routes.length - 1;
      }
      if (z.routes[N]) {
        if (z.routes[N].show) {
          z.route_to_center = N;
          M = z.routes.length + 2;
        }
      }
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.set_tail_length = function (M) {
    z.settings.taillength = M;
    z.reset_taillengths();
    z.updateinfobottomdiv();
    z.request_redraw();
  };
  this.setcourseslider = function (Q) {
    if (!z.playtime) {
      z.playtime = z.zerotime;
    }
    for (var O = 0; O < z.routes.length; O++) {
      if (z.routes[O].show) {
        var M = z.routes[O];
        var R = (Q.values[0] / 10000) * M.latarray.length;
        var N = (Q.values[1] / 10000) * M.latarray.length;
        z.zerotime = M.zerotime;
        z.playtime = z.zerotime;
        M.offset = N;
        M.taillength = parseInt(N - R);
        M.segmenttime = parseInt(N - R);
        O = z.routes.length + 1;
      }
    }
    z.request_redraw();
    z.update_routediv(false);
  };
  this.savevariantinfo = function (N) {
    var V = "# Runners\n";
    for (var M = 0; M < z.routes.length; M++) {
      var Q = "";
      if (z.routes[M].variants) {
        for (var U = 0; U < z.routes[M].variants.length; U++) {
          if (z.routes[M].variants[U] != null && z.routes[M].variants[U] >= 0) {
            tagname = z.tags[z.routes[M].variants[U]].name;
            Q = Q + U + ":" + z.routes[M].variants[U] + "|" + tagname + ";";
          }
        }
        if (Q) {
          V = V + z.routes[M].runnername + ";" + Q + "\n";
        }
      }
    }
    V = V + "# Variants\n";
    for (var M = 0; M < z.tags.length; M++) {
      var R = z.tags[M];
      if (R.type == "route") {
        var S = "";
        var T = R.pointsxy;
        if (T) {
          for (jj = 1; jj < T.length; jj++) {
            var O = T[jj];
            var W = O.split(",");
            S = S + W[0] + "," + W[1] + " ";
          }
        }
        V = V + M + ";" + R.name + ";" + parseInt(R.length) + ";" + S + "\n";
      }
    }
    z.canvas.saveDataURL(N, V);
  };
  this.savecompletemap = function (N) {
    if (!N) {
      N = new Date().valueOf();
    }
    z.settings.isprinting = 1;
    z.printscreenfactor = 1 / z.canvas.zoomfactor;
    z.canvas.canvaselement.height = z.map.height / z.printscreenfactor;
    z.canvas.canvaselement.width = z.map.width / z.printscreenfactor;
    z.canvas.zoomfactor = 1 / z.printscreenfactor;
    z.canvas.height = z.map.height / z.printscreenfactor;
    z.canvas.width = z.map.width / z.printscreenfactor;
    z.canvas.cx = (z.canvas.width / 2) * z.printscreenfactor;
    z.canvas.cy = (z.canvas.height / 2) * z.printscreenfactor;
    z.redraw();
    z.canvas.saveDataURL(N);
    z.settings.isprinting = 0;
    var M;
    if (z.settings.enableprintscreen == 2) {
      M = "http://localhost/ge/2d/";
    } else {
      M = "";
    }
    z.open_dialog(
      "Saved map",
      '<a target=_blank href="' +
        M +
        "eimages/" +
        N +
        "." +
        z.settings.printscreentype +
        '">Download map/analysis here</a>',
      0
    );
  };
  this.savecompletemap_withcourse_and_sketch = function (O) {
    z = mapviewer;
    z.settings.courseopacity = O;
    var N = z.settings.mapopacity;
    var M = z.settings.courseopacity;
    z.settings.mapopacity = 1;
    fname = new Date().valueOf();
    z.settings.isprinting = 1;
    z.canvas.canvaselement.height = z.map.height;
    z.canvas.canvaselement.width = z.map.width;
    z.canvas.zoomfactor = 1;
    z.canvas.height = z.map.height;
    z.canvas.width = z.map.width;
    z.canvas.cx = z.canvas.width / 2;
    z.canvas.cy = z.canvas.height / 2;
    z.redraw();
    z.canvas.saveDataURL(fname);
    z.settings.isprinting = 0;
    z.settings.mapopacity = N;
    z.settings.courseopacity = M;
    z.request_redraw();
  };
  this.change_legendtype = function (M) {
    if (M == 1) {
      z.settings.legendtype++;
      if (z.settings.legendtype > 6) {
        z.settings.legendtype = 0;
      }
    } else {
      z.settings.legendtype--;
      if (z.settings.legendtype < 0) {
        z.settings.legendtype = 6;
      }
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.change_autrotangle = function (M) {
    if (M == 1) {
      z.settings.autrotanglemode++;
      if (z.settings.autrotanglemode > z.settings.autrotanglemodes.length - 1) {
        z.settings.autrotanglemode = 0;
      }
    } else {
      z.settings.autrotanglemode--;
      if (z.settings.autrotanglemode < 0) {
        z.settings.autrotanglemode = z.settings.autrotanglemodes.length - 1;
      }
    }
    z.rotatesplit();
    z.updateinfobottomdiv();
  };
  this.change_legendinfo = function (M) {
    if (M == 1) {
      z.settings.legendinfo++;
      if (z.settings.legendinfo > z.settings.legendinfos.length - 1) {
        z.settings.legendinfo = 0;
      }
    } else {
      z.settings.legendinfo--;
      if (z.settings.legendinfo < 0) {
        z.settings.legendinfo = z.settings.legendinfos.length - 1;
      }
    }
    if (z.settings.legendinfo >= 6 && z.settings.legendinfo <= 7) {
      z.settings.calc_inout_times = 1;
    } else {
      z.settings.calc_inout_times = 0;
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.toggle_graph_showrealtime = function () {
    if (z.settings.graph_showrealtime == 1) {
      z.settings.graph_showrealtime = 0;
    } else {
      z.settings.graph_showrealtime = 1;
    }
  };
  this.toggle_autoselect = function () {
    if (z.settings.showautoselect == 1) {
      z.settings.showautoselect = 0;
      $("#showautoselect").hide();
    } else {
      z.settings.showautoselect = 1;
      $("#showautoselect").show();
    }
  };
  this.toggle_timeslider = function () {
    if ($("#realtimesliderdiv").css("display") == "none") {
      $("#realtimesliderdiv").show();
    } else {
      $("#realtimesliderdiv").hide();
    }
    z.updateinfobottomdiv();
  };
  this.reducerouteopacity = function () {
    z.settings.routeopacity = z.settings.routeopacity - 0.1;
    if (z.settings.routeopacity < 0.001) {
      z.settings.routeopacity = 0;
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.increaserouteopacity = function () {
    z.settings.routeopacity = z.settings.routeopacity + 0.1;
    if (z.settings.routeopacity > 1) {
      z.settings.routeopacity = 1;
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.change_dotstep = function (M) {
    z.settings.dotstep = z.settings.dotstep + M;
    if (z.settings.dotstep < 1) {
      z.settings.dotstep = 9999;
    }
    if (z.settings.dotstep > 9999) {
      z.settings.dotstep = 1;
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.plotgraph_dialog = function (M) {
    z.open_dialog("Compare " + M, '<div id="plotdialog"></div>', 0);
  };
  this.courseeditor_start = function () {
    if (!z.courseeditor_data) {
      var M = new Object();
      M.coursecoords = z.coursecoords;
      var O = jQuery.extend(true, {}, M);
      z.courseeditor_data = new Object();
      z.courseeditor_data.courseinfo = jQuery.extend(true, {}, z.courseinfo);
      z.courseeditor_data.coursecoords = O.coursecoords;
    }
    if (!z.courseinfo.numlaps) {
      z.courseinfo.numlaps = 1;
    }
    var N = z.courseinfo.numlaps;
    var M = new Object();
    M.coursecoords = z.courseeditor_data.coursecoords;
    var O = jQuery.extend(true, {}, M);
    z.coursecoords = O.coursecoords;
    z.courseinfo = jQuery.extend(true, {}, z.courseeditor_data.courseinfo);
    z.courseinfo.numlaps = N;
    z.ploteleprofile_popup();
    $("#AutoCourseLaps").val(z.courseinfo.numlaps);
    z.hillsegments_combine_segments(z.courseinfo.numlaps);
    var Q = z.snaproutestocourse();
    $("#coursefit_status").html(Q);
  };
  this.set_average_elevation = function () {
    z = mapviewer;
    var U = new Array();
    var M = $("#selectgraph-1").val();
    var S = z.datafieldtypes[parseInt(M) - 5];
    if (S) {
      var W = 0;
      for (var T = 0; T < z.routes.length; T++) {
        var R = z.routes[T];
        if (R.show) {
          var O = z.routes[T].lapdata;
          if (O.length) {
            for (var N = 0; N < O.length; N++) {
              var R = z.routes[T];
              var O = z.routes[T].lapdata[N];
              if (O) {
                if (O[S]) {
                  for (var N = 0; N < O[S].length; N++) {
                    if (!U[N]) {
                      U[N] = 0;
                    }
                    U[N] = U[N] + O[S][N];
                  }
                  W++;
                }
              }
            }
          }
        }
      }
      if (W > 0) {
        for (var N = 0; N < U.length; N++) {
          U[N] = U[N] / W;
        }
        var V = z.courseeditor_data.coursecoords;
        for (var Q = 0; Q < V.length; Q++) {
          var X = V[Q].split(",");
          X[2] = U[Q];
          V[Q] = X.join(",");
        }
      }
    } else {
    }
  };
  this.plotcurreleprofiles = function () {
    z = mapviewer;
    var Y = new Array();
    var U = new Array();
    eleinfo = new Object();
    eleinfo.minele = [];
    eleinfo.maxele = [];
    eleinfo.maxdist = [];
    for (var Q = 0; Q < mapviewer.current_eleprofiles.length; Q++) {
      eleinfo.minele.push(mapviewer.current_eleprofiles[Q].elevation.min());
      eleinfo.maxele.push(mapviewer.current_eleprofiles[Q].elevation.max());
      eleinfo.maxdist.push(
        mapviewer.current_eleprofiles[Q].patharr_interp_data.distance.max()
      );
    }
    for (var Q = 0; Q < mapviewer.current_eleprofiles.length; Q++) {
      var T = mapviewer.current_eleprofiles[Q];
      var X = 0;
      var M = 0;
      var W = new Array();
      for (var S = 0; S < T.elevation.length; S++) {
        var V = T.elevation[S] - eleinfo.minele.min();
        if ((S > 0) & (V > M)) {
          X += V - M;
        }
        M = V;
        W.push([T.patharr_interp_data.distance[S], V]);
      }
      Y.push(W);
      dist = T.patharr_interp_data.routelength;
      var O = 5;
      var R = 5;
      routeinfo =
        "Route " +
        T.name +
        ". Length " +
        parseInt(dist) +
        " m. Climb " +
        parseInt(X) +
        " m / " +
        parseInt((X / dist) * 100 * 10) / 10 +
        "%";
      if (T.time) {
        vspeed = tominsec((T.time / X) * 100) + " min/100 m climb";
        var N = 4;
        eq_flat_time = (dist / 1000) * N * 60;
        est_climb_time = T.time - eq_flat_time;
        vspeed_climb_only =
          tominsec((est_climb_time / X) * 100) + " min/100 m climb";
        vspeed = vspeed + ", Climb only: " + vspeed_climb_only;
        routeinfo =
          routeinfo +
          ", " +
          tominsec(T.time) +
          " min, " +
          tominsec((T.time / dist) * 1000) +
          " min/km, " +
          vspeed;
      }
      z.open_dialog(
        "Compare elevation profiles",
        '<div id="plotdialog"></div>',
        0
      );
      U.push({
        showLine: true,
        showMarker: false,
        fillAndStroke: true,
        fill: false,
        fillAlpha: "0.1",
        label: routeinfo,
        color: "#" + T.color,
      });
      ymin = 0;
      ymax = eleinfo.maxele.max() - eleinfo.minele.min() + R;
      xmax = eleinfo.maxdist.max();
      ymin = Math.round(ymin / 5) * 5;
      ymax = Math.round(ymax / 5) * 5;
      xmax = Math.round(xmax / 5) * 5;
      z.ploteledialog_plot = $.jqplot("plotdialog", Y, {
        axes: { yaxis: { min: ymin, max: ymax }, xaxis: { min: 0, max: xmax } },
        legend: { show: true },
        series: U,
      });
    }
    $("#plotdialog").height($("#dialog").height() - 20);
    z.ploteledialog_plot.replot({ resetAxes: false });
    $("#dialog").sizeChanged(function () {
      if ($("#plotdialog").height()) {
        $("#plotdialog").height($("#dialog").height() - 20);
        z.ploteledialog_plot.replot({ resetAxes: false });
      }
    });
    z.plotcurreleprofiles_3d();
  };
  this.plotcurreleprofiles_3d = function () {
    z = mapviewer;
    var S = new Array();
    for (var Z = 0; Z < z.current_eleprofiles.length; Z++) {
      var V = z.current_eleprofiles[Z];
      var W = new Object();
      var ac = new Array();
      var N = new Array();
      var Q = new Array();
      var ab = new Array();
      for (var U = 0; U < V.elevation.length; U++) {
        var ad = V.elevation[U];
        var aa = V.patharr_interp_data.interp_path[U];
        var X = aa.lat;
        var Y = aa.lng;
        var T = z.map.toxy(X, Y);
        ac.push(ad);
        N.push(U);
        Q.push(T.x);
        ab.push(T.y);
      }
      W.elevation = ac;
      W.x = Q;
      W.y = ab;
      W.color = V.color;
      var O = new Array();
      O.push(0);
      O.push(ac.length - 1);
      O.push(0);
      W.eledetails = O;
      var R = new Array();
      for (var M = 0; M < W.elevation.length; M++) {
        if (M == 0) {
          R[M] = 0;
        } else {
          if (M < W.elevation.length / 2) {
            R[M] = R[M - 1] + 1;
          } else {
            R[M] = R[M - 1] - 1;
          }
        }
        R[M] = 3;
      }
      W.dZ = R;
      S.push(W);
    }
    localStorage_setItem("course3Ds", JSON.stringify(S));
  };
  this.ploteleprofile_popup_scaled = function () {
    var O = "eleprofile";
    z.settings.eleplotoptions.printspecial = 1;
    z.settings.eleplotoptions.scaled_eleplot = 1;
    z.settings.eleplotoptions.alwaysshowgrade = 1;
    z.open_dialog(
      O,
      '<div id="plotdialog"></div><div id="plotdialog_settings"></div>',
      0
    );
    var N = z.ploteleprofile("#plotdialog");
    var M =
      $("#plotdialog").width() / $("#plotdialog .jqplot-point-label").length;
    if (M <= z.settings.eleplotoptions.labelsperpixelbeforeoffset) {
      count = 0;
      $("#plotdialog .jqplot-point-label").each(function (Q) {
        count = count + 1;
        if (count % 2 == 0) {
          $(this).css("background", "#ffffff");
          $(this).css("margin-top", "-15px");
        } else {
          $(this).css("background", "#ffffff");
          $(this).css("margin-top", "5px");
        }
      });
    }
    $("#plotdialog .jqplot-point-label").each(function (Q) {
      var R = $(this).html();
      R = R.replace(/\n/g, "<br>");
      $(this).html(R);
    });
    data = $("#plotdialog").jqplotToImageStr({});
    downloadImg(data, "eleprofile_scaled.png");
    z.settings.eleplotoptions.printspecial = 0;
    z.settings.eleplotoptions.scaled_eleplot = 0;
    z.settings.eleplotoptions.alwaysshowgrade = 0;
  };
  this.ploteleprofile_popup = function () {
    var N = "eleprofile";
    z.open_dialog(
      N,
      '<div id="plotdialog"></div><div id="plotdialog_settings"></div>',
      0
    );
    var M = z.ploteleprofile("#plotdialog");
    if (!z.courseinfo.numlaps) {
      z.courseinfo.numlaps = 1;
    }
    $("#plotdialog_settings").html(
      '<select id="eleprofileClickSelector"><option value="segmentborder">Add/remove hillsegment</option><option value="segmenttype">Change hillsegment type</option><option value="splittimes">Add/remove split</option></select> <select id="AutoCourseLaps"><option value="' +
        z.courseinfo.numlaps +
        '">' +
        z.courseinfo.numlaps +
        ' laps</option><option value="1">1 lap</option><option value="2">2 laps</option><option value="3">3 laps</option><option value="4">4 laps</option><option value="5">5 laps</option><option value="6">6 laps</option><option value="7">7 laps</option><option value="8">8 laps</option><option value="9">9 laps</option><option value="10">10 laps</option></select> <button onclick="mapviewer.courseeditor_define();return false;"  id="definecourse_button">Define course</button> <button onclick="mapviewer.saveCourse(null,null,0);return false"  id="savexccourse_button">Export course</button> <button onclick="mapviewer.saveCourse(null,null,1);return false"  id="savexccourseroute_button">Export course+routes</button><button onclick="$(\'#selectmode\').val(\'graphmode\');$(\'#selectmode\').change();mapviewer.close_dialog();return false"  id="plotgraph_button">Plot graph</button><div id="coursefit_status" style="border-top: 1px solid #888;padding-top:10px;margin-top:8px;font-size:12px;"></div>'
    );
  };
  this.plotgraph_dialog_lines = function (O, M) {
    z.open_dialog("Compare " + O, '<div id="plotdialog"></div>', 0);
    var N = $.jqplot("plotdialog", M);
  };
  this.find_biathlon_keyinfo = function (am) {
    var aH = new Array();
    var aN = new Array();
    var Y = mapviewer;
    var an = 0;
    for (var aJ = 0; aJ < Y.routes.length; aJ++) {
      var Q = Y.routes[aJ];
      if (Q.show || am) {
        Q.shootinfo = new Array();
        var ah = mapviewer.routes[aJ].lapdata[an].times[0];
        var av = Q.timearray[ah];
        var ao = null;
        var X = Q.pulse;
        if (!X) {
          X = new Array();
          for (var aY = 0; aY < Q.latarray.length; aY++) {
            X[aY] = 0;
          }
        }
        for (var S = 0; S < Y.courseinfo.lap_spacing.length; S++) {
          var ap = mapviewer.courseinfo.lap_spacing[S];
          var aL = ap + 1;
          var ae = Math.floor(mapviewer.routes[aJ].lapdata[an].times[ap]);
          ao = ae;
          var a0 = Math.floor(mapviewer.routes[aJ].lapdata[an].times[aL]);
          var aQ = 0;
          var ac = new Array();
          for (var aY = ae; aY < a0; aY++) {
            var aZ = 0;
            var W = Q.timearray[aY] - Q.timearray[aY - 1];
            var U = calcdistance(
              Q.latarray[aY],
              Q.lngarray[aY],
              Q.latarray[aY - 1],
              Q.lngarray[aY - 1]
            );
            if (W != 0) {
              aZ = U / W;
            }
            ac.push([aQ, aZ]);
            aQ++;
          }
          var aI = average_line(ac, 2, "normal");
          var aP = null;
          var aw = null;
          var N = 2;
          var aA = 0;
          var aa = 0;
          var ak = 0;
          var O = 0;
          var af = 0;
          var V = X[ae];
          var aO = Q.timearray[ao];
          var aV = aO - av;
          var au = false;
          for (var aY = 0; aY < aI.length; aY++) {
            if (!au && aI[aY][1] <= N) {
              au = true;
              aA = Q.timearray[ae + aY] - aO;
              O = X[ae + aY];
              kk_startshooting = aY;
              aP = ae + aY;
            }
            if (au && aI[aY][1] >= N && aY - kk_startshooting >= 10) {
              af = X[ae + aY];
              aa = Q.timearray[ae + aY] - aO - aA;
              aw = ae + aY;
              aY = aI.length + 1;
            }
          }
          t_total = Q.timearray[a0] - Q.timearray[ae];
          t_penalty_old = t_total - aA - aa;
          var ay = 0;
          for (var aY = ah; aY <= ao; aY++) {
            if (X[aY] > ay) {
              ay = X[aY];
            }
          }
          var M = 60 * 5;
          var aC = 60 * 5;
          var al = Y.settings.mindist_for_penalty;
          var ai = 10;
          if (!Y.courseinfo.biathlonvariables) {
            Y.courseinfo.biathlonvariables = new Object();
          }
          var T = { ind: NaN, val: NaN, hr: NaN };
          if (Y.courseinfo.biathlonvariables.intorange) {
            var aR = Y.courseinfo.biathlonvariables.intorange;
            if (aR) {
              T = Q.findclosestpoint_segment(aR.lat, aR.lng, ae, aP);
            }
          }
          var R = { ind: NaN, val: NaN, hr: NaN };
          if (Y.courseinfo.biathlonvariables.outofrange) {
            var aR = Y.courseinfo.biathlonvariables.outofrange;
            if (aR) {
              R = Q.findclosestpoint_segment(aR.lat, aR.lng, aw, a0);
            }
          }
          var aj = { ind: NaN, val: NaN, hr: NaN };
          if (Y.courseinfo.biathlonvariables.afterpenalty) {
            var aR = Y.courseinfo.biathlonvariables.afterpenalty;
            if (aR) {
              aj = Q.findclosestpoint_segment(aR.lat, aR.lng, R.ind, a0);
            }
          }
          var aB = { ind: NaN, val: NaN, hr: NaN };
          if (Y.courseinfo.biathlonvariables.beforerange) {
            var aR = Y.courseinfo.biathlonvariables.beforerange;
            if (aR) {
              aB = Q.findclosestpoint_segment(aR.lat, aR.lng, T.ind - M, T.ind);
            }
          }
          var aU = { ind: NaN, val: NaN, hr: NaN };
          if (Y.courseinfo.biathlonvariables.oncourse) {
            var aR = Y.courseinfo.biathlonvariables.oncourse;
            if (aR) {
              aU = Q.findclosestpoint_segment(
                aR.lat,
                aR.lng,
                T.ind - aC,
                T.ind
              );
            }
          }
          var aF = NaN;
          if (Y.courseinfo.biathlonvariables.inpenalty) {
            var aR = Y.courseinfo.biathlonvariables.inpenalty;
            if (aR) {
              var aG = aR.lat;
              var az = aR.lng;
              var ax = R.ind;
              var at = aj.ind;
              var aT = 1e99;
              aF = 0;
              for (var aW = ax; aW <= at; aW++) {
                aT++;
                var aX = calcdistance(Q.latarray[aW], Q.lngarray[aW], aG, az);
                if (aX < al && aT >= ai) {
                  aF++;
                  aT = 0;
                }
              }
            }
          }
          var aS = new Object();
          aS.pos_beforeshooting = ae;
          aS.pos_intorange = T;
          aS.pos_outofrange = R;
          aS.pos_afterpenalty = aj;
          aS.pos_startshooting = aP;
          aS.pos_endshooting = aw;
          aS.pos_aftershooting = a0;
          aS.pos_beforerange = aB;
          aS.pos_oncourse = aU;
          ak = aj.ind - R.ind;
          aA = T.ind - aB.ind;
          t_range = R.ind - T.ind;
          t_range_minus_shooting = t_range - aa;
          V = aB.hr;
          hr_into_range = T.hr;
          hr_oncourse = aU.hr;
          aF = aF;
          aS.t_shooting = aa;
          aS.hr_start_shooting = O;
          aS.hr_finish_shooting = af;
          aS.t_lap = aV;
          aS.maxhr_lap = ay;
          aS.ind_start_lap = ah;
          aS.ind_finish_lap = ao;
          aS.t_before_shooting = aA;
          aS.t_penalty = ak;
          aS.hr_before_range = V;
          aS.penalties = aF;
          aS.t_range = t_range;
          aS.t_range_minus_shooting = t_range_minus_shooting;
          aS.hr_oncourse = hr_oncourse;
          aS.hr_into_range = hr_into_range;
          var a1 = Q.maxpulse;
          if (a1) {
            aS.hr_start_shooting_rel = (O / a1) * 100;
            aS.hr_finish_shooting_rel = (af / a1) * 100;
            aS.hr_before_range_rel = (V / a1) * 100;
            aS.hr_into_range_rel = (hr_into_range / a1) * 100;
            aS.hr_oncourse_rel = (hr_oncourse / a1) * 100;
            aS.maxhr_lap_rel = (aS.maxhr_lap / a1) * 100;
          }
          Q.shootinfo[S] = aS;
          ah = a0;
          av = mapviewer.routes[aJ].timearray[ah];
          aS.timepersegmenttype = [0, 0, 0];
        }
        var S = Y.courseinfo.lap_spacing.length - 1;
        var ah =
          Y.routes[aJ].lapdata[an].times[Y.courseinfo.lap_spacing[S] + 1];
        var ao =
          Y.routes[aJ].lapdata[an].times[
            Y.routes[aJ].lapdata[an].times.length - 1
          ];
        var aV = ao - ah;
        var ay = 0;
        for (var aY = Math.floor(ah); aY <= Math.floor(ao); aY++) {
          if (X[aY] > ay) {
            ay = X[aY];
          }
        }
        var aS = new Object();
        aS.t_before_shooting = 0;
        aS.t_shooting = 0;
        aS.t_penalty = 0;
        aS.hr_start_shooting = 0;
        aS.hr_finish_shooting = 0;
        aS.hr_before_range = 0;
        aS.t_lap = aV;
        aS.maxhr_lap = ay;
        if (a1) {
          aS.maxhr_lap_rel = (aS.maxhr_lap / a1) * 100;
        }
        aS.ind_start_lap = ah;
        aS.ind_finish_lap = ao;
        aS.timepersegmenttype = [0, 0, 0];
        Q.shootinfo[S + 1] = aS;
        var S = 0;
        for (var aY = 0; aY < Y.courseinfo.hillsegments.length; aY++) {
          var Z = Y.courseinfo.hillsegments[aY];
          var aE = Z.thetypeint;
          if (aE == 2) {
            S++;
          } else {
            Q.shootinfo[S].timepersegmenttype[aE + 1] =
              Q.shootinfo[S].timepersegmenttype[aE + 1] +
              mapviewer.routes[aJ].lapdata[0].averages.times[aY];
          }
        }
        var ab = 4;
        var ag = new Array();
        var aD = new Array();
        ag[0] = 0;
        for (var aY = 0; aY < Y.courseinfo.lap_spacing.length; aY++) {
          aD[aY] = Y.courseinfo.lap_spacing[aY];
          ag[aY + 1] = Y.courseinfo.lap_spacing[aY] + 1;
        }
        aD[Y.courseinfo.lap_spacing.length] = Y.courseinfo.distarray.length - 1;
        for (var aY = 0; aY < ag.length; aY++) {
          var aM = new Array();
          for (var ad = 0; ad < ab; ad++) {
            var aK = aD[aY] - ag[aY];
            var ar = ag[aY] + Math.floor((ad * aK) / ab);
            var aq = ag[aY] + Math.floor(((ad + 1) * aK) / ab);
            if (ad == ab - 1) {
              aq = aD[aY];
            }
            aM[ad] =
              Y.routes[aJ].lapdata[an].times[aq] -
              Y.routes[aJ].lapdata[an].times[ar];
          }
          Q.shootinfo[aY].t_lap_segments = aM;
        }
      }
    }
  };
  this.make_biathlon_results_table = function () {
    var N = new Array();
    var W = new Array();
    var ab = mapviewer;
    var ag = 0;
    var aj = new Array("#eeeeee", "#ffffff");
    var V = 0;
    ab.find_biathlon_keyinfo();
    for (var Q = 0; Q < ab.routes.length; Q++) {
      var M = ab.routes[Q];
      if (M.show) {
        V++;
        if (V > aj.length) {
          V = 1;
        }
        var ah = ' style="background:' + aj[V - 1] + '" ';
        if (ab.settings.userelativepulse) {
        } else {
        }
        for (var R = 0; R < mapviewer.courseinfo.lap_spacing.length; R++) {
          var O = new Array();
          var ai = new Array();
          var aa = M.runnername.split(" - ");
          aa = aa[0];
          var aa = aa + " - " + (R + 1);
          O.push(aa);
          ai.push(aa);
          var ac = M.shootinfo[R];
          var Y = M.shootinfo[mapviewer.courseinfo.lap_spacing.length];
          if (!ac) {
            ac = {
              hr_before_range: 0,
              hr_start_shooting: 0,
              hr_finish_shooting: 0,
              t_lap: 0,
              t_before_shooting: 0,
              t_shooting: 0,
              t_penalty: 0,
              timepersegmenttype: [0, 0, 0],
              t_lap_segments: [0, 0, 0, 0],
            };
          }
          if (!Y) {
            Y = {
              hr_before_range: 0,
              hr_start_shooting: 0,
              hr_finish_shooting: 0,
              t_lap: 0,
              t_before_shooting: 0,
              t_shooting: 0,
              t_penalty: 0,
              timepersegmenttype: [0, 0, 0],
              t_lap_segments: [0, 0, 0, 0],
            };
          }
          var ae = ac.hr_before_range;
          var Z = ac.hr_start_shooting;
          var S = ac.hr_finish_shooting;
          var ad = ac.hr_into_range;
          var U = ac.maxhr_lap;
          var T = Y.maxhr_lap;
          if (ab.settings.userelativepulse) {
            ae = ac.hr_before_range_rel;
            Z = ac.hr_start_shooting_rel;
            S = ac.hr_finish_shooting_rel;
            ad = ac.hr_into_range_rel;
            U = ac.maxhr_lap_rel;
            T = Y.maxhr_lap_rel;
          }
          if (isNaN(U)) {
            U = 0;
          }
          if (isNaN(ae)) {
            ae = 0;
          }
          if (isNaN(ad)) {
            ad = 0;
          }
          if (isNaN(Z)) {
            Z = 0;
          }
          if (isNaN(S)) {
            S = 0;
          }
          O.push(parseInt(U));
          O.push(parseInt(ae));
          O.push(parseInt(ad));
          O.push(parseInt(Z));
          O.push(parseInt(S));
          O.push(tominsec(ac.t_lap));
          O.push(tominsec(ac.t_before_shooting));
          O.push(tominsec(ac.t_shooting));
          O.push(tominsec(ac.t_range_minus_shooting));
          O.push(tominsec(ac.t_penalty));
          O.push(ac.penalties);
          ai.push(parseInt(U));
          ai.push(parseInt(ae));
          ai.push(parseInt(ad));
          ai.push(parseInt(Z));
          ai.push(parseInt(S));
          ai.push("00:" + tominsec(ac.t_lap));
          ai.push("00:" + tominsec(ac.t_before_shooting));
          ai.push("00:" + tominsec(ac.t_shooting));
          ai.push("00:" + tominsec(ac.t_range_minus_shooting));
          ai.push("00:" + tominsec(ac.t_penalty));
          ai.push(ac.penalties);
          ai.push(ac.timepersegmenttype[0]);
          ai.push(ac.timepersegmenttype[1]);
          ai.push(ac.timepersegmenttype[2]);
          ai.push(ac.t_lap_segments[0]);
          ai.push(ac.t_lap_segments[1]);
          ai.push(ac.t_lap_segments[2]);
          ai.push(ac.t_lap_segments[3]);
          ai.push(parseInt(T));
          ai.push("00:" + tominsec(Y.t_lap));
          ai.push(Y.timepersegmenttype[0]);
          ai.push(Y.timepersegmenttype[1]);
          ai.push(Y.timepersegmenttype[2]);
          ai.push(Y.t_lap_segments[0]);
          ai.push(Y.t_lap_segments[1]);
          ai.push(Y.t_lap_segments[2]);
          ai.push(Y.t_lap_segments[3]);
          N.push(
            "<tr><td" + ah + ">" + O.join("</td><td" + ah + ">") + "</td></tr>"
          );
          W.push(ai.join(";") + "\n");
        }
      }
    }
    var X =
      '<div style="-webkit-user-select: all;-ms-user-select: all;-moz-user-select: all;">';
    X +=
      '<h4>Biathlon evaluation</h4><table class="table" border=1 cellpadding=3 cellspacing=0>';
    X +=
      "<tr><th>Name</th><th>Max HR lap</th><th>HR before range</th><th>HR into range</th><th>HR start shoot</th><th>HR after shoot</th><th>Time lap</th><th>Time before range</th><th>Time shooting</th><th>XC time range</th><th>Time 'penalty'</th><th>Misses</th></tr>" +
      N.join("\n") +
      "</table>";
    var af =
      "Name;Max HR lap;HR before tange;HR into range;HR start shoot;HR after shoot;Time lap;Time before range;Time shooting;XC time range;Time penalty;Misses;Time lap down;Time lap flat;Time lap uphill;Time lap part 1/4;Time lap part 2/4;Time lap part 3/4;Time lap part 4/4;Max HR last lap;Time last lap;Time last lap down;Time last lap flat;Time last lap uphill;Time last lap part 1/4;Time last lap part 2/4;Time last lap part 3/4;Time last lap part 4/4;\n" +
      W.join("");
    downloadTxt(af, "biathlondata.csv");
    ab.open_dialog("Biathlon evaluation", X);
  };
  this.plot_persegment = function (ag, ae, aa) {
    var aj = mapviewer.hilltypes;
    var af = 0;
    var N = [];
    var Z = new Array();
    var Y = new Array();
    for (var O = 0; O < z.routes.length; O++) {
      var M = z.routes[O];
      var ab = 0;
      if (M.show && z.courseinfo.lap_spacing) {
        af++;
        for (var Q = 0; Q < z.routes[O].lapdata.length; Q++) {
          var al = M.runnername_middle;
          ab++;
          if (ab > 1 || z.routes[O].lapdata.length > 1) {
            al = al + " " + ab;
          }
          Z.push(al);
          Y.push("#" + M.color);
          var ak = 0;
          if (z.routes[O].lapdata[Q].persegment[ae]) {
            if (aa == "Mixed_Stack" || aa == "Mixed_Stack_Diff") {
              ak = new Array();
              var aj = mapviewer.hilltypes;
              for (var R = 0; R < aj.length; R++) {
                var T = z.routes[O].lapdata[Q].persegment[ae][aj[R]];
                if (!T) {
                  T = 0;
                }
                ak.push(T);
                console.log(ak);
              }
            } else {
              ak = z.routes[O].lapdata[Q].persegment[ae][aa];
            }
          }
          N.push(ak);
        }
      }
    }
    if (aa == "Mixed_Stack" || aa == "Mixed_Stack_Diff") {
      if (aa == "Mixed_Stack_Diff") {
        for (var S = 0; S < N[0].length; S++) {
          var U = new Array();
          for (var R = 0; R < N.length; R++) {
            var W = N[R][S];
            if (W != 0) {
              U.push(W);
            }
          }
          var X = 0;
          if (U.length > 0) {
            X = U.min();
          }
          for (var R = 0; R < N.length; R++) {
            N[R][S] -= X;
          }
        }
      }
      var ai = {
        Mixed_Stack: "Time per segment type",
        Mixed_Stack_Diff: "Time loss per segment type",
      };
      var ah = ai[aa];
      barcols = z.hillcolors.slice();
      barlabels = new Array();
      for (var R = 0; R < aj.length; R++) {
        barlabels[R] = aj[R];
        if (barlabels[R] == "Separator") {
          barlabels[R] = mapviewer.settings.graphsettings.separatorlabel;
        }
      }
      var ac = new Array();
      for (var R = 0; R < barcols.length; R++) {
        barcols[R] = "#" + barcols[R];
        ac.push({ label: barlabels[R], color: barcols[R] });
      }
      var ad = true;
      barplot_stacked(ag, ah, transpose(N), Z, barcols, af, ac, ad);
    } else {
      data = N;
      mindata = data.min() - (data.max() - data.min()) / 3;
      maxdata = data.max() + (data.max() - data.min()) / 3;
      if (maxdata - mindata < 0.2) {
        mindata = mindata - 0.1;
        maxdata = maxdata + 0.1;
      } else {
        if (maxdata - mindata < 0.4) {
          mindata = mindata - 0.1;
          maxdata = maxdata + 0.1;
        }
      }
      var V = new Array();
      for (var R = 0; R < data.length; R++) {
        if (Math.abs(data[R]) < 3) {
          fact = 100;
        } else {
          fact = 10;
        }
        V[R] = [Z[R], parseInt(fact * data[R]) / fact];
      }
      formatstr = "%.1f";
      if (Math.abs(maxdata) < 3) {
        formatstr = "%.2f";
      }
      tmptmp = barplot(ag, aa, [V], Y, formatstr, mindata, maxdata);
    }
  };
  this.plot_var_in_break = function (ae, am) {
    var af = new Array();
    var ag = new Array();
    var ad = 2;
    var an = "normal";
    var Z = 0;
    var ac = 0;
    var ah = 0;
    var ap;
    var T;
    var au;
    if (am == "pulse") {
      ap = "Comparison of HR between laps";
      T = "%d";
      au =
        '<table class="jqplot-highlighter"> <tr><td>Time:</td><td>%s s</td></tr> <tr><td>HR:</td><td>%s</td></tr></table>';
    } else {
      if (am == "speed") {
        ap = "Comparison of Speed between laps";
        T = "%.1f";
        au =
          '<table class="jqplot-highlighter"> <tr><td>Time:</td><td>%s s</td></tr> <tr><td>Speed:</td><td>%s m/s</td></tr></table>';
      }
    }
    for (var aj = 0; aj < z.routes.length; aj++) {
      var N = z.routes[aj];
      if (N.show && z.courseinfo.lap_spacing) {
        for (var O = 0; O < z.courseinfo.lap_spacing.length; O++) {
          var M = 0;
          showlapnum = $("#biabetween").val();
          if (showlapnum == 0) {
            M = 1;
          } else {
            if (showlapnum - 1 == O) {
              M = 1;
            }
          }
          if (M) {
            var X = N.runnername.split(" - ");
            X = X[0];
            var X = X + " - " + (O + 1);
            var aa = mapviewer.courseinfo.lap_spacing[O];
            var al = aa + 1;
            var W = Math.floor(mapviewer.routes[aj].lapdata[Z].times[aa]);
            var av = Math.floor(mapviewer.routes[aj].lapdata[Z].times[al]);
            var U = [];
            var ao = 0;
            var ak;
            if (z.settings.recolormode == "byathlete") {
              ak = "#" + N.color;
            } else {
              if (z.settings.recolormode == "bylap") {
                z.colorcounter = O;
                ak = "#" + z.getnextcolor();
              } else {
                if (O == 0) {
                  ak = "#" + N.color;
                }
                ak = "#" + z.linecolors[ac + z.routes.length];
                ac++;
              }
            }
            var S = new Array();
            if (z.settings.userelativepulse) {
              var ax = N.maxpulse;
              if (ax) {
                for (var V = 0; V < N.pulse.length; V++) {
                  S[V] = (N.pulse[V] / ax) * 100;
                }
              }
            } else {
              S = N.pulse;
            }
            if (!S) {
              S = new Array();
              for (var ar = 0; ar < N.latarray.length; ar++) {
                S[ar] = NaN;
              }
            }
            for (var ar = W; ar < av; ar++) {
              if (am == "pulse") {
                U.push([ao, S[ar]]);
              } else {
                if (am == "speed") {
                  var at = 0;
                  var R = N.timearray[ar] - N.timearray[ar - 1];
                  var Q = calcdistance(
                    N.latarray[ar],
                    N.lngarray[ar],
                    N.latarray[ar - 1],
                    N.lngarray[ar - 1]
                  );
                  if (R != 0) {
                    at = Q / R;
                  }
                  U.push([ao, at]);
                }
              }
              ao++;
            }
            if (ao > ah) {
              ah = ao;
            }
            var ai = U;
            if (ad > 1) {
              ai = average_line(U, ad, an);
            }
            af.push(ai);
            ag.push({
              color: ak,
              showLine: true,
              fill: false,
              showMarker: false,
              pointLabels: { show: false, location: "x" },
              fillAndStroke: false,
              fillAlpha: 0.2,
              label: X,
            });
          }
        }
      }
    }
    var aq = "insideGrid";
    var aw = "ne";
    var ab = 3;
    if (af.length > 6) {
      aq = "outsideGrid";
      aw = "s";
      ab = 6;
    }
    var Y;
    if (
      am == "pulse" &&
      z.settings.userelativepulse &&
      z.settings.biaplot_relhrmin
    ) {
      if (z.settings.biaplot_relhrmin > 0) {
      } else {
        z.settings.biaplot_relhrmin = 50;
      }
      Y = $.jqplot(ae, af, {
        cursor: { show: true, zoom: true, showTooltip: false },
        legend: {
          show: true,
          placement: aq,
          location: aw,
          renderer: $.jqplot.EnhancedLegendRenderer,
          rendererOptions: { numberColumns: ab },
          show: true,
        },
        series: ag,
        highlighter: {
          show: true,
          sizeAdjust: 7.5,
          bringSeriesToFront: true,
          formatString: au,
        },
        axes: {
          xaxis: { min: 0, max: ah, tickOptions: { formatString: "%d s" } },
          yaxis: {
            min: z.settings.biaplot_relhrmin,
            max: 100,
            tickOptions: { formatString: T },
          },
        },
        seriesDefaults: { color: "#ff0000" },
        title: ap,
      });
    } else {
      Y = $.jqplot(ae, af, {
        cursor: { show: true, zoom: true, showTooltip: false },
        legend: {
          show: true,
          placement: aq,
          location: aw,
          renderer: $.jqplot.EnhancedLegendRenderer,
          rendererOptions: { numberColumns: ab },
          show: true,
        },
        series: ag,
        highlighter: {
          show: true,
          sizeAdjust: 7.5,
          bringSeriesToFront: true,
          formatString: au,
        },
        axes: {
          xaxis: { min: 0, max: ah, tickOptions: { formatString: "%d s" } },
          yaxis: { tickOptions: { formatString: T } },
        },
        seriesDefaults: { color: "#ff0000" },
        title: ap,
      });
    }
    return Y;
  };
  this.plot_biabars = function (V, ab) {
    var Z = $("#biastatsort").val();
    var ar = 0;
    z = mapviewer;
    z.find_biathlon_keyinfo();
    var R = new Array();
    var aq = new Array();
    var ah = new Array();
    var ag;
    var ac;
    var am;
    var ao;
    var an = [];
    if (ab == "pulse") {
      S = "Comparison of HR before/after shooting";
      ac = "%.1f";
      af = ["#008800", "#aa6600", "#880000", "#666666"];
      barlabels = [
        "HR at end of shooting",
        "HR during shooting",
        "HR before shooting",
        "Max HR lap",
      ];
      ao = false;
    } else {
      if (ab == "time") {
        S = "Comparison of shooting & range time";
        ac = "%.1f";
        af = ["#83157c", "#8758a7", "#8896c6", "#92bbe5"];
        barlabels = [
          "Time before shooting [s]",
          "Shooting time [s]",
          "Range XC time [s]",
          "Penalty time [s]",
        ];
        ao = true;
      }
    }
    for (var X = 0; X < af.length; X++) {
      an.push({ label: barlabels[X], color: af[X] });
    }
    var af;
    var S;
    var aj = new Array();
    for (var U = 0; U < z.routes.length; U++) {
      var N = z.routes[U];
      if (N.show && z.courseinfo.lap_spacing) {
        ar++;
        for (var W = 0; W < mapviewer.courseinfo.lap_spacing.length; W++) {
          var ak = N.shootinfo[W];
          if (ak) {
            var ae = N.runnername_middle;
            ae = ae.replace(/ - 1$/, "");
            if (!mapviewer.settings.graphsettings.barplotstacked_writelaptxt) {
              aj.push(ae + ": " + (W + 1));
            } else {
              aj.push("L" + ae + " lap " + (W + 1));
            }
            var aa = ak.maxhr_lap;
            var al = ak.hr_before_range;
            var ai = ak.hr_start_shooting;
            var Y = ak.hr_finish_shooting;
            if (1) {
              console.log("Note! Forcing relative pulse?!");
              aa = ak.maxhr_lap_rel;
              al = ak.hr_before_range_rel;
              ai = ak.hr_start_shooting_rel;
              Y = ak.hr_finish_shooting_rel;
            }
            if (ab == "pulse") {
              var T;
              var Q;
              var O;
              var M;
              T = Y;
              if (ai > Y) {
                Q = ai - Y;
              } else {
                Q = 0;
              }
              if (al > ai) {
                O = al - ai;
              } else {
                O = 0;
              }
              M = aa - al;
              if (M < 0) {
                M = 0;
              }
              R.push([T, Q, O, M]);
            } else {
              if (ab == "time") {
                R.push([
                  ak.t_before_shooting,
                  ak.t_shooting,
                  ak.t_range_minus_shooting,
                  ak.t_penalty,
                ]);
              }
            }
            if (Z == "HR_before_shooting") {
              aq.push(ai);
            } else {
              if (Z == "HR_after_shooting") {
                aq.push(Y);
              } else {
                if (Z == "HR_before_range") {
                  aq.push(al);
                } else {
                  if (Z == "Time_shooting") {
                    aq.push(ak.t_shooting);
                  } else {
                    if (Z == "Time_after") {
                      aq.push(ak.t_penalty);
                    } else {
                      if (Z == "Time_total") {
                        aq.push(
                          ak.t_before_shooting + ak.t_shooting + ak.t_penalty
                        );
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (aq.length > 0) {
      aq = sortWithIndeces(aq);
      var ap = new Array();
      var ad = new Array();
      for (var X = 0; X < aq.length; X++) {
        ap[X] = R[aq.sortIndices[X]];
        ad[X] = aj[aq.sortIndices[X]];
      }
      if (ab == "time") {
        $("#" + V).empty();
        barplot_stacked(V, S, transpose(ap), ad, af, aj.length, an, ao, 0);
      } else {
        $("#" + V).empty();
        barplot_stacked(V, S, transpose(ap), ad, af, aj.length, an, ao);
      }
    } else {
      if (ab == "time") {
        $("#" + V).empty();
        barplot_stacked(V, S, transpose(R), aj, af, ar, an, ao, 0);
      } else {
        $("#" + V).empty();
        barplot_stacked(V, S, transpose(R), aj, af, ar, an, ao);
      }
    }
    console.log(
      "Feature for later?: Plot horizontal line for fastest / lowest? For time in to shooting and for total?"
    );
    console.log("Feature for later?: Plot tot_time as a function of %HR?");
  };
  this.savearea_zoom = function (M, Q, O) {
    if (!Q) {
      Q = new Date().valueOf();
    }
    if (O == undefined) {
      O = 800;
    }
    target_zf = M;
    z.settings.isprinting = 1;
    zf = z.canvas.zoomfactor;
    ch = z.canvas.canvaselement.height;
    cw = z.canvas.canvaselement.width;
    newh = (ch * target_zf) / zf;
    neww = (cw * target_zf) / zf;
    if (newh < O) {
      target_zf = (target_zf * O) / newh;
    }
    newh = (ch * target_zf) / zf;
    neww = (cw * target_zf) / zf;
    z.settings.routewidth = (z.settings.routewidth * target_zf) / zf;
    z.canvas.outlinetxtsize = (z.canvas.outlinetxtsize * target_zf) / zf;
    z.canvas.canvaselement.height = newh;
    z.canvas.canvaselement.width = neww;
    z.canvas.height = newh;
    z.canvas.width = neww;
    z.canvas.zoomfactor = target_zf;
    z.redraw();
    z.play_loop();
    z.canvas.saveDataURL(Q);
    z.settings.routewidth = z.settings.routewidth / (target_zf / zf);
    z.canvas.outlinetxtsize = z.canvas.outlinetxtsize / (target_zf / zf);
    z.canvas.zoomfactor = zf;
    z.canvas.canvaselement.height = ch;
    z.canvas.canvaselement.width = cw;
    z.canvas.height = ch;
    z.canvas.width = cw;
    var N = -mapviewer.canvas.rotate_angle;
    mapviewer.canvas.rotate_angle = 0;
    mapviewer.canvas.context.rotate(-N);
    z.settings.isprinting = 0;
    z.request_redraw();
  };
  this.savelegs = function (N, T, Z, S) {
    z.settings.showcourse = 0;
    z.autoname_tags();
    if (!Z) {
      if (T == 0) {
        Z = 0.3;
      } else {
        Z = 0.45;
      }
    }
    if (!S) {
      if (T == 2) {
        z.canvas.outlinetxtsize = 55;
      } else {
        z.canvas.outlinetxtsize = 35;
      }
    }
    if (T == 2) {
      mapviewer.settings.tagging_timealt = 4;
    } else {
      if (T == 1) {
        mapviewer.settings.tagging_timealt = 0;
      }
    }
    if (T == 0 || T == 1 || T == 2) {
      z.settings.routewidth = 18;
      if (T == 1 || T == 2) {
        z.settings.mapopacity = 0.7;
      } else {
        z.settings.mapopacity = 1;
      }
      for (var M = 0; M < z.routes.length; M++) {
        z.routes[M].show = 0;
      }
    } else {
      if (T == 3) {
      }
    }
    z.togglerightmenu("togglerightmenu");
    for (var O = 0; O < z.coursecoords.length - 1; O++) {
      z.centerleg(O, Z);
      if (T == 3) {
        controlnu = O + 1;
        minoffset = 1e99;
        for (var M = 0; M < z.routes.length; M++) {
          var R = z.routes[M];
          var Q = R.splits[controlnu];
          var X = R.splits[controlnu - 1];
          if (Q && X) {
            var Y = Q.index;
            var W = Y - X.index;
            R.offset = Q.index - (z.zerotime - R.zerotime);
            R.taillength = W;
            R.segmenttime = W;
            R.segmentlength = R.calc_length(X.index, Q.index);
            if (R.offset < minoffset) {
              minoffset = R.offset;
            }
          } else {
            R.segmenttime = -1;
            R.segmentlength = -1;
            R.segmentpace = 0;
            R.taillength = -1;
          }
        }
        if (R.segmenttime == -1 || isNaN(R.segmentlength)) {
          R.segmentlength = -1;
        }
        if (minoffset < 1e99) {
          for (var M = 0; M < z.routes.length; M++) {
            z.routes[M].offset = z.routes[M].offset - minoffset;
          }
          z.playtime = z.zerotime + minoffset;
          routes[M].setpos(0, z.playtime);
        }
      }
      if (T == 0) {
        z.redraw();
        z.play_loop();
        z.canvas.saveDataURL(N + "_" + (O + 1));
      }
      if (T == 3) {
        z.redraw();
        z.play_loop();
        z.canvas.saveDataURL(N + "_routes_" + (O + 1));
      }
      if (T == 1 || T == 2) {
        z.showtags_control(O + 1);
        var V = 0;
        for (var M = 0; M < z.tags.length; M++) {
          var U = z.tags[M];
          if (U.show && U.type == "route") {
            V++;
          }
        }
        if (V > 0) {
          z.redraw();
          z.play_loop();
          if (T == 1) {
            z.canvas.saveDataURL(N + "_" + (O + 1) + "_alt");
          } else {
            if (T == 2) {
              z.canvas.saveDataURL(N + "_" + (O + 1) + "_altnol");
            }
          }
        }
      }
    }
    z.togglerightmenu("togglerightmenu");
    z.settings.showcourse = 1;
  };
  this.savelegs_new = function (al) {
    z = mapviewer;
    var S = "";
    var ai;
    if (z.map.id == "localimage") {
      ai = z.map.name;
    } else {
      ai = "img";
    }
    ai = ai.replace(/\.jpg/g, "");
    ai = ai.replace(/\.gif/g, "");
    ai = ai.replace(/_\d+/g, "");
    ai = ai.replace(/|/g, "");
    ai = ai.replace(/[\. 骧邃鯻]/g, "");
    var aj = 15;
    z.settings.showcourse = 0;
    z.autoname_tags();
    for (var ab = 0; ab < z.coursecoords.length - 1; ab++) {
      z.settings.centerlegnum = ab + 1;
      z.showtags_control(ab + 1);
      var ac = 0;
      var Y = 0;
      fact = 0.25;
      while (!Y) {
        Y = 1;
        for (var N = 0; N < z.tags.length; N++) {
          z.centerleg(ab, fact);
          var U = z.tags[N];
          if (U.show && U.type == "route") {
            for (var ah = 0; ah < U.pointsxy.length; ah++) {
              var T = U.pointsxy[ah].split(",");
              var X = T[0];
              var W = T[1];
              var V = -z.canvas.rotate_angle;
              sx1 =
                z.canvas.width / 2 + (X - z.canvas.cx) * z.canvas.zoomfactor;
              sy1 =
                z.canvas.height / 2 + (W - z.canvas.cy) * z.canvas.zoomfactor;
              sx2 = sx1 * Math.cos(V) + sy1 * Math.sin(V);
              sy2 = -(sx1 * Math.sin(V)) + sy1 * Math.cos(V);
              if (
                sx2 > aj &&
                sy2 > aj &&
                sx2 < z.canvas.width - aj &&
                sy2 < z.canvas.height - aj
              ) {
              } else {
                Y = 0;
              }
            }
          }
        }
        if (Y == 0) {
          fact = fact + 0.01;
        }
      }
      for (var N = 0; N < z.tags.length; N++) {
        z.tags[N].show = 0;
      }
      for (var R = 0; R <= 3; R++) {
        var am;
        if (R == 0) {
          if (al == 1) {
            am = "_A";
          } else {
            am = "_no";
          }
          mapviewer.settings.tagging_timealt = 0;
          mapviewer.settings.showtagmode = 0;
          z.settings.mapopacity = 0.8;
        } else {
          if (R == 1) {
            if (al == 1) {
              am = "_B";
            } else {
              am = "_va";
            }
            mapviewer.settings.tagging_timealt = 4;
            mapviewer.settings.showtagmode = 1;
            z.settings.mapopacity = 0.5;
          } else {
            if (R == 2) {
              if (al == 1) {
                am = "_C";
              } else {
                am = "";
              }
              mapviewer.settings.tagging_timealt = 0;
              mapviewer.settings.showtagmode = 1;
              z.settings.mapopacity = 0.5;
            } else {
              if (R == 3) {
                if (al == 1) {
                  am = "";
                } else {
                  am = "";
                }
              }
            }
          }
        }
        var Z =
          "leg_" +
          parseInt(z.settings.centerlegnum).toFixed().pad(2, "0") +
          "_" +
          ai;
        var ak = Z + am;
        if (R == 3) {
          var an = "";
          var ad = new Array();
          var Q = new Array();
          for (var N = 0; N < z.tags.length; N++) {
            var U = z.tags[N];
            if (U.type == "route" && U.show) {
              an += U.name + ";" + parseInt(U.length) + "\n";
              ad.push(U.name);
              Q.push(parseInt(U.length));
            }
          }
          z.savetxtfile(ak, an);
          S =
            S +
            ai +
            "|" +
            (ab + 1) +
            "|" +
            Z +
            ".jpg|" +
            ad.join(";") +
            "|" +
            Q.join(";") +
            "|\n";
        } else {
          z.togglerightmenu("togglerightmenu");
          z.centerleg(ab, fact);
          if (R == 1 || R == 2) {
            z.showtags_control(ab + 1);
            var ac = 0;
            for (var N = 0; N < z.tags.length; N++) {
              var U = z.tags[N];
              if (U.show && U.type == "route") {
                ac++;
              }
            }
          }
          var ag = z.canvas.context.transformedPoint(0, 0).x;
          var O = z.canvas.context.transformedPoint(0, 0).y;
          var af = z.canvas.context.transformedPoint(
            mapviewer.canvas.width,
            mapviewer.canvas.height
          ).x;
          var M = z.canvas.context.transformedPoint(
            mapviewer.canvas.width,
            mapviewer.canvas.height
          ).y;
          var ae = Math.sqrt((af - ag) * (af - ag) + (M - O) * (M - O));
          var aa = 1;
          if (ae < 1200) {
            aa = 1200 / ae;
          }
          z.savearea_zoom(aa, ak);
        }
      }
    }
    z.savetxtfile("config.txt", S);
  };
  this.savemistakes = function (S, Z, ag) {
    antcntrls = z.coursecoords.length;
    var R = new Array();
    var Q = 3;
    if (!Z && Z != 0) {
      Z = 15;
    }
    if (!ag) {
      ag = z.routes.length;
    }
    if (ag == "All") {
      ag = z.routes.length;
    }
    if (ag == "Selected") {
      ag = z.routes.length;
      for (var U = 0; U < z.routes.length; U++) {
        if (z.routes[U].show == 1) {
          R[U] = 1;
        } else {
          R[U] = 0;
        }
      }
    }
    var al = new Array();
    var X = new Array();
    var ar = new Array();
    for (var T = 1; T < antcntrls - 1; T++) {
      var aj = new Array();
      for (var U = 0; U < z.routes.length; U++) {
        var M = z.routes[U];
        if (M.splits) {
          Y = 0;
          if (M.splits[T]) {
            Y = M.splits[T].index - M.splits[T - 1].index;
          }
          if (Y > 0) {
            aj.push(Y);
          }
        }
      }
      sortWithIndeces(aj);
      if (aj.length < Q) {
        Q = aj.length;
      }
      var ap = 0;
      for (var U = 0; U < Q; U++) {
        ap = ap + aj[U];
      }
      ap = Math.floor(ap / Q);
      X[T - 1] = ap;
      al[T - 1] = aj[0];
      var aa = aj.sortIndices[0];
      ar[T - 1] = aa;
    }
    tmptmp = ar;
    var af = new Array();
    for (var U = 0; U < z.routes.length; U++) {
      var O = new Array();
      var W = new Array();
      var aq = new Array();
      var M = z.routes[U];
      if (M.splits) {
        if (M.splits[antcntrls - 1]) {
          tottime = M.splits[antcntrls - 1].index - M.splits[0].index;
          for (var T = 1; T < antcntrls; T++) {
            var Y = M.splits[T].index - M.splits[T - 1].index;
            aq[T - 1] = Y;
            var V = Y - al[T - 1];
            var ah = (V / al[T - 1]) * 100;
            if (ah < 0) {
              ah = 0;
            }
            W[T - 1] = ah;
            O[T - 1] = V;
          }
          M.behindpsplits = W.splice(0);
          M.behindsplits = O.splice(0);
          M.splittimes = aq.splice(0);
          M.tottime = tottime;
        } else {
          tottime = 1e99;
        }
      } else {
        tottime = 1e99;
      }
      if (tottime < 0) {
        tottime = 1e99;
      }
      af.push(tottime);
    }
    sortWithIndeces(af);
    var am = "";
    var ao = "";
    for (var U = 0; U < ag; U++) {
      var ac = 0;
      if (R.length > 0) {
        if (R[af.sortIndices[U]] == 1) {
          ac = 1;
        }
      } else {
        ac = 1;
      }
      if (ac) {
        var M = z.routes[af.sortIndices[U]];
        var N = "<b>" + M.runnername + "</b><br>";
        var ao = "";
        if (M.behindsplits) {
          var V = M.behindsplits.join(";").split(";");
          if (Z >= 0) {
            sortWithIndeces(V);
            for (var ai = 0; ai < V.length; ai++) {
              if (isNaN(V[ai])) {
                V[ai] = 0;
              }
            }
          } else {
            asortWithIndeces(V);
            for (var ai = 0; ai < V.length; ai++) {
              if (isNaN(V[ai])) {
                V[ai] = Infinity;
              }
            }
          }
          for (var ak = V.length - 1; ak > 0; ak--) {
            cntrlnum = V.sortIndices[ak];
            timeloss = M.behindsplits[cntrlnum];
            if ((timeloss >= Z && Z >= 0) || (timeloss <= -Z && Z < 0)) {
              z.settings.colormode = z.settings.modes.colorbyorg;
              z.drawroutechoice_leg(cntrlnum + 1);
              for (var ae = 0; ae < z.routes.length; ae++) {
                z.routes[ae].show = 0;
              }
              M.show = 1;
              M.color = "ff0000";
              z.routes[ar[cntrlnum]].show = 1;
              z.routes[ar[cntrlnum]].color = "0000ff";
              if (!S) {
                z.togglerightmenu("togglerightmenu");
                z.drawroutechoice_leg(cntrlnum + 1);
                z.centerleg(cntrlnum, 0.2);
                z.center_drawn_routes();
                z.update_routediv();
                z.settings.showcourse = 0;
                z.settings.mode = z.settings.modes.AnalysisMode;
                z.drawroutes();
                z.redraw();
                z.play_loop();
                var ad = cntrlnum + 1;
                var an =
                  M.runnername +
                  "_" +
                  ad.toFixed().pad(2, "0") +
                  "_" +
                  timeloss.toFixed().pad(3, "0");
                z.canvas.saveDataURL(an, null, 1);
                z.togglerightmenu("togglerightmenu");
              }
              var ab =
                cntrlnum +
                "|" +
                M.indexnumber +
                "|" +
                z.routes[ar[cntrlnum]].indexnumber;
              savestr = "";
              if (z.settings.enableprintscreen) {
                savestr =
                  ' <a href="javascript:void(0);" onclick="mapviewer.savethisleg(' +
                  (cntrlnum + 1) +
                  ",'" +
                  M.runnername +
                  "')\">S</a>";
              }
              ao +=
                '- <a href="javascript:void(0);" onclick="mapviewer.showroutesleg(' +
                cntrlnum +
                "," +
                M.indexnumber +
                "," +
                z.routes[ar[cntrlnum]].indexnumber +
                ');return(false);">Control ' +
                (cntrlnum + 1) +
                ": +" +
                tominsec(timeloss) +
                '</a> <a href="javascript:void(0);" title="Toggle autOanalysis display" onclick="if (mapviewer.settings.autoanalysis) {mapviewer.settings.autoanalysis=0;} else {mapviewer.settings.autoanalysis=1;} mapviewer.request_redraw();">A</a>' +
                savestr +
                "<br>";
            } else {
              ak = 0;
            }
          }
        }
        if (ao) {
          am = am + "<br>" + N + ao;
        }
      }
    }
    $("#xinfodiv").html(am);
  };
  this.showroutesleg = function (O, N, M) {
    z.settings.colormode = z.settings.modes.colorbyorg;
    for (var Q = 0; Q < z.routes.length; Q++) {
      if (z.routes[Q].indexnumber == N || z.routes[Q].indexnumber == M) {
        z.routes[Q].show = 1;
        z.routes[Q].color = "ff0000";
        if (z.routes[Q].indexnumber == M) {
          z.routes[Q].color = "0000ff";
        }
      } else {
        z.routes[Q].show = 0;
      }
    }
    z.drawroutechoice_leg(O + 1);
    z.centerleg(O, 0.2);
    z.center_drawn_routes();
    z.drawroutes();
    z.AutOanalysis();
    z.redraw();
  };
  this.savethisleg = function (O, N) {
    var Q = "";
    if (!z.settings.savenamecounter) {
      z.settings.savenamecounter = new Array();
    }
    if (!z.settings.savenamecounter[parseInt(z.settings.centerlegnum)]) {
      z.settings.savenamecounter[parseInt(z.settings.centerlegnum)] = 0;
    }
    z.settings.savenamecounter[parseInt(z.settings.centerlegnum)]++;
    if (z.settings.savenamecounter[parseInt(z.settings.centerlegnum)] > 1) {
      Q =
        "_" +
        parseInt(z.settings.savenamecounter[parseInt(z.settings.centerlegnum)])
          .toFixed()
          .pad(2, "0");
    }
    var M;
    if (z.map.id == "localimage") {
      M = z.map.name;
    } else {
      M = "img";
    }
    M = M.replace(/\.jpg/g, "");
    M = M.replace(/_\d+/g, "");
    M = M.replace(/[\. 骧邃鯻]/g, "");
    var R =
      "leg_" + parseInt(O).toFixed().pad(2, "0") + "_" + M + "_" + N + "_" + Q;
    z.redraw();
    z.play_loop();
    z.canvas.saveDataURL(R);
  };
  this.parse_xml_general = function (M) {
    tmptmp8 = M;
    if ($(parseXml(M)).find("PersonResult").length) {
      mapviewer.parse_xmlsplits_fromtxt(M);
    } else {
      if (M.match("2DRerun event")) {
        mapviewer.parse_xmlcoursenew_fromtxt(M);
      } else {
        mapviewer.parse_xmlocadcourse_fromtxt(M);
      }
    }
  };
  this.parse_xmlcoursenew_fromtxt = function (M) {
    console.log("XML-course saved from 2DRerun");
    z.coursecoords_latlng = new Array();
    var N = 0;
    $(parseXml(M))
      .find("Control")
      .each(function () {
        if ($(this).find("Position").attr("lat")) {
          var Q = parseFloat($(this).find("Position").attr("lat"));
          var O = parseFloat($(this).find("Position").attr("lng"));
          z.coursecoords_latlng[N] = Q + "," + O;
          N = N + 1;
        }
      });
    if (N > 0) {
      mapviewer.update_coursecoords_fromlatlng();
      mapviewer.request_redraw();
    }
  };
  this.parse_xmlocadcourse_fromtxt = function (O) {
    var X = 1e99;
    var W = 1e99;
    var T = -1e99;
    var S = -1e99;
    var V = new Array();
    $(parseXml(O))
      .find("StartPoint")
      .each(function () {
        code = $(this).find("StartPointCode").text();
        var Z = parseFloat($(this).find("ControlPosition").attr("x"));
        var ac = -parseFloat($(this).find("ControlPosition").attr("y"));
        var ab = parseFloat($(this).find("MapPosition").attr("x"));
        var aa = parseFloat($(this).find("MapPosition").attr("y"));
        if (Z < X) {
          X = Z;
        }
        if (ac < W) {
          W = ac;
        }
        if (Z > T) {
          T = Z;
        }
        if (ac > S) {
          S = ac;
        }
        var Y = new Object();
        Y.x = Z;
        Y.y = ac;
        Y.mapx = ab;
        Y.mapy = aa;
        Y.code = code;
        V[code] = Y;
      });
    $(parseXml(O))
      .find("Control")
      .each(function () {
        code = $(this).find("ControlCode").text();
        var Z = parseFloat($(this).find("ControlPosition").attr("x"));
        var ac = -parseFloat($(this).find("ControlPosition").attr("y"));
        var ab = parseFloat($(this).find("MapPosition").attr("x"));
        var aa = parseFloat($(this).find("MapPosition").attr("y"));
        if (Z < X) {
          X = Z;
        }
        if (ac < W) {
          W = ac;
        }
        if (Z > T) {
          T = Z;
        }
        if (ac > S) {
          S = ac;
        }
        var Y = new Object();
        Y.x = Z;
        Y.y = ac;
        Y.mapx = ab;
        Y.mapy = aa;
        Y.code = code;
        V[code] = Y;
      });
    $(parseXml(O))
      .find("FinishPoint")
      .each(function () {
        code = $(this).find("FinishPointCode").text();
        var Z = parseFloat($(this).find("ControlPosition").attr("x"));
        var ac = -parseFloat($(this).find("ControlPosition").attr("y"));
        var ab = parseFloat($(this).find("MapPosition").attr("x"));
        var aa = parseFloat($(this).find("MapPosition").attr("y"));
        if (Z < X) {
          X = Z;
        }
        if (ac < W) {
          W = ac;
        }
        if (Z > T) {
          T = Z;
        }
        if (ac > S) {
          S = ac;
        }
        var Y = new Object();
        Y.x = Z;
        Y.y = ac;
        Y.mapx = ab;
        Y.mapy = aa;
        Y.code = code;
        V[code] = Y;
      });
    mapviewer.ocadtranslate.x0 = -X;
    mapviewer.ocadtranslate.y0 = -W;
    var Q = mapviewer.map.width / Math.abs(T - X);
    var N = mapviewer.map.height / Math.abs(S - W);
    var M = Math.min(Q, N);
    mapviewer.ocadtranslate.scalex = M;
    mapviewer.ocadtranslate.scaley = M;
    var R =
      "Choose course<br><select id='ocadcourseselect' onChange=\"mapviewer.ocadcourse_to_coursecoords(parseInt($('#ocadcourseselect').val()));\">";
    var U = new Array();
    $(parseXml(O))
      .find("Course")
      .each(function () {
        var Z = 0;
        var Y = new Object();
        Y.controls = new Array();
        Y.legl = new Array();
        Y.name = $(this).find("CourseName").text();
        Y.id = parseInt($(this).find("CourseId").text());
        var aa = $(this).find("StartPointCode").text();
        Y.controls.push(aa);
        $(this)
          .find("CourseControl")
          .each(function () {
            var ac = $(this).find("Sequence").text();
            var ad = $(this).find("ControlCode").text();
            var ae = parseFloat($(this).find("LegLength").text());
            Z = Z + ae;
            Y.controls.push(ad);
            Y.legl.push(ae);
          });
        var aa = $(this).find("FinishPointCode").text();
        var ab = parseFloat($(this).find("DistanceToFinish").text());
        Y.controls.push(aa);
        Y.legl.push(ab);
        Z = Z + ab;
        Y.totl = Z;
        U.push(Y);
        R =
          R + "<option value='" + (U.length - 1) + "'>" + Y.name + "</option>";
      });
    mapviewer.ocadcourses = U;
    mapviewer.ocadcontrols = V;
    mapviewer.ocadcourse_to_coursecoords(0);
    mapviewer.showcourse = 1;
    mapviewer.settings.alwaysshowcourse = 1;
    R = R + "</select>";
    $("#ocadcourses").html(R);
    mapviewer.ocadtranslate.select_box = R;
    mapviewer.request_redraw();
    mapviewer.ocadcourse_mousescale();
  };
  this.ocadcourse_to_coursecoords = function (N) {
    var M = z.ocadcourses[N];
    z.ocadtranslate.currentcourse = N;
    var T = new Array();
    for (var S = 0; S < M.controls.length; S++) {
      var R = M.controls[S];
      var Q =
        (mapviewer.ocadcontrols[R].x + mapviewer.ocadtranslate.x0) *
        mapviewer.ocadtranslate.scalex;
      var O =
        (mapviewer.ocadcontrols[R].y + mapviewer.ocadtranslate.y0) *
        mapviewer.ocadtranslate.scaley;
      T.push(Q + "," + O);
    }
    mapviewer.coursecoords = T;
    mapviewer.request_redraw();
  };
  this.ocadcourse_mousescale = function () {
    z.waitforclick = 1;
    z.ocadtranslate.scaleclicks = new Array();
    alert(this.ocadtranslate.clickinfo[0]);
    z.waitforclickfunction = function (M, Q, N) {
      var O = new Object();
      O.x = M;
      O.y = Q;
      z.ocadtranslate.scaleclicks.push(O);
      if (z.ocadtranslate.scaleclicks.length <= 3) {
        alert(this.ocadtranslate.clickinfo[z.ocadtranslate.scaleclicks.length]);
      } else {
        mapviewer.waitforclick = 0;
        mapviewer.ocadcourse_scale();
      }
    };
  };
  this.ocadcourse_scale = function () {
    z = mapviewer;
    var W = z.ocadtranslate.scaleclicks[0].x;
    var U = z.ocadtranslate.scaleclicks[0].y;
    var T = z.map.tolatlng(W, U);
    var R = z.findclosestcontrol(T.lat, T.lng).index;
    var N = z.ocadcourses[z.ocadtranslate.currentcourse];
    var Z = z.ocadcontrols[N.controls[R]].x;
    var M = z.ocadcontrols[N.controls[R]].y;
    var W = z.ocadtranslate.scaleclicks[2].x;
    var U = z.ocadtranslate.scaleclicks[2].y;
    var T = z.map.tolatlng(W, U);
    var R = z.findclosestcontrol(T.lat, T.lng).index;
    var N = z.ocadcourses[z.ocadtranslate.currentcourse];
    var ah = z.ocadcontrols[N.controls[R]].x;
    var V = z.ocadcontrols[N.controls[R]].y;
    var ad = z.ocadtranslate.scaleclicks[1].x;
    var Q = z.ocadtranslate.scaleclicks[1].y;
    var ac = z.ocadtranslate.scaleclicks[3].x;
    var O = z.ocadtranslate.scaleclicks[3].y;
    var Y = ac - ad;
    var ag = ah - Z;
    var X = O - Q;
    var af = V - M;
    var ab = Y / ag;
    var aa = X / af;
    var ae = ad / ab - Z;
    var S = Q / aa - M;
    mapviewer.ocadtranslate.x0 = ae;
    mapviewer.ocadtranslate.y0 = S;
    mapviewer.ocadtranslate.scalex = ab;
    mapviewer.ocadtranslate.scaley = aa;
    z.ocadcourse_to_coursecoords(z.ocadtranslate.currentcourse);
  };
  this.parse_xmlsplits_fromtxt = function (N) {
    var U = new Array();
    var O = 0;
    var T = "";
    var S = 1;
    $(parseXml(N))
      .find("PersonResult")
      .each(function () {
        name = $(this).find("Given").text();
        family = $(this).find("Family").text();
        if (family) {
          name = family + " " + name;
        }
        tottime = $(this).find("Time").find("Clock").text();
        if (!tottime) {
          tottime = $(this).find("FinishTime").find("Clock").text();
        }
        if (!tottime) {
          alltimes = $(this).find("Result").find("Time");
          tottime = alltimes.first().text();
          tottime = tominsec(tottime);
          S = 3;
        }
        starttime = $(this).find("StartTime").text();
        result = $(this).find("Result");
        ok = 0;
        rstatus = $(this).find("CompetitorStatus");
        if (rstatus) {
          rstatus = rstatus.attr("value");
          if (!rstatus) {
            rstatus = $(this).find("Status").text();
          }
          if (rstatus == "OK") {
            ok = 1;
          }
        }
        if (ok) {
          var V = "";
          prevsecs = 0;
          $(parseXml(result))
            .find("SplitTime")
            .each(function () {
              time = $(this).find("Time").text();
              hms = time.split(":");
              if (hms.length == 3) {
                secs =
                  parseFloat(hms[2]) +
                  parseFloat(hms[1]) * 60 +
                  parseFloat(hms[0]) * 3600;
              } else {
                if (hms.length == 2) {
                  secs = parseFloat(hms[1]) * 60 + parseFloat(hms[0]) * 3600;
                } else {
                  secs = parseFloat(time);
                }
              }
              thissecs = secs - prevsecs;
              V = V + tominsec(thissecs) + ";";
              prevsecs = secs;
            });
          hms = tottime.split(":");
          secs =
            parseFloat(hms[2]) +
            parseFloat(hms[1]) * 60 +
            parseFloat(hms[0]) * 3600;
          thissecs = secs - prevsecs;
          V = V + tominsec(thissecs);
          U[name] = V;
          name = name.replace(/^[\d\+\s\-]+/g, "");
        } else {
        }
        O++;
      });
    U = U.sort();
    var T = "";
    var R = keys(U).sort();
    for (var Q in R) {
      name = R[Q];
      if (U.hasOwnProperty(name)) {
        var M = U[name];
        M = M.replace(/^[\d\+\s\-]+/g, "");
        T = T + name + ";" + U[name] + "\n";
      }
    }
    z.doloadsplits(0, T);
  };
  this.center_drawn_routes = function () {
    var al = z.playtime;
    var aj = new Array();
    var N = new Array();
    var M = new Array();
    var ac = new Array();
    var X = -z.canvas.rotate_angle;
    for (var S = 0; S < z.routes.length; S++) {
      var ak = z.routes[S];
      if (ak.show) {
        var ag = ak.taillength;
        if (ag > 0) {
          var W = al - parseFloat(ag);
          var T = ak.findTimeIndex(al + parseFloat(ak.offset));
          var U = ak.findTimeIndex(W + parseFloat(ak.offset));
          if (U == -Infinity) {
            U = 0;
          }
          if (T >= ak.latarray.length) {
            T = ak.latarray.length - 1;
          }
          drawStep = 1;
          for (var ai = T; ai >= U + 1; ai = ai - drawStep) {
            lat = ak.latarray[ai];
            lng = ak.lngarray[ai];
            P = z.map.toxy(lat, lng);
            x1 = P.x;
            y1 = P.y;
            x2 = x1 * Math.cos(X) + y1 * Math.sin(X);
            y2 = -x1 * Math.sin(X) + y1 * Math.cos(X);
            aj.push(x2);
            N.push(y2);
            M.push(x1);
            ac.push(y1);
          }
        }
      }
    }
    var O = 0.2;
    var Y = z.canvas.width;
    var ah = z.canvas.height;
    var ad = aj.max() - aj.min();
    var ab = N.max() - N.min();
    var R = (M.max() + M.min()) / 2;
    var Q = (ac.max() + ac.min()) / 2;
    var aa = Math.abs(Math.sqrt(ad * ad));
    var af = Y / (aa + Y * O);
    var Z = Math.abs(Math.sqrt(ab * ab));
    var ae = ah / (Z + ah * O);
    var V = af;
    if (ae < af) {
      V = ae;
    }
    if (!isNaN(V)) {
      z.canvas.zoomfactor = V;
      z.move_mapxy_to_center(R, Q);
      z.request_redraw();
      return 1;
    } else {
      return 0;
    }
  };
  this.rotatesplit = function () {
    if (
      (z.settings.lastclick_x == 0 && z.settings.lastclick_y == 0) ||
      (z.settings.thisclick_x == 0 && z.settings.thisclick_y == 0)
    ) {
    } else {
      z.canvas.use_rotate = 1;
      z.canvas.mouse_rotate = 0;
      var O = z.canvas.rotate_angle;
      z.canvas.context.rotate(-O);
      var S = z.settings.lastclick_x;
      var Q = z.settings.lastclick_y;
      var T = z.settings.thisclick_x;
      var R = z.settings.thisclick_y;
      var N = T - S;
      var M = R - Q;
      var U = z.settings.autrotanglemodes[z.settings.autrotanglemode];
      var V;
      if (!U || U == "Vertical") {
        V = Math.atan2(N, -M);
      } else {
        if (U == "Horizontal") {
          V = Math.atan2(M, N);
        } else {
          if (U == "10 deg") {
            V = Math.atan2(M, N) + (10 / 180) * 3.1415926;
          } else {
            if (U == "20 deg") {
              V = Math.atan2(M, N) + (20 / 180) * 3.1415926;
            } else {
              if (U == "30 deg") {
                V = Math.atan2(M, N) + (30 / 180) * 3.1415926;
              } else {
                if (U == "40 deg") {
                  V = Math.atan2(M, N) + (40 / 180) * 3.1415926;
                } else {
                  if (U == "50 deg") {
                    V = Math.atan2(M, N) + (50 / 180) * 3.1415926;
                  }
                }
              }
            }
          }
        }
      }
      z.canvas.context.rotate(-V);
      z.canvas.mouse_rotate = 1;
      var W = z.center_drawn_routes();
      if (!W) {
        z.canvas.context.rotate(V);
      }
      z.request_redraw();
    }
  };
  this.centerleg = function (U, M) {
    if (!M) {
      M = 0.3;
    }
    z.canvas.use_rotate = 1;
    z.canvas.mouse_rotate = 0;
    var Y = z.canvas.rotate_angle;
    z.canvas.context.rotate(-Y);
    var W = U + 1;
    var ad = z.coursecoords[U].split(",");
    var aa = parseFloat(ad[0]);
    var Z = parseFloat(ad[1]);
    var ad = z.coursecoords[W].split(",");
    var Q = parseFloat(ad[0]);
    var O = parseFloat(ad[1]);
    var ae = (aa + Q) / 2;
    var ab = (Z + O) / 2;
    var R = mapviewer.canvas.width;
    var X = mapviewer.canvas.height;
    var V = Q - aa;
    var T = O - Z;
    var ac = Math.atan2(V, -T);
    z.canvas.context.rotate(-ac);
    var S = Math.abs(Math.sqrt(V * V + T * T));
    var N = X / (S + X * M);
    mapviewer.canvas.zoomfactor = N;
    mapviewer.move_mapxy_to_center(ae, ab);
    mapviewer.request_redraw();
    (mapviewer.canvas.rotate_angle * 180) / Math.PI;
  };
  this.centerleg_norotate = function (V, M) {
    if (!M) {
      M = 0.3;
    }
    z.canvas.use_rotate = 1;
    var ab = z.canvas.rotate_angle;
    z.canvas.context.rotate(-ab);
    z.canvas.use_rotate = 0;
    z.canvas.mouse_rotate = 0;
    var X = V + 1;
    var af = z.coursecoords[V].split(",");
    var ad = parseFloat(af[0]);
    var ac = parseFloat(af[1]);
    var af = z.coursecoords[X].split(",");
    var Q = parseFloat(af[0]);
    var O = parseFloat(af[1]);
    var ag = (ad + Q) / 2;
    var ae = (ac + O) / 2;
    var R = mapviewer.canvas.width;
    var aa = mapviewer.canvas.height;
    var W = Q - ad;
    var U = O - ac;
    var T = Math.abs(Math.sqrt(W * W));
    var Z = aa / (T + R * M);
    var S = Math.abs(Math.sqrt(U * U));
    var Y = aa / (S + aa * M);
    var N = Z;
    if (Y > Z) {
      N = Y;
    }
    mapviewer.canvas.zoomfactor = N;
    mapviewer.move_mapxy_to_center(ag, ae);
    mapviewer.request_redraw();
    (mapviewer.canvas.rotate_angle * 180) / Math.PI;
  };
  this.centerleg_frominput = function (O) {
    var M = $("#showcourserotate");
    if (M.length != 0) {
      M = parseInt(M.val());
    }
    if (M == 1 || !M) {
      var N = 0.4;
      z.centerleg(parseInt(O - 1), N);
    } else {
      var N = 0.6;
      z.centerleg_norotate(parseInt(O - 1), N);
    }
    if (z.playing) {
      O--;
    }
    z.drawroutechoice_leg(O, z.playing);
    z.update_routediv(0);
  };
  m.onmousedown = function (U, T, S) {
    z.playtime_onmousedown = z.playtime;
    z.initvalue_mousemove = null;
    var X = Object;
    X.x = U;
    X.y = T;
    X.clickedkey = S;
    z.click_onmousedown = X;
    if (
      mapviewer.waitfordrag == 1 &&
      mapviewer.waitfordrag_startpoint == null
    ) {
      mapviewer.waitfordrag_startpoint = new Object();
      mapviewer.waitfordrag_startpoint.x = X.x;
      mapviewer.waitfordrag_startpoint.y = X.y;
    }
    z.settings.movetagnum = null;
    if (z.settings.mode == z.settings.modes.DrawCourseMode && S == 1) {
      var R = z.map.tolatlng(U, T);
      z.control_onmousedown = z.findclosestcontrol(R.lat, R.lng);
    } else {
      if (z.settings.mode == z.settings.modes.DrawCourseMode && S == 2) {
        var R = z.map.tolatlng(U, T);
        z.control_onmousedown = z.findclosestcontrolnumber(R.lat, R.lng);
      } else {
        if (z.settings.tagmode == 3 && z.currenttag && S == 1) {
          var R = z.map.tolatlng(U, T);
          z.tagpoint_onmousedown = z.findclosesttagpoint(R.lat, R.lng);
        } else {
          if (
            z.settings.mode == z.settings.modes.AnalysisMode &&
            z.settings.definecourse == 1 &&
            z.settings.coursedefinition_mode >= 1 &&
            z.settings.coursedefinition_mode <= 2
          ) {
            var R = z.map.tolatlng(U, T);
            if (S == 1) {
              z.control_onmousedown = z.findclosestcontrol(R.lat, R.lng);
            } else {
              if (S == 2) {
                var R = z.map.tolatlng(U, T);
                z.control_onmousedown = new Object();
                z.control_onmousedown.x = U;
                z.control_onmousedown.y = T;
                z.control_onmousedown.lat = R.lat;
                z.control_onmousedown.lng = R.lng;
                var M = z.routes[z.settings.coursefit_rnr];
                if (M) {
                  if (M.lapdata) {
                    var W = M.lapdata[z.settings.coursefit_lnr];
                    if (W) {
                      var V = W.times;
                      var ab = 1e99;
                      var ae = -1;
                      for (var Q = 0; Q < V.length; Q++) {
                        var Y = calcdistance(
                          M.latarray[Math.round(V[Q])],
                          M.lngarray[Math.round(V[Q])],
                          R.lat,
                          R.lng
                        );
                        if (Y < ab) {
                          ae = Q;
                          ab = Y;
                        }
                      }
                      z.settings.coursefit_modpoint = ae;
                      z.request_redraw();
                    }
                  }
                }
              }
            }
          } else {
            if (
              z.settings.analyzecourse == 1 &&
              S < 3 &&
              mapviewer.settings.mode != mapviewer.settings.modes.ReplayMode
            ) {
              var R = z.map.tolatlng(U, T);
              if (S == 1) {
                z.control_onmousedown = z.findclosestcontrol(R.lat, R.lng);
              } else {
                z.control_onmousedown = null;
              }
              z.marker_onmousedown = z.findclosestmarker(
                R.lat,
                R.lng,
                "shownsegment"
              );
              if (z.marker_onmousedown) {
                var Q = z.marker_onmousedown.markernu;
                z.highlight_route(z.marker_onmousedown.markernu);
                z.request_redraw();
              }
              m.setFont(m.font, 6, 0, "ff0000", 1);
            } else {
              if (z.settings.calibrationmode) {
                if (
                  z.map.calstring_points.substr(0, 3) == "NaN" ||
                  mapviewer.map.calstring_points.substr(-3) == "NaN"
                ) {
                  z.map.initcalibration(z.map.calstring);
                }
                var R = z.map.tolatlng(U, T);
                z.calpoint_onmousedown = z.findclosestcalpoint(R.lat, R.lng);
              } else {
                if (
                  z.settings.modifyroutes ||
                  (z.settings.routeedit_mode == 2 &&
                    z.settings.coursedefinition_mode == 3)
                ) {
                  var R = z.map.tolatlng(U, T);
                  for (var Q = 0; Q < z.routes.length; Q++) {
                    if (z.routes[Q].show) {
                      M = z.routes[Q];
                      Q = z.routes.length + 1;
                    }
                  }
                  M.latarray_mousedown = M.latarray.slice(0);
                  M.lngarray_mousedown = M.lngarray.slice(0);
                  var Z = M.findclosestpoint(R.lat, R.lng, "completeroute", -1);
                  z.settings.modifyroute_mousedown = Z;
                  var R = z.map.toxy(Z.P.lat, Z.P.lng);
                  if (z.settings.modifyroutes) {
                    z.visualize_point = new Object();
                    z.visualize_point.x = R.x;
                    z.visualize_point.y = R.y;
                  }
                } else {
                  if (S == 1) {
                    var R = z.map.tolatlng(U, T);
                    if (z.settings.mode == z.settings.modes.AnalysisMode) {
                      z.marker_onmousedown = z.findclosestmarker(
                        R.lat,
                        R.lng,
                        "shownsegment"
                      );
                      if (z.marker_onmousedown) {
                        var Q = z.marker_onmousedown.markernu;
                        var O = z.routes[Q].poslatlng(z.playtime);
                        var ac = z.routes[Q].poslatlng(
                          z.playtime - z.routes[Q].taillength
                        );
                        var aa = calcdistance(O.lat, O.lng, R.lat, R.lng);
                        var N = calcdistance(ac.lat, ac.lng, R.lat, R.lng);
                        if (aa < N) {
                          z.marker_onmousedown.modifyend = "end";
                        } else {
                          z.marker_onmousedown.modifyend = "start";
                        }
                      }
                    } else {
                      z.marker_onmousedown = z.findclosestmarker(
                        R.lat,
                        R.lng,
                        "currpos"
                      );
                    }
                    if (z.marker_onmousedown) {
                      z.highlight_route(z.marker_onmousedown.markernu);
                      z.request_redraw();
                      m.setFont(m.font, 6, 0, "ff0000", 1);
                    }
                  } else {
                    if (S >= 3) {
                      var ad = z.canvas.find_mapcenter_xy();
                      z.settings.rotate_centerx = ad.x;
                      z.settings.rotate_centery = ad.y;
                      z.settings.rotateoffset = 0;
                      z.settings.rotate_x0 = U;
                      z.settings.rotate_y0 = T;
                      z.visualize_point = new Object();
                      z.visualize_point.x = z.settings.rotate_centerx;
                      z.visualize_point.y = z.settings.rotate_centery;
                      z.request_redraw();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  this.runningwild_finished = function () {
    z.settings.orunningwild.finished = 1;
    z.settings.infotxt = "";
    var au = new Date().getTime();
    z.settings.orunningwild.time =
      Math.floor((au - z.settings.orunningwild.starttime) / 10) / 100;
    if (isnarrowscreen) {
    } else {
      $("#" + z.infodiv).html(
        "<b>Thanks for playing RunningWild - Calculating results!</b>"
      );
    }
    $("#" + z.canvasid).css("cursor", "auto");
    z.settings.orunningwild.allpoints_interplat = new Array();
    z.settings.orunningwild.allpoints_interplng = new Array();
    if (!z.settings.orunningwild.lengths) {
      z.settings.orunningwild.lengths = new Array();
    }
    var ae = new Array();
    var ak = 0;
    var R = 0;
    var ao = null;
    var al = null;
    var ad = null;
    var ab = null;
    for (count = 0; count < z.settings.orunningwild.allpoints.length; count++) {
      var aq = z.settings.orunningwild.allpoints[count].split(",");
      var aC = aq[0];
      var aB = aq[1];
      var T = z.map.tolatlng(aC, aB);
      var N = T.lat;
      var az = T.lng;
      if (count > 0) {
        var an = N - ad;
        var af = az - ab;
        R = calcdistance(ad, ab, N, az);
        var aj = Math.sqrt((aC - ao) * (aC - ao) + (aB - al) * (aB - al));
        if (aj == 0) {
          aj = 1;
        }
        var ax = Math.ceil(aj / 5);
        if (ax > 100) {
          ax = 100;
        }
        for (var aA = 1; aA < ax; aA++) {
          var Q = ad + (an / ax) * aA;
          var av = ab + (af / ax) * aA;
          z.settings.orunningwild.allpoints_interplat.push(Q);
          z.settings.orunningwild.allpoints_interplng.push(av);
        }
      }
      ao = aC;
      al = aB;
      ad = N;
      ab = az;
      z.settings.orunningwild.allpoints_interplat.push(N);
      z.settings.orunningwild.allpoints_interplng.push(az);
      ak = ak + R;
      ae.push(ak);
    }
    prevlength = 0;
    for (var aA = 1; aA < z.settings.orunningwild.splits.length; aA++) {
      thislength = ae[z.settings.orunningwild.splits[aA] - 1];
      z.settings.orunningwild.lengths[aA] = parseInt(thislength - prevlength);
      prevlength = thislength;
    }
    z.settings.orunningwild.lengths[0] = parseInt(ae[ae.length - 1]);
    var Z = 0;
    var am = z.settings.orunningwild.allpoints_interplat.length;
    var ay;
    var aw;
    var U = 0;
    var ap = new Array();
    var M = new Array();
    if (this.tags) {
      if (z.tags.length > 0) {
        tnr = 0;
        thistag = this.tags[tnr];
        if (thistag.type == "route") {
          U = 1;
          z.settings.orunningwild.equal_cmpname = thistag.name;
          var ad = 0;
          var ab = 0;
          var ao = 0;
          var al = 0;
          for (var aA = 0; aA < thistag.points.length; aA++) {
            var T = thistag.points[aA];
            var Y = T.split(",");
            var ai = parseFloat(Y[0]);
            var ac = parseFloat(Y[1]);
            var W = thistag.pointsxy[aA];
            var ag = W.split(",");
            var at = ag[0];
            var ar = ag[0];
            if (ad == 0 && ab == 0) {
            } else {
              var S = 1;
              var ah = Math.sqrt((at - ao) * (at - ao) + (ar - al) * (ar - al));
              if (ah == 0) {
                ah = S;
              }
              var X = S / ah;
              for (delta = X; delta < 1; delta = delta + X) {
                var T = interpolate(ad, ab, ai, ac, delta);
                ap.push(T.xn);
                M.push(T.yn);
              }
            }
            ap.push(ai);
            M.push(ac);
            ad = ai;
            ab = ac;
            ao = at;
            al = ar;
          }
          ay = 0;
          aw = ap.length;
        }
      }
    }
    if (!U) {
      if (z.routes.length > 0) {
        rnr = 0;
        var O = this.routes[rnr];
        ay = 0;
        aw = O.latarray.length;
        if (z.routes[0].splits) {
          if (z.routes[0].splits.length > 0) {
            ay = z.routes[0].splits[0].index;
            aw = z.routes[0].splits[z.routes[0].splits.length - 1].index;
          }
        }
        ap = O.latarray;
        M = O.lngarray;
        z.settings.orunningwild.equal_cmpname = O.runnername;
        U = 1;
      }
    }
    var aa = z.canvas.rotate_angle;
    z.canvas.context.rotate(-aa);
    z.prepare_finished_runningwild();
    $("#" + z.routemenudiv).html(
      '<center><p>Comparing with ideal route<p><img src="loading.gif"><p>Be patient<center>'
    );
    if (z.settings.orunningwild.compareideal == 0) {
      U = 0;
    } else {
      if (z.settings.orunningwild.compareideal) {
      } else {
        z.settings.orunningwild.compareideal = 0;
      }
    }
    if (U) {
      z.settings.orunningwild.ideal_lat = ap;
      z.settings.orunningwild.ideal_lng = M;
      z.settings.orunningwild.ideal_startpos = ay;
      z.settings.orunningwild.ideal_endpos = aw;
      z.settings.orunningwild.ideal_show = 1;
      z.settings.orunningwild.ideal_color = "0000ff";
      var V = z.compare_routes_runningwild(
        ap,
        M,
        ay,
        aw,
        z.settings.orunningwild.allpoints_interplat,
        z.settings.orunningwild.allpoints_interplng,
        Z,
        am
      );
      z.settings.orunningwild.equal_percent = V.equal_percent;
      if (!z.settings.orunningwild.equal_cmpname) {
        z.settings.orunningwild.equal_cmpname = "course creator";
      }
      if (isnarrowscreen) {
      } else {
        $("#" + z.infodiv).html(
          "<b>RunningWild Result: " +
            z.settings.orunningwild.equal_percent +
            "% equal to " +
            z.settings.orunningwild.equal_cmpname +
            " in " +
            z.settings.orunningwild.time +
            " + " +
            Math.floor(z.settings.orunningwild.overtime * 100) / 100 +
            " seconds</b>"
        );
      }
    } else {
      z.settings.orunningwild.equal_percent = -1;
      if (isnarrowscreen) {
      } else {
        $("#" + z.infodiv).html(
          "<b>RunningWild Time: " +
            z.settings.orunningwild.time +
            " + " +
            Math.floor(z.settings.orunningwild.overtime * 100) / 100 +
            " seconds</b>"
        );
      }
    }
    z.saverw();
  };
  this.prepare_finished_runningwild = function () {
    var N = z.runningwild_findstart();
    var M = z.map.toxy(N.startlat, N.startlng);
    z.move_mapxy_to_center(M.x, M.y);
    z.togglerightmenu();
    $("#" + z.menudiv).html(
      "<div id='toprightmenu'></div><div id='routemenu'></div><div id='routedesc'></div><div id='infobottomdiv'></div>"
    );
    this.toprightmenu = "toprightmenu";
    this.routemenudiv = "routemenu";
    this.routedescdiv = "routedesc";
    this.infobottomdiv = "infobottomdiv";
  };
  this.compare_routes_runningwild = function (Z, ab, an, Y, M, O, ac, ak) {
    var ad = new Array();
    var R = new Array();
    for (var Q = an; Q < Y; Q++) {
      ad[Q] = 0;
    }
    for (var S = ac; S < ak; S++) {
      R[S] = 0;
    }
    for (var Q = an; Q < Y; Q++) {
      lat2 = Z[Q];
      lng2 = ab[Q];
      var W = 0;
      for (var S = ac; S < ak; S++) {
        lat1 = M[S];
        lng1 = O[S];
        dist = calcdistance(lat1, lng1, lat2, lng2);
        if (dist < z.settings.orunningwild.sameroutechoice_distance) {
          W = 1;
          R[S] = 1;
        }
      }
      if (W) {
        ad[Q] = 1;
      }
    }
    var al = new Array();
    var V = new Array();
    var am = "";
    var N = 0;
    for (var S = ac; S < ak; S++) {
      lat1 = M[S];
      lng1 = O[S];
      var U = z.map.toxy(lat1, lng1);
      var ah = U.x;
      var af = U.y;
      am += ah + "," + af + " ";
      if (R[S] && N) {
      } else {
        if (R[S] && !N) {
          al.push(am);
          am = ah + "," + af + " ";
        } else {
          if (!R[S] && N) {
            V.push(am);
            am = ah + "," + af + " ";
          } else {
            if (!R[S] && !N) {
            }
          }
        }
      }
      N = R[S];
    }
    if (!N) {
      al.push(am);
    } else {
      V.push(am);
    }
    var aj = new Array();
    var T = new Array();
    var am = "";
    var ae = Y - an;
    var aa = 0;
    var N = 0;
    for (var Q = an; Q < Y; Q++) {
      lat2 = Z[Q];
      lng2 = ab[Q];
      var U = z.map.toxy(lat2, lng2);
      var ah = U.x;
      var af = U.y;
      am += ah + "," + af + " ";
      if (ad[Q]) {
        aa++;
      }
      if (ad[Q] && N) {
      } else {
        if (ad[Q] && !N) {
          aj.push(am);
          am = ah + "," + af + " ";
        } else {
          if (!ad[Q] && N) {
            T.push(am);
            am = ah + "," + af + " ";
          } else {
            if (!ad[Q] && !N) {
            }
          }
        }
      }
      N = ad[Q];
    }
    if (!N) {
      aj.push(am);
    } else {
      T.push(am);
    }
    diffroute_points = ae - aa;
    var ag = new Object();
    ag.corr_diffroutes = aj;
    ag.this_diffroutes = al;
    ag.corr_sameroutes = T;
    ag.this_sameroutes = V;
    z.settings.orunningwild.diffroutes = ag;
    var ai = Math.ceil((100 * aa) / (aa + diffroute_points));
    var X = Object;
    X.equal_percent = ai;
    return X;
  };
  this.draw_latlngline = function (R, N, T, O, M) {
    linestr = "";
    for (var S = T; S < O; S++) {
      var Q = z.map.toxy(R[S], N[S]);
      linestr += Q.x + "," + Q.y + " ";
    }
    z.canvas.setLineStyle(M, z.settings.routeopacity, z.settings.routewidth);
    z.canvas.drawPoly(linestr);
  };
  this.compare_routes_runningwild_tmp = function (Y, Z, ap, X, N, Q, aa, an) {
    var M = new Array();
    var ae = new Array();
    var ao = new Array();
    var W = new Array();
    var ad = "";
    var ac = "";
    var ab = 0;
    var ai = 0;
    var U = 5;
    var al = "diff";
    var aj = 0;
    for (var O = ap; O < X; O++) {
      lat2 = Y[O];
      lng2 = Z[O];
      var T = 0;
      for (var R = aa; R < an; R++) {
        lat1 = N[R];
        lng1 = Q[R];
        dist = calcdistance(lat1, lng1, lat2, lng2);
        if (dist < z.settings.orunningwild.sameroutechoice_distance) {
          T = 1;
          R = an + 1;
        }
      }
      var S = z.map.toxy(lat2, lng2);
      var am = S.x;
      var ak = S.y;
      var S = z.map.toxy(lat1, lng1);
      var ag = S.x;
      var af = S.y;
      ad += ag + "," + af + " ";
      ac += am + "," + ak + " ";
      if (T) {
        ab++;
        state = "same";
      } else {
        ai++;
        state = "diff";
      }
      if (al == state) {
        aj++;
      } else {
        if (aj < U) {
          state = "same";
          aj++;
        } else {
          M.push(ac);
          ae.push(ad);
          W.push(al);
          ao.push(al);
          ad = ag + "," + af + " ";
          ac = am + "," + ak + " ";
        }
      }
      al = state;
    }
    z.settings.orunningwild.diffroutes_current = ae;
    var ah = Math.ceil((100 * ab) / (ab + ai));
    var V = Object;
    V.equal_percent = ah;
    return V;
  };
  this.compare_routes_runningwild_old = function (ab, ac, ak, Z, N, O, ae, aj) {
    var ai = new Array();
    var M = "";
    var S = 0;
    var ad = 0;
    var Y = 0;
    for (var Q = ak; Q < Z; Q++) {
      lat2 = ab[Q];
      lng2 = ac[Q];
      var U = 0;
      for (var R = ae; R < aj; R++) {
        lat1 = N[R];
        lng1 = O[R];
        dist = calcdistance(lat1, lng1, lat2, lng2);
        if (dist < z.settings.orunningwild.sameroutechoice_distance) {
          U = 1;
          R = aj + 1;
        }
      }
      if (U) {
        ad++;
        var T = z.map.toxy(lat2, lng2);
        var ag = T.x;
        var af = T.y;
        var V = z.map.toxy(lat1, lng1);
        var aa = V.x;
        var X = V.y;
        if (S > 2) {
          M += aa + "," + X + " ";
          ai.push(M);
        }
        S = 1;
        M = aa + "," + X + " ";
      } else {
        Y++;
        S++;
        var T = z.map.toxy(lat2, lng2);
        var ag = T.x;
        var af = T.y;
        M += ag + "," + af + " ";
      }
    }
    z.settings.orunningwild.diffroutes_current = ai;
    var ah = Math.ceil((100 * ad) / (ad + Y));
    var W = Object;
    W.equal_percent = ah;
    return W;
  };
  this.update_segmenttime_from_taillength = function () {
    for (var M = 0; M < z.routes.length; M++) {
      if (z.routes[M].show) {
        z.routes[M].segmenttime = z.routes[M].taillength;
        z.routes[M].segmentlength = z.routes[M].calc_length(
          z.routes[M].currenttime(z.playtime) - z.routes[M].taillength,
          z.routes[M].currenttime(z.playtime)
        );
        if (z.settings.calc_inout_times) {
          z.routes[M].calc_inout_time(
            z.routes[M].currenttime(z.playtime) - z.routes[M].taillength,
            z.routes[M].currenttime(z.playtime)
          );
        }
      }
    }
  };
  this.writeTextRoute = function () {};
  this.addlocalroutesfromurl = function () {
    z.loadsettingsfromURLParameter();
    this.loadedgpxfromurl = 0;
    this.addnextlocalroutefromurl();
  };
  this.addnextlocalroutefromurl = function () {
    var S = getURLParameter("gpx");
    if (S) {
      var R = getURLParameter("race");
      var M = S.split(":");
      if (this.loadedgpxfromurl < M.length) {
        kkk = this.loadedgpxfromurl;
        this.loadedgpxfromurl++;
        var Q = M[kkk];
        var O = Q;
        if (!R) {
          url = "xcdata/" + Q + ".gpx";
        } else {
          if (getURLParameter("drop")) {
            url = "../../data/" + R + "/" + Q + ".gpx";
          } else {
            var N = getURLParameter("racedir");
            if (N) {
              url = N + "/" + R + "/" + Q + ".gpx";
            } else {
              url = "/dropbox/langrenn/" + R + "/" + Q + ".gpx";
            }
          }
        }
        $.ajax({
          type: "get",
          url: url,
          dataType: "text",
          error: function (U, T) {
            alert("Could not load " + url);
          },
          success: function (U, V, T) {
            z.addroutefromtxt(U, O);
            if (z.map.width == null) {
              z.load_blank_map();
            }
            if (getURLParameter("course") && loadcourse == 0) {
              loadcourse = -1;
              z.loadcoursefromURLParameter();
            }
            z.request_redraw();
            z.addnextlocalroutefromurl();
          },
        });
      } else {
        if (getURLParameter("split")) {
          setTimeout("mapviewer.makelaproutes()", 2000);
        }
      }
    }
  };
  this.loadcoursefromURLParameter = function () {
    if (z.map.loaded) {
      var N = getURLParameter("coursefile");
      if (N) {
        url = "../xccourses/" + N + ".json";
        setTimeout(
          "mapviewer.canvas.zoomfactor=.2;mapviewer.request_redraw();",
          1000
        );
      } else {
        var M = getURLParameter("course");
        var Q = getURLParameter("race");
        if (Q) {
          if (getURLParameter("drop")) {
            url = "../../data/" + Q + "/" + M + ".json";
          } else {
            var O = getURLParameter("racedir");
            if (O) {
              url = O + "/" + Q + "/" + M + ".json";
            } else {
              url = "/dropbox/langrenn/" + Q + "/" + M + ".json";
            }
          }
        } else {
          url = "xcdata/" + M + ".json";
        }
      }
      z.loadCoursefromlocalfile(url);
    } else {
      setTimeout("mapviewer.loadcoursefromURLParameter();", 2000);
    }
  };
  this.loadsettingsfromURLParameter = function () {
    var N = getURLParameter("settings");
    if (N) {
      var M = getURLParameter("racedir");
      url = M + "/settings/" + N;
      z.loadSettingsfromlocalfile(url);
    }
  };
  this.loadRCfromURLParameter = function () {
    if (getURLParameter("rc")) {
      var M = getURLParameter("rc");
      var O = getURLParameter("race");
      if (O) {
        if (getURLParameter("drop")) {
          url = "../../data/" + O + "/" + M + ".json";
        } else {
          var N = getURLParameter("racedir");
          if (N) {
            url = N + "/" + O + "/" + M + ".json";
          } else {
            url = "/dropbox/langrenn/" + O + "/" + M + ".json";
          }
        }
      } else {
        url = "xcdata/" + M + ".json";
      }
      z.loadRoutesfromlocalfile(url);
    } else {
      if (getURLParameter("loadsession")) {
        var Q = getURLParameter("id");
        url = "savexc/" + Q + ".json";
        z.loadRoutesfromlocalfile(url);
      } else {
        setTimeout("mapviewer.loadRCfromURLParameter();", 2000);
      }
    }
  };
  this.hideallroutes = function () {
    for (var M = 0; M < z.routes.length; M++) {
      z.routes[M].show = 0;
    }
    z.request_redraw();
  };
  this.sortxcresults = function () {
    var N = z.settings.sortxcresults;
    if (N == 0) {
      for (var M = 0; M < z.routes.length; M++) {
        if (!z.routes[M].time) {
          if (z.routes[M].lapdata.length > 0) {
            z.routes[M].time =
              z.routes[M].lapdata[z.routes[M].lapdata.length - 1].times[
                z.routes[M].lapdata[0].times.length - 1
              ] - z.routes[M].lapdata[0].times[0];
          } else {
            z.routes[M].time =
              z.routes[M].timearray[z.routes[M].timearray.length - 1] -
              z.routes[M].timearray[0];
          }
        }
      }
      z.routes.sort(sort_xctime);
    } else {
      if (N == 1) {
        z.routes.sort(sort_xcstart);
      } else {
        if (N == 2) {
          z.routes.sort(sort_xcname);
        }
      }
    }
  };
  this.makelaproutes = function () {
    if (z.courseinfo.neednewsnap) {
      z.snaproutestocourse();
      z.courseinfo.neednewsnap = 1;
    }
    z = mapviewer;
    var ac = new Array();
    var S = 0;
    for (var Y = 0; Y < z.routes.length; Y++) {
      var U = z.routes[Y].lapdata;
      if (U.length) {
        for (var R = 0; R < U.length; R++) {
          var X = z.routes[Y];
          var U = z.routes[Y].lapdata;
          var Q = U[R].starttime;
          var aa = Math.round(Q + U[R].time) + 3;
          if (aa >= X.latarray.length - 1) {
            aa = X.latarray.length - 1;
          }
          if (Q <= 0) {
            Q = 0;
          }
          var O = X.latarray.slice(Q, aa).join(";");
          var W = X.lngarray.slice(Q, aa).join(";");
          var M = X.timearray.slice(Q, aa).join(";");
          var V = new Route(
            O,
            W,
            M,
            X.runnername + " - " + (R + 1),
            "",
            z.getnextcolor(),
            1,
            z.routes.length + 1,
            null,
            null,
            null
          );
          V.runnername_long = X.runnername_long;
          V.maxpulse = X.maxpulse;
          V.indexnumber = S;
          S++;
          ac[ac.length] = V;
          var N = z.datafieldtypes;
          for (var ab = 0; ab < N.length; ab++) {
            if (X[N[ab]] != null) {
              fname = N[ab];
              var Z = X[fname].slice(Q, aa + 1);
              V[fname] = Z;
            }
          }
          V.setlapstart(0, z.playtime);
        }
      }
    }
    var T = z.routes;
    z.routes = ac;
    z.orgroutes = T;
    z.update_routediv(1);
    z.courseinfo.neednewsnap = 1;
    for (var R = 0; R < z.routes.length; R++) {
      z.routes[R].setpos(0, z.playtime);
    }
    z.snaproutestocourse();
  };
  this.save_graph_plus_elevation = function (Q) {
    if (!Q) {
      var W = "";
      for (var U = 0; U < z.routes.length; U++) {
        if (z.routes[U].show) {
          W = W + z.routes[U].runnername_short + "_";
        }
      }
      W = W.substr(0, 100);
      W = W + $("#selectgraph-1 option:selected").text();
      Q = "xc_" + W + ".png";
      Q = Q.replace(/ /g, "");
    }
    if (z.settings.pfact) {
      pfact = z.settings.pfact;
    } else {
      pfact = 0.9;
    }
    z.printwidth = 1460 * pfact;
    var X = 0;
    z.printheight = 570 * pfact;
    X = X + z.printheight;
    z.printgraph = 1;
    var M = name;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    var T = $("#graph-1").jqplotToImageStr({});
    z.printgraph = 0;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.printheight = 200 * pfact;
    X = X + z.printheight;
    z.printgraph = 2;
    var M = name;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    z.redraw();
    var S = $("#graph-2").jqplotToImageStr({});
    z.printgraph = 0;
    z.settings.showInfoBelow = "";
    z.redraw();
    z.settings.showInfoBelow = "CourseInfo";
    var R = document.getElementById("graph-4");
    R.innerHTML =
      "<canvas width=" +
      z.printwidth +
      " height=" +
      X +
      ' id="savecanvas"></div>';
    var O = document.getElementById("savecanvas");
    var N = O.getContext("2d");
    var V = new Image();
    V.src = T;
    V.onload = function () {
      N.drawImage(V, 0, 0);
      cimg2 = new Image();
      cimg2.src = S;
      cimg2.onload = function () {
        N.drawImage(cimg2, 0, V.height);
        sleep(1000);
        downloadImg(O.toDataURL("image/png"), Q);
      };
    };
  };
  this.splitunsplitroutes = function () {
    if ($("#splitroutesbutton")[0].innerHTML == "Split routes by lap") {
      z.makelaproutes();
      $("#splitroutesbutton")[0].innerHTML = "Unsplit routes";
      $("#splitrouteslink")[0].innerHTML = "Unsplit routes";
    } else {
      z.unsplitroutes();
      $("#splitroutesbutton")[0].innerHTML = "Split routes by lap";
      $("#splitrouteslink")[0].innerHTML = "Split routes by lap";
    }
  };
  this.unsplitroutes = function () {
    if (!z.orgroutes) {
      alert("No routes to un-split");
    } else {
      z.routes = z.orgroutes;
      z.update_routediv(1);
      z.courseinfo.neednewsnap = 1;
      for (var M = 0; M < z.routes.length; M++) {
        z.routes[M].setpos(0, z.playtime);
      }
      z.snaproutestocourse();
    }
  };
  this.loadfitfilefromdata = function (O, N) {
    var M = new EasyFit({
      force: true,
      speedUnit: "m/s",
      lengthUnit: "m",
      temperatureUnit: "celcius",
      elapsedRecordField: true,
      mode: "list",
    });
    M.parse(O, function (R, U) {
      if (R) {
        console.log(R);
      } else {
        var T = parse_fit_fromdata(U);
        if (!N) {
          N = "Import";
        }
        N = N.replace(/-/, "");
        var Q = new Route(
          T.lats,
          T.lngs,
          T.times,
          N,
          "",
          z.getnextcolor(),
          1,
          z.routes.length + 1,
          null,
          null,
          null
        );
        var V = z.datafieldtypes;
        for (var S = 0; S < V.length; S++) {
          if (T[V[S]] != null) {
            fname = V[S];
            Q.addfield_interp(fname, T[V[S]], T.times);
            z.used_fieldtypes[V[S]] = 1;
          }
        }
        if (Q.cutstart) {
          Q.removedatapoints(0, Q.cutstart);
          Q.zerotime = Q.zerotime + Q.cutstart;
        }
        if (Q.cutend) {
          Q.removedatapoints(Q.latarray.length - Q.cutend, Q.cutend);
        }
        z.routes[z.routes.length] = Q;
        if (Q.zerotime < z.zerotime) {
          z.zerotime = Q.zerotime;
        }
        if (Q.zerotime + Q.latarray.length > z.maxtime) {
          z.maxtime = Q.zerotime + Q.latarray.length;
        }
        z.update_routediv(1);
        z.courseinfo.neednewsnap = 1;
      }
    });
  };
  this.convert_shown_paths_to_route = function (O) {
    for (var N = 0; N < z.tags.length; N++) {
      var M = z.tags[N];
      if (M.show) {
        z.convert_path_to_route(N);
      }
    }
  };
  this.convert_path_to_route = function (R) {
    var S = z.tags[R];
    var U = S.pointsxy;
    var X = 0;
    if (z.zerotime <= 1e98 && z.zerotime > 0) {
      X = z.zerotime;
    }
    var T;
    var V;
    var N = new Object();
    N.lats = [];
    N.lngs = [];
    N.times = [];
    for (var M = 0; M < U.length; M++) {
      var Q = U[M];
      var Y = Q.split(",");
      var Q = z.map.tolatlng(Y[0], Y[1]);
      thislat = Q.lat;
      thislng = Q.lng;
      if (M > 0) {
        if (S.speed) {
          speed = S.speed;
        } else {
          speed = 3.33;
        }
        d = calcdistance(T, V, thislat, thislng);
        dt = parseInt(d / speed);
        if (dt < 1) {
          dt = 1;
        }
        if (dt > 100) {
          dt = 100;
        }
        X = X + dt;
      }
      N.lats.push(thislat);
      N.lngs.push(thislng);
      N.times.push(X);
      T = thislat;
      V = thislng;
    }
    var W = S.name;
    if (!W) {
      W = "Tag " + R;
    }
    tmptmp3 = N;
    var O = new Route(
      N.lats.join(";"),
      N.lngs.join(";"),
      N.times.join(";"),
      W,
      "",
      S.color,
      1,
      z.routes.length + 1,
      null,
      null,
      null
    );
    z.routes[z.routes.length] = O;
    z.zerotime = O.zerotime;
  };
  this.addroutefromtxt = function (M, O) {
    var R = parse_gpx_fromtxt(M);
    if (!O) {
      O = "Import";
    }
    O = O.replace(/-/, "");
    var N = new Route(
      R.lats,
      R.lngs,
      R.times,
      O,
      "",
      z.getnextcolor(),
      1,
      z.routes.length + 1,
      null,
      null,
      null
    );
    var S = z.datafieldtypes;
    for (var Q = 0; Q < S.length; Q++) {
      if (R[S[Q]] != null) {
        fname = S[Q];
        N.addfield_interp(fname, R[S[Q]], R.times);
        z.used_fieldtypes[S[Q]] = 1;
      }
    }
    if (N.cutstart) {
      N.removedatapoints(0, N.cutstart);
      N.zerotime = N.zerotime + N.cutstart;
    }
    if (N.cutend) {
      N.removedatapoints(N.latarray.length - N.cutend, N.cutend);
    }
    z.routes[z.routes.length] = N;
    if (N.zerotime < z.zerotime) {
      z.zerotime = N.zerotime;
    }
    if (N.zerotime + N.latarray.length > z.maxtime) {
      z.maxtime = N.zerotime + N.latarray.length;
    }
    z.update_routediv(1);
    z.courseinfo.neednewsnap = 1;
  };
  this.Draw_pace_graph = function () {
    z = mapviewer;
    var Z = new Array();
    var ab = 0;
    var N = 1e99;
    var R = 0;
    var ah = 0;
    var ag = z.settings.pacegraph.maxpace;
    var ac = z.settings.pacegraph.minpace;
    var M = [];
    var U = new Array();
    var ae = [];
    var W = new Array();
    var V = -1;
    for (var X = 0; X < z.routes.length; X++) {
      if (z.routes[X].show) {
        V++;
        to = z.routes[X].currenttime(z.playtime);
        from = to - z.routes[X].taillength;
        if (from < 0) {
          from = 0;
        }
        var O = new Array();
        var ai = z.routes[X].runnername;
        ae.push(ai);
        W[X] = from;
        var Q = 0;
        var Y = z.settings.pacegraph.dt;
        var Y = 3;
        var af = null;
        var aa = null;
        for (j = from; j <= to; j = j + Y) {
          thislat = z.routes[X].latarray[j];
          thislng = z.routes[X].lngarray[j];
          if (af || aa) {
            var ad = calcdistance(af, aa, thislat, thislng);
            var T = ((Y / ad) * 1000) / 60;
            if (T < N) {
              N = T;
            }
            if (T > R) {
              R = T;
            }
            if (T > ag) {
              T = ag;
            }
            Q = Q + ad;
            O.push([Q, T]);
            if (Q > ah) {
              ah = Q;
            }
          }
          af = thislat;
          aa = thislng;
        }
        if (O.length > ab) {
          ab = O.length;
        }
        Z[V] = O;
        U.push("#" + z.routes[X].color);
      }
    }
    if (N < ac) {
      N = z.settings.pacegraph.minpace;
    }
    if (R > ag) {
      R = z.settings.pacegraph.maxpace;
    }
    ah = Math.ceil(ah / 10) * 10;
    $("#graphholder").show();
    $("#graphholder").html("");
    mapviewer.settings.showInfoBelow = "Pacecurve";
    settings = {
      cursor: { show: true, zoom: true, showTooltip: true },
      series: ae,
      seriesColors: U,
      seriesDefaults: { rendererOptions: { smooth: true } },
      axes: {
        xaxis: { min: 0, max: ah, tickOptions: { formatString: "%d m" } },
        yaxis: { tickOptions: { formatString: "%d min/km" } },
      },
    };
    var S = $.jqplot("graphholder", Z, settings);
    mapviewer.request_redraw();
  };
  this.toggleColorAnalysismode = function (M) {
    if (M == 1) {
      this.settings.pacecoloring.type = this.settings.pacecoloring.type + 1;
    } else {
      this.settings.pacecoloring.type = this.settings.pacecoloring.type - 1;
    }
    if (this.settings.pacecoloring.type == 6) {
      this.settings.pacecoloring.type = 0;
    } else {
      if (this.settings.pacecoloring.type == -1) {
        this.settings.pacecoloring.type = 5;
      }
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.toggleColormode = function (M) {
    if (M == 1) {
      z.settings.colormode++;
      if (z.settings.colormode > z.settings.colormodes.length - 1) {
        z.settings.colormode = 0;
      }
    } else {
      z.settings.colormode--;
      if (z.settings.colormode < 0) {
        z.settings.colormode = z.settings.colormodes.length - 1;
      }
    }
    if (z.settings.colormode == z.settings.modes.colorbysplit) {
      z.recolorbysplit();
      $("#recolor").html("Org colors");
    } else {
      if (z.settings.colormode == z.settings.modes.colorbyorg) {
        z.recolorbyorg();
        $("#recolor").html("Color by time");
      } else {
        if (z.settings.colormode == z.settings.modes.colorbylength) {
          z.recolorbylength();
          $("#recolor").html("Color by time");
        } else {
          z.update_routediv(0);
        }
      }
    }
    z.request_redraw();
    z.updateinfobottomdiv();
  };
  this.OpenSettings = function () {
    z.open_dialog("Advanced Options", null);
    if (z.settings.savevideo) {
      if (z.settings.savevideo.a) {
        $("#slider-savelink").html(z.settings.savevideo.a);
      }
    }
  };
  this.Show_tag_all_overview = function () {
    z.open_dialog("tagtable", null);
    var O = new google.visualization.Table(document.getElementById("tagtable"));
    var T = new Array();
    for (var S = 0; S < z.routes.length; S++) {
      T[z.routes[S].md5] = S;
    }
    var R = new google.visualization.DataTable();
    R.addColumn("string", "Runner");
    R.addColumn("string", "Name");
    R.addColumn("string", "Category");
    R.addColumn("number", "Time from start");
    R.addColumn("number", "Length from start");
    R.addColumn("number", "Segment Time");
    R.addColumn("number", "Segment Length");
    R.addColumn("number", "Segment Pace");
    R.addColumn("string", "Comment");
    var U = 0;
    for (var S = 0; S < z.tags.length; S++) {
      var N = z.tags[S];
      if (N.type != "route") {
        var Q = N.md5;
        var M = T[Q];
        if (z.routes[M].show) {
          R.addRows(1);
          R.setCell(U, 0, N.runnername);
          R.setCell(U, 1, N.name);
          R.setCell(U, 2, N.category);
          R.setCell(U, 3, N.time, tominsec(N.time));
          R.setCell(U, 4, N.length, Math.round(N.length) + " m");
          if (N.type == "segment") {
            R.setCell(U, 5, N.totime - N.time, tominsec(N.totime - N.time));
            R.setCell(
              U,
              6,
              N.tolength - N.length,
              " " + Math.round(N.tolength - N.length) + " m"
            );
            R.setCell(
              U,
              7,
              ((N.totime - N.time) / (N.tolength - N.length)) * 1000,
              N.pace
            );
          } else {
            R.setCell(U, 5, 1e99, "N/A");
            R.setCell(U, 6, 1e99, "N/A");
            R.setCell(U, 7, 1e99, "N/A");
          }
          R.setCell(U, 8, N.description);
          U++;
        }
      }
    }
    O.draw(R, { showRowNumber: true, alternatingRowStyle: true });
  };
  this.Show_tag_segment_overview = function () {
    z.open_dialog("tagtable", null);
    var Z = new google.visualization.Table(document.getElementById("tagtable"));
    var X = new Array();
    for (var N = 0; N < z.routes.length; N++) {
      X[z.routes[N].md5] = N;
    }
    var Q = new google.visualization.DataTable();
    Q.addColumn("string", "Runner");
    Q.addColumn("string", "Category");
    Q.addColumn("number", "# Segments");
    Q.addColumn("number", "Sum Time");
    Q.addColumn("number", "Sum Length");
    Q.addColumn("number", "Average Pace");
    var M = new Array();
    for (var N = 0; N < z.tags.length; N++) {
      var W = z.tags[N];
      if (W.type != "route") {
        var U = W.md5;
        var S = X[U];
        if (z.routes[S].show && W.type == "segment") {
          var V = W.category;
          var T = W.runnername;
          var R = T + ";" + V;
          if (!M[R]) {
            M[R] = new Object();
            M[R].length = 0;
            M[R].time = 0;
            M[R].ant = 0;
          }
          M[R].category = V;
          M[R].runnername = T;
          M[R].length = M[R].length + (W.tolength - W.length);
          M[R].time = M[R].time + (W.totime - W.time);
          M[R].ant++;
        }
      }
    }
    var Y = 0;
    for (var R in M) {
      var O = M[R];
      if (O.ant > 0) {
        Q.addRows(1);
        Q.setCell(Y, 0, O.runnername);
        Q.setCell(Y, 1, O.category);
        Q.setCell(Y, 2, O.ant);
        Q.setCell(Y, 3, O.time, tominsec(O.time));
        Q.setCell(Y, 4, O.length, Math.round(O.length) + " m");
        Q.setCell(
          Y,
          5,
          (O.time / O.length) * 1000,
          tominsec((O.time / O.length) * 1000) + " min/km"
        );
        Y++;
      }
    }
    Z.draw(Q, { showRowNumber: true, alternatingRowStyle: true });
  };
  this.Show_splits_overview = function () {
    var T = "";
    if (!z.settings.autosplits_calculated) {
      z.calculate_autosplits();
    }
    z.open_dialog("splitstable", null);
    var W = new google.visualization.Table(
      document.getElementById("splitstable")
    );
    var Q = new google.visualization.DataTable();
    Q.addColumn("string", "Runner");
    for (var M = 0; M < z.coursecoords.length - 1; M++) {
      Q.addColumn("number", "#" + (M + 1));
    }
    var V = 0;
    for (var U = 0; U < z.routes.length; U++) {
      var R = z.routes[U];
      if (R.show) {
        Q.addRows(1);
        Q.setCell(V, 0, R.runnername);
        T = T + R.runnername;
        var N = R.splits;
        var O = N[0].index;
        var S = O;
        for (var M = 1; M < N.length; M++) {
          this_passing = N[M].index;
          this_split = this_passing - O;
          O = this_passing;
          this_split_text = tominsec(this_split);
          if (this_split < 0) {
            this_split_text = "-";
            this_split_text_hms = "-";
            this_split = 1e99;
          } else {
            this_split_text_hms = "00:" + this_split_text;
          }
          Q.setCell(V, M, this_split, this_split_text);
          T = T + "\t" + this_split_text_hms;
        }
        V++;
        T = T + "\n";
      }
    }
    W.draw(Q, { showRowNumber: true, alternatingRowStyle: true });
    $("#splitsexport").val(T);
  };
  this.Draw_temp_heatmap = function () {
    var ao = 0;
    var aq = 1e99;
    var ax = 0;
    var au = z.settings.pacecoloring.maxpace;
    var am = z.settings.pacecoloring.minpace;
    var aa = z.canvas.context.transformedPoint(0, 0).x;
    var M = z.canvas.context.transformedPoint(0, 0).y;
    var Z = aa + z.canvas.width / z.canvas.zoomfactor;
    var aE = M + z.canvas.height / z.canvas.zoomfactor;
    var az = z.map.tolatlng(aa, M);
    var ay = z.map.tolatlng(Z, aE);
    var at = az.lat;
    var aj = az.lng;
    var ap = ay.lat;
    var ai = ay.lng;
    var ad = z.map.toxy(at, aj);
    var ac = z.map.toxy(ap, ai);
    var aa = ad.x;
    var M = ad.y;
    var Z = ac.x;
    var aE = ac.y;
    var O = aE - M;
    var Q = Z - aa;
    var av = 5;
    var S = z.canvas.width / av;
    var R = z.canvas.height / av;
    var al = new Array();
    var aw = new Array();
    var ag = new Array();
    for (var an = 0; an < z.routes.length; an++) {
      if (z.routes[an].show) {
        to = z.routes[an].currenttime(z.playtime);
        from = to - z.routes[an].taillength;
        if (from < 0) {
          from = 0;
        }
        var U = 3;
        var ak = null;
        var ae = null;
        for (j = from; j <= to; j = j + U) {
          thislat = z.routes[an].latarray[j];
          thislng = z.routes[an].lngarray[j];
          if (ak || ae) {
            var af = z.routes[an].pace[j];
            aw.push(af);
            var aB = calcdistance(ak, ae, thislat, thislng);
            al.push(aB);
            if (af < aq) {
              aq = af;
            }
            if (af > ax) {
              ax = af;
            }
            for (jj = 0; jj <= 0.99; jj = jj + 0.01) {
              var V = z.map.toxy(
                ak + (thislat - ak) * jj,
                ae + (thislng - ae) * jj
              );
              var aD = V.x;
              var aC = V.y;
              var W = Math.round(((aD - aa) / Q) * S);
              var T = Math.round(((aC - M) / O) * R);
              X = W + ";" + T;
              if (ag[X]) {
                ag[X] = ag[X] + af + ";";
              } else {
                ag[X] = af + ";";
              }
            }
          }
          ak = thislat;
          ae = thislng;
        }
      }
    }
    var ar = 0;
    if (am < 0) {
      ar = -am;
    }
    var Y = new Array();
    for (var X in ag) {
      if (ag.hasOwnProperty(X)) {
        vals = ag[X];
        tvals = vals.split(";");
        af = 0;
        for (var aA = 0; aA < tvals.length - 1; aA++) {
          af = af + parseFloat(tvals[aA]);
        }
        af = af / (tvals.length - 1);
        if (af > au) {
          af = au;
        }
        if (af < am) {
          af = am;
        }
        af = af + ar;
        gridids = X.split(";");
        if (!isNaN(af)) {
          var ah = new Object();
          ah.x = (gridids[0] * z.canvas.width) / S;
          ah.y = (gridids[1] * z.canvas.height) / R;
          ah.value = af;
          Y[Y.length] = ah;
        }
      }
    }
    aq = am + ar;
    ax = au + ar;
    dataset = new Object();
    dataset.data = Y;
    dataset.max = ax;
    dataset.min = aq;
    dataset.divx = S;
    dataset.divy = R;
    dataset.scalex = z.canvas.width / S;
    dataset.scaley = z.canvas.height / R;
    tmptmp4 = dataset;
    tmpdata = dataset;
    var N = (z.canvas.width / S / 2) * 1.05;
    var ab = new Object();
    ab.dist = al;
    ab.pace = aw;
    ab.dt = U;
    localStorage.setItem("heatmapdata", JSON.stringify(dataset));
    localStorage.setItem("paceinfo", JSON.stringify(ab));
    z.heatmap = h337.create({
      container: document.getElementById("mapholder"),
      radius: N,
      maxOpacity: 1,
      minOpacity: 1,
      blur: 0,
      gradient: { 0: "#080", 0.5: "yellow", 1: "red" },
      visible: true,
    });
    z.heatmap.setData(dataset);
  };
  this.Draw_pace_heatmap = function () {
    var ao = 0;
    var aq = 1e99;
    var av = 0;
    var at = 20;
    var am = 2;
    var aa = z.canvas.context.transformedPoint(0, 0).x;
    var M = z.canvas.context.transformedPoint(0, 0).y;
    var Z = aa + z.canvas.width / z.canvas.zoomfactor;
    var aC = M + z.canvas.height / z.canvas.zoomfactor;
    var ax = z.map.tolatlng(aa, M);
    var aw = z.map.tolatlng(Z, aC);
    var ar = ax.lat;
    var aj = ax.lng;
    var ap = aw.lat;
    var ai = aw.lng;
    var ad = z.map.toxy(ar, aj);
    var ac = z.map.toxy(ap, ai);
    var aa = ad.x;
    var M = ad.y;
    var Z = ac.x;
    var aC = ac.y;
    var S = z.canvas.width;
    var R = z.canvas.height;
    var O = aC - M;
    var Q = Z - aa;
    var al = new Array();
    var au = new Array();
    var ag = new Array();
    for (var an = 0; an < z.routes.length; an++) {
      if (z.routes[an].show) {
        to = z.routes[an].currenttime(z.playtime);
        from = to - z.routes[an].taillength;
        if (from < 0) {
          from = 0;
        }
        var T = 1;
        var ak = null;
        var ae = null;
        for (j = from; j <= to; j = j + T) {
          thislat = z.routes[an].latarray[j];
          thislng = z.routes[an].lngarray[j];
          if (ak || ae) {
            var az = calcdistance(ak, ae, thislat, thislng);
            var af = ((T / az) * 1000) / 60;
            if (af < aq) {
              aq = af;
            }
            if (af > av) {
              av = af;
            }
            if (af > at) {
              af = at;
            }
            au.push(af);
            al.push(az);
            var V = z.map.toxy((thislat + ak) / 2, (thislng + ae) / 2);
            var aB = V.x;
            var aA = V.y;
            var W = Math.round(((aB - aa) / Q) * S);
            var U = Math.round(((aA - M) / O) * R);
            X = W + ";" + U;
            if (ag[X]) {
              ag[X] = ag[X] + af + ";";
            } else {
              ag[X] = af + ";";
            }
          }
          ak = thislat;
          ae = thislng;
        }
      }
    }
    var Y = new Array();
    for (var X in ag) {
      if (ag.hasOwnProperty(X)) {
        vals = ag[X];
        tvals = vals.split(";");
        af = 0;
        for (var ay = 1; ay < tvals.length; ay++) {
          af = af + tvals[ay];
        }
        af = af / (tvals.length - 1);
        gridids = X.split(";");
        var ah = new Object();
        ah.x = gridids[0];
        ah.y = gridids[1];
        ah.count = af;
        Y[Y.length] = ah;
      }
    }
    dataset = new Object();
    dataset.data = Y;
    dataset.max = av;
    var ab = new Object();
    ab.dist = al;
    ab.pace = au;
    ab.dt = T;
    localStorage.setItem("heatmapdata", JSON.stringify(dataset));
    localStorage.setItem("paceinfo", JSON.stringify(ab));
    tmpdata = dataset;
    var N = (z.canvas.width / S / 2) * 20;
    z.heatmap = h337.create({
      container: document.getElementById("mapholder"),
      radius: N,
      maxOpacity: 1,
      minOpacity: 1,
      blur: 0,
      gradient: { 0: "#080", 0.5: "yellow", 1: "red" },
      visible: true,
    });
    z.heatmap.setData(dataset);
  };
  this.Draw_heatmap_testing = function () {
    if (!z.Ocanvas) {
      z.Ocanvas = document.createElement("canvas");
      $("#mapholder").append(z.Ocanvas);
      z.Ocanvas.style.display = "block";
      z.Ocanvas.style.position = "absolute";
      z.Ocanvas.style.top = "0";
      z.Ocanvas.style.left = "0";
      z.Ocanvas.style.zIndex = 1000000;
    }
    z.Ocanvas.height = mapviewer.canvas.height;
    z.Ocanvas.width = mapviewer.canvas.width;
    actx = z.Ocanvas.getContext("2d");
    actx.clearRect(0, 0, z.Ocanvas.width, z.Ocanvas.height);
    var M = actx.getImageData(100, 100, 10, 10);
    imageData = M.data;
    for (ii = 0; ii < 300; ii++) {
      imageData[ii] = 255;
    }
    M.data = imageData;
    actx.putImageData(M, 100, 100);
    mapviewer.canvas.context.putImageData(M, 100, 100);
  };
  this.Draw_heatmap = function () {
    var al = 0;
    var N = 0;
    var ak = z.canvas.context.transformedPoint(0, 0).x;
    var U = z.canvas.context.transformedPoint(0, 0).y;
    var aj = ak + z.canvas.width / z.canvas.zoomfactor;
    var S = U + z.canvas.height / z.canvas.zoomfactor;
    var an = z.map.tolatlng(ak, U);
    var am = z.map.tolatlng(aj, S);
    var X = an.lat;
    var aq = an.lng;
    var V = am.lat;
    var ao = am.lng;
    var Y = z.map.toxy(X, aq);
    var W = z.map.toxy(V, ao);
    var ak = Y.x;
    var U = Y.y;
    var aj = W.x;
    var S = W.y;
    var af = z.canvas.width;
    var ae = z.canvas.height;
    var aa = S - U;
    var ab = aj - ak;
    var R = new Array();
    var M = new Array();
    for (var ac = 0; ac < z.routes.length; ac++) {
      if (z.routes[ac].show) {
        to = z.routes[ac].currenttime(z.playtime);
        from = to - z.routes[ac].taillength;
        if (from < 0) {
          from = 0;
        }
        var ad = 3;
        var ap = null;
        var ag = null;
        for (j = from; j <= to; j = j + ad) {
          thislat = z.routes[ac].latarray[j];
          thislng = z.routes[ac].lngarray[j];
          if (ap || ag) {
            var Z = z.map.toxy((thislat + ap) / 2, (thislng + ag) / 2);
            var ai = Z.x;
            var ah = Z.y;
            var Q = Math.round(((ai - ak) / ab) * af);
            var O = Math.round(((ah - U) / aa) * ae);
            gridid = Q + ";" + O;
            if (!R[gridid]) {
              R[gridid] = 0;
            }
            R[gridid]++;
            if (R[gridid] > N) {
              N = R[gridid];
            }
            var T = new Object();
            T.x = Q;
            T.y = O;
            T.count = 1;
            M[M.length] = T;
          }
          ap = thislat;
          ag = thislng;
        }
      }
    }
    dataset = new Object();
    dataset.data = M;
    dataset.max = N + 1;
    tmpdata = dataset;
    z.heatmap = h337.create({
      element: document.getElementById("mapholder"),
      radius: 25,
      visible: true,
    });
    z.heatmap.store.setDataSet(tmpdata);
  };
  this.Draw_all_full_routes = function (N) {
    if (N) {
      $("#selectmode").val("analysis");
      $("#selectmode").change();
    }
    minoffset = 1e99;
    for (var M = 0; M < z.routes.length; M++) {
      z.routes[M].offset =
        z.routes[M].latarray.length - 1 - (z.zerotime - z.routes[M].zerotime);
      z.routes[M].taillength = z.routes[M].latarray.length - 1;
      z.routes[M].segmenttime = z.routes[M].latarray.length - 1;
      if (z.routes[M].offset < minoffset) {
        minoffset = z.routes[M].offset;
      }
    }
    if (minoffset < 1e99) {
      for (var M = 0; M < z.routes.length; M++) {
        z.routes[M].offset = z.routes[M].offset - minoffset;
      }
    }
    z.playtime = z.zerotime + minoffset;
    z.reset_replaystarttime();
    z.update_routediv(1);
    z.request_redraw();
  };
  this.update_taglength = function () {
    z = mapviewer;
    for (var M = 0; M < z.tags.length; M++) {
      var U = z.tags[M];
      if (U.type == "route") {
        for (var T = 0; T < U.points.length; T++) {
          var Y = U.pointsxy[T].split(",");
          var Q = z.map.tolatlng(parseFloat(Y[0]), parseFloat(Y[1]));
          U.points[T] = Q.lat + "," + Q.lng;
        }
        var X = 0;
        var O = U.points[0];
        var N = O.split(",");
        var V = N[0];
        var W = N[1];
        for (var T = 1; T < U.points.length; T++) {
          var O = U.points[T];
          var N = O.split(",");
          var R = N[0];
          var S = N[1];
          d = calcdistance(V, W, R, S);
          X = X + d;
          V = R;
          W = S;
        }
        U.length = X;
      }
    }
  };
  this.update_courselength = function () {
    var Q = 0;
    if (z.coursecoords.length) {
      for (var O = 1; O < z.coursecoords.length; O++) {
        var N = z.coursecoords[O - 1].split(",");
        var M = z.map.tolatlng(N[0], N[1]);
        N = z.coursecoords[O].split(",");
        var S = z.map.tolatlng(N[0], N[1]);
        var R = calcdistance(M.lat, M.lng, S.lat, S.lng);
        Q += R;
      }
      Q = parseInt(Q);
      if (courseplanning && Q > 0) {
        value = "analyzecourse";
        $("#selectmode option[value=" + value + "]").removeAttr("disabled");
        z.settings.showtagmode = 1;
      }
    }
    $("#showcourselength").html(Q + " m");
    if (courseplanning && Q > 0) {
      $("#showcourselength_planning").html("<i>Course length: " + Q + " m</i>");
    }
    mapviewer.settings.courselength = Q;
  };
  this.update_routediv = function (O) {
    var X = $("#showcourserotate");
    if (X.length != 0) {
      X = parseInt(X.val());
    }
    var Z = parseInt($("#savezoom").val());
    if (z.settings.runningwild) {
    } else {
      if (z.settings.mode == z.settings.modes.CalibrationMode) {
        $("#" + this.routemenudiv).html(
          '<b>Calibrate map</b><br><font size=1>Drag the three red points in order to adjust the route to the map. You may replace any of the red points by clicking anywhere on the course - that will move the closest red point to this position.</font><p><b>Calibration string</b><br><font size=1>Calibration strings can be found using three-point identification in <a target=_blank href="http://omaps.worldofo.com/gps/">the WorldofO three-point calibration-tool</a>. </font>'
        );
        $("#" + this.routemenudiv).append(
          "<button onclick=\"mapviewer.saveloadcalstring('savefile',null)\">Save to file</button>"
        );
        $("#" + this.routemenudiv).append(
          "<form style=\"display:none\"><input type=\"file\"  accept=\".cal\" id=\"calinput\" style=\"display:none\"></form><button onclick=\"$('#calinput').trigger('click');\">Load from file</button><br><button onclick=\"mapviewer.open_dialog('Show/change calibration string','Calibration string:<p><textarea id=\\'setcal\\' cols=\\'60\\' rows=\\'5\\'></textarea><p><button onclick=\\'mapviewer.applysetcal();\\'>Apply new calstring</button><p><font size=1>Format: lng1|lat1|x1|y1|lng2|lat2|x2|y2|lng3|lat3|x3|y3</font>');$('#setcal').val(mapviewer.map.calstring_points);\">Show/change calstring</button>"
        );
        $("#" + this.routemenudiv).append('<div id="localmaps"></div>');
        z.updatelocalmaps();
        $("#calinput").bind("change", function (aA) {
          mapviewer.saveloadcalstring(
            "loadfile",
            aA.originalEvent.target.files
          );
        });
      } else {
        if (z.settings.mode == z.settings.modes.DrawCourseMode) {
          savecoursetofile = "";
          savecoursetofile = "<hr><p><b>Load/save course/tags</b>";
          savecoursetofile +=
            "<br><font size=1>When working as a course setter it may be an advantage to save/load course and tag data locally. This is experimental functionality.<br><i>(works only in Google Chrome)</i></font>";
          savecoursetofile +=
            '<form style="display:none"><input type="file"  accept=".json" id="courseinput" style="display:none"></form><button onclick="$(\'#courseinput\').trigger(\'click\');">Load from file</button>';
          savecoursetofile +=
            "<br><button onclick=\"mapviewer.savecourseandtags('savefile',null,null)\">Save to file</button>";
          savecoursetofile +=
            "<br><button onclick=\"mapviewer.savecourseandtags('loadbrowser',null,null)\">Load from browser</button>";
          savecoursetofile +=
            "<br><button onclick=\"mapviewer.savecourseandtags('savebrowser',null,null)\">Save internally in browser</button>";
          savecoursetofile +=
            "<br><button onclick=\"mapviewer.savecourseandtags('savegpxfile',null,null)\">Export course GPX</button>";
          savecoursetofile +=
            "<br><br><i><b>New!</b><br>Save map + course + tags to server. Please do not use this for courses for future events, play safe and save locally using the above options! If map file is larger than 3.5 MB, it will fail silently... </i><br><button onclick=\"mapviewer.savecourseandtags('saveserverwithmap',null,null)\">Save to server w/map</button><br>";
          if (
            getURLParameter("printscreen") &&
            (getURLParameter("lidstr") || getURLParameter("idstr"))
          ) {
            savecoursetofile +=
              "<br><button onclick=\"mapviewer.savecourseandtags('saveservercoursesplits',null,null)\">Save CO+splits server</button><br>";
          }
          $("#" + this.routedescdiv).html(
            '<h4>Draw Course</h4><font size=1>Click left mouse-button to add control. Click left mouse-button + hold CTRL key to remove control (if clicked close to existing control) or add extra control. Hold SHIFT key and left mouse-button while moving mouse to move controls. Hold CTRL key and left mouse-button while moving mouse to move control.</font> <p><b>Course length:<span id="showcourselength">0 m</span></b><br><button onclick="mapviewer.coursecoords=new Array();mapviewer.request_redraw();">Delete course</button><div style="margin-top:10px;" id="ocadcourses"></div>'
          );
          if (z.ocadtranslate.select_box) {
            $("#ocadcourses").html(mapviewer.ocadtranslate.select_box);
            $("#ocadcourseselect").val(z.ocadtranslate.currentcourse);
          }
          if (!courseplanning) {
            $("#" + this.routedescdiv).append(
              "<hr><b>Save Course to server</b><br><button onclick=\"mapviewer.open_dialog('savecourse',null);\">Save course</button><br><font size=1>When saving a course, all currently shown routes will be assigned to this course, as long as they do not already belong to another GPS-course. Please uncheck all routes in 'Split analysis' mode if you do not want to assign the shown routes to this course.</font>" +
                savecoursetofile
            );
          }
          z.update_courselength();
          z.update_taglength();
          if (savecoursetofile) {
            $("#courseinput").bind("change", function (aA) {
              mapviewer.savecourseandtags(
                "loadfile",
                null,
                aA.originalEvent.target.files
              );
            });
          }
          $("#" + this.routemenudiv).html("");
        } else {
          if (z.settings.mode == z.settings.modes.SaveDataMode) {
            savecoursetofile = "";
            savecoursetofile = "<h4>Save/load course/routes</h4>";
            savecoursetofile +=
              "<font size=1> Note that this will not save the map - only the course and the drawn routechoice alternatives. To continue your work you have to first loap the map, then the course/routes. The map needs to have exactly the same size (in pixels) as last time for it to work. This is experimental functionality.<br><i>(works only in Google Chrome)</i></font>";
            savecoursetofile +=
              '<form style="display:none"><input type="file"  accept=".json" id="courseinputsm" style="display:none"></form><button onclick="$(\'#courseinputsm\').trigger(\'click\');">Load from file</button>';
            savecoursetofile +=
              "<br><button onclick=\"mapviewer.savecourseandtags('savefile',null,null)\">Save to file</button>";
            savecoursetofile +=
              "<br><button onclick=\"mapviewer.savecourseandtags('loadbrowser',null,null)\">Load from browser</button>";
            savecoursetofile +=
              "<br><button onclick=\"mapviewer.savecourseandtags('savebrowser',null,null)\">Save internally in browser</button>";
            savecoursetofile +=
              "<br><br><i><b>New!</b><br>Save map + course + tags to server. Please do not use this for courses for future events, play safe and save locally using the above options! If map file is larger than 3.5 MB, it will fail silently... </i><br><button onclick=\"mapviewer.savecourseandtags('saveserverwithmap',null,null)\">Save to server w/map</button><br>";
            $("#" + this.routedescdiv).html(savecoursetofile);
            $("#courseinputsm").bind("change", function (aA) {
              mapviewer.savecourseandtags(
                "loadfile",
                null,
                aA.originalEvent.target.files
              );
            });
            $("#" + this.routemenudiv).html("");
          } else {
            var af = 0;
            if (z.settings.mode == z.settings.modes.AnalysisMode) {
              z.update_segmenttime_from_taillength();
            }
            if (xc) {
              z.sortxcresults();
            } else {
              z.routes.sort(sort_segmenttimelength);
            }
            var ao = $("#autoname_colors").val();
            $("#" + this.routemenudiv).html("");
            $("#" + this.routedescdiv).html("");
            if (xc) {
              z.settings.routecolors = new Array();
              z.settings.routenumbers = new Array();
              var ai = new Array();
              var ar = $("#cmplapnumber").val();
              var Q =
                '<font size=1>Compare to:</font><br><select id="cmplapnumber">';
              ad = "";
              if (!ar) {
                ad = " selected ";
              }
              Q += "<option value=0 " + ad + ">Fastest</option>";
              ad = "";
              if (ar == 1) {
                ad = " selected ";
              }
              Q += "<option value=1 " + ad + ">Average Joe</option>";
              ad = "";
              if (ar == 2) {
                ad = " selected ";
              }
              Q += "<option value=2 " + ad + ">Average Joe Scaled</option>";
              ad = "";
              if (ar == 99) {
                ad = " selected ";
              }
              Q += "<option value=99 " + ad + ">Own first loop DNW</option>";
              for (var ah = 0; ah < z.routes.length; ah++) {
                var M = z.routes[ah];
                var ag = M.lapdata;
                if (ag.length) {
                  for (var az = 0; az < ag.length; az++) {
                    var N = ag[az];
                    var ay = z.routes[ah].runnername;
                    var aw = ay.split(" - ");
                    var ac = aw[0];
                    if (ay.indexOf(" - ") != -1) {
                      if (!ai[ac]) {
                        ai[ac] = 0;
                      }
                      ai[ac]++;
                    }
                    if (ag.length > 1) {
                      ay = ay + " lap " + (az + 1);
                    }
                    var ad = "";
                    if (ar == ay) {
                      ad = " selected ";
                    }
                    Q +=
                      "<option value='" +
                      ay +
                      "'" +
                      ad +
                      ">" +
                      ay +
                      "</option>";
                    lapnamex = ay.replace(" - ", "-");
                    z.settings.routecolors[lapnamex] = z.routes[ah].color;
                    z.settings.routenumbers[ay] = ah;
                  }
                }
              }
              for (var ac in ai) {
                if (ai[ac] > 1) {
                  var ae = ac + " - lap-by-lap";
                  var ad = "";
                  if (ar == ae) {
                    ad = " selected ";
                  }
                  Q +=
                    "<option value='" +
                    ae +
                    "' " +
                    ad +
                    ">" +
                    ac +
                    " (lap-by-lap)</option>";
                }
              }
              Q += "</select><br>";
              $("#cmplapnumberdiv").html(Q);
              if (!z.settings.graph_showrealtime) {
                z.settings.graph_showrealtime = 0;
              }
              z.printquickbutton_toggle(
                "cmplapnumberdiv",
                "Real time",
                "id_graph_showrealtime",
                "mapviewer.toggle_graph_showrealtime()",
                z.settings.graph_showrealtime,
                "Start curves from actual starttime instead of from zero. Only works after split-routes-by-lap.",
                "font-size:10px;font-weight:normal;margin-top:4px;"
              );
            }
            var ab = 0;
            for (var az = 0; az < z.routes.length; az++) {
              if (z.routes[az].variants) {
                ab = 1;
              }
            }
            var S = -1;
            for (var az = 0; az < z.routes.length; az++) {
              addinfo = "";
              addinfotooltip = "";
              if (z.settings.mode == z.settings.modes.AnalysisMode) {
                if (z.routes[az].segmenttime > 0) {
                  var T;
                  var at;
                  var av = z.routes[az].segmenttime;
                  if (S == -1) {
                    S = av;
                    at = tominsec(av);
                  } else {
                    T = av - S;
                    at = "+" + tominsec(T);
                  }
                  var Y = tominsec(
                    Math.round(
                      (z.routes[az].segmenttime / z.routes[az].segmentlength) *
                        1000
                    )
                  );
                  addinfotooltip =
                    parseInt(z.routes[az].segmentlength) +
                    " m, " +
                    Y +
                    " min/km, " +
                    tominsec(av);
                  if (z.settings.calc_inout_times) {
                    if (
                      z.routes[az].segmenttime_out > 0 ||
                      z.routes[az].segmenttime_in > 0
                    ) {
                      addinfotooltip = addinfotooltip + "<br>";
                      if (z.routes[az].segmenttime_out > 0) {
                        addinfotooltip =
                          addinfotooltip +
                          "Out: " +
                          tominsec(z.routes[az].segmenttime_out);
                      }
                      if (z.routes[az].segmenttime_in > 0) {
                        addinfotooltip =
                          addinfotooltip +
                          " In: " +
                          tominsec(z.routes[az].segmenttime_in);
                      }
                    }
                  }
                  if (
                    mapviewer.settings.corridoranalysis == 1 &&
                    mapviewer.settings.otechanalysis == 1
                  ) {
                    var au = "";
                    if (this.routes[az].results) {
                      if (this.routes[az].results.corridor_overall) {
                        au +=
                          " " +
                          Math.round(this.routes[az].results.corridor_overall) +
                          "% (" +
                          Math.round(this.routes[az].results.corridor_time) +
                          "% time, " +
                          Math.round(this.routes[az].results.corridor_length) +
                          "% length)";
                      }
                    }
                    if (!au) {
                      au = "Not evaluated";
                    }
                    addinfotooltip = au;
                  }
                  if (
                    mapviewer.settings.compassanalysis == 1 &&
                    mapviewer.settings.otechanalysis == 1
                  ) {
                    var au = "";
                    if (this.routes[az].results) {
                      if (this.routes[az].results.compass_overall) {
                        au +=
                          " " +
                          Math.round(this.routes[az].results.compass_overall) +
                          "% compass";
                      }
                    }
                    if (!au) {
                      au = "Not evaluated";
                    }
                    addinfotooltip = au;
                  }
                  addinfo = ' <span class="runnertime">' + at + "</span>";
                  af++;
                }
              } else {
                if (z.realtime || z.IsLive) {
                  if (z.routes[az].offset != 0) {
                    addinfo =
                      ' <span class="runnertime">Offset ' +
                      tominsec(z.routes[az].offset) +
                      "</span>";
                  }
                }
                if (O) {
                  addinfotooltip =
                    "Time: " +
                    tominsec(parseInt(z.routes[az].currenttime(z.playtime)));
                }
              }
              var an = z.routes[az].color;
              if (!z.routes[az].show) {
                an = "ffffff";
              }
              thiscolorbox =
                '<div id="showroute-' +
                az +
                '" class="colorbox" style="background:#' +
                an +
                '"></div>';
              tooltipinfo =
                z.routes[az].runnername + " (" + addinfotooltip + ")";
              allinfo = "";
              if (z.settings.analyzecourse == 1 && ab) {
                if (1) {
                  var ap = z.lastcontrol;
                  if (z.routes[az].variants[ap] != null) {
                    variantname = z.tags[z.routes[az].variants[ap]].name;
                    addinfotooltip =
                      addinfotooltip + "<br>Variant " + variantname;
                  }
                }
              }
              if (this.showallinfo) {
                allinfo =
                  '<div class="allinfosmall">' + addinfotooltip + "</div>";
              }
              var aq = "";
              isfavend = "";
              if (z.routes[az].fav) {
                aq = '<font color="#800">';
                isfavend = "</font>";
              }
              $("#" + this.routedescdiv).append(
                '<div class="runnerdesc">' +
                  thiscolorbox +
                  '<span title="' +
                  tooltipinfo +
                  '"><span id="routename-' +
                  az +
                  '">' +
                  aq +
                  z.routes[az].runnername_middle +
                  isfavend +
                  "</span>" +
                  addinfo +
                  "</span>" +
                  allinfo +
                  "</div>"
              );
              $("#showroute-" + az).bind("click", function (aA, aB) {
                z.showroute(this.id);
                if (z.settings.colormode == z.settings.modes.colorbysplit) {
                  z.recolorbysplit();
                } else {
                  if (z.settings.colormode == z.settings.modes.colorbylength) {
                    z.recolorbylength();
                  }
                }
              });
              if (z.settings.analyzecourse == 1) {
                $("#routename-" + az).bind("click", function (aA, aB) {
                  z.addsplits_opendialog(this.id);
                });
              } else {
                $("#routename-" + az).bind("click", function (aA, aB) {
                  z.changenamestart_opendialog(this.id);
                });
              }
            }
            if (!courseplanning && !z.settings.definecourse) {
              $("#" + this.routemenudiv).append(
                "<hr><div style='padding-bottom:4px'><b>Choose athletes</b></div>"
              );
              this.addbutton(this.routemenudiv, "showa", "All");
              $("#showa").bind("click", function (aA, aB) {
                z.showroutes(999);
              });
              this.addbutton(this.routemenudiv, "shown", "None");
              $("#shown").bind("click", function (aA, aB) {
                z.showroutes(-1);
              });
              if (this.settings.mode == this.settings.modes.GraphMode) {
                this.addbutton(
                  this.routemenudiv,
                  "recolora",
                  "Recolor by Athlete"
                );
                this.addbutton(this.routemenudiv, "recolorb", "Recolor by lap");
                this.addbutton(this.routemenudiv, "recolorc", "Recolor all");
                $("#recolora").bind("click", function (aA, aB) {
                  z.recolorxc("byathlete");
                });
                $("#recolorb").bind("click", function (aA, aB) {
                  z.recolorxc("bylap");
                });
                $("#recolorc").bind("click", function (aA, aB) {
                  z.recolorxc("byall");
                });
              }
              if (z.settings.mode == z.settings.modes.AnalysisMode) {
                if (af > 3) {
                  this.addbutton(this.routemenudiv, "show3", "3");
                  $("#show3").bind("click", function (aA, aB) {
                    z.showroutes(3);
                  });
                }
                if (af > 6) {
                  this.addbutton(this.routemenudiv, "show6", "6");
                  $("#show6").bind("click", function (aA, aB) {
                    z.showroutes(6);
                  });
                }
                if (af > 10) {
                  this.addbutton(this.routemenudiv, "show10", "10");
                  $("#show10").bind("click", function (aA, aB) {
                    z.showroutes(10);
                  });
                }
                if (af > 0) {
                  this.addbutton(this.routemenudiv, "showvariants", "Variants");
                  $("#showvariants").bind("click", function (aA, aB) {
                    z.showvariants();
                  });
                  $("#showvariants").attr("title", help.showvariants_button);
                }
              }
              if (z.settings.mode == z.settings.modes.AnalysisMode) {
                var aa = "Color by time";
                if (z.settings.colormode == z.settings.modes.colorbysplit) {
                  aa = "Org colors";
                } else {
                }
                this.addbutton(this.routemenudiv, "recolor", aa);
                $("#recolor").bind("click", function (aA, aB) {
                  if (z.settings.colormode == z.settings.modes.colorbyorg) {
                    z.recolorbysplit();
                    z.settings.colormode = z.settings.modes.colorbysplit;
                    $("#recolor").html("Orig. colors");
                    z.updateinfobottomdiv();
                  } else {
                    z.recolorbyorg();
                    z.settings.colormode = z.settings.modes.colorbyorg;
                    $("#recolor").html("Color by time");
                    z.updateinfobottomdiv();
                  }
                });
                if (this.settings.mode != this.settings.modes.GraphMode) {
                  this.addbutton(
                    this.routemenudiv,
                    "recolora",
                    "Recolor selected"
                  );
                  $("#recolora").bind("click", function (aA, aB) {
                    z.recolorxc("byshown");
                  });
                }
                if (!xc) {
                  z.printquickbutton_toggle(
                    z.routemenudiv,
                    "AutoSelect",
                    "id_autoselect",
                    "mapviewer.toggle_autoselect()",
                    z.settings.showautoselect,
                    "Automatically select best runners on the split each time new split is selected",
                    "font-size:10px;font-weight:normal;margin-top:4px;"
                  );
                  optionstr =
                    "3-O:Spl 3|6-O:Spl 6|10-O:Spl 10|3-F:Spl 3+Favs|6-F:Spl 6+Favs|10-F:Spl 10+Favs|3-3:Spl 3+Top 3:Spl 10+Favs|6-3:Spl 6+Top 3|6-6:Spl 6+Top 6|0-F:Favs only";
                  chooseautoselect = z.printselect(
                    "AutoShow",
                    "showautoselect_select",
                    optionstr,
                    z.settings.autoselect_chosen,
                    "horlabel"
                  );
                  thestyle = "";
                  if (!z.settings.showautoselect) {
                    thestyle += "display:none;";
                  }
                  $("#" + z.routemenudiv).append(
                    '<div style="' +
                      thestyle +
                      '" id="showautoselect">' +
                      chooseautoselect +
                      "</div>"
                  );
                  $("#showautoselect_select").bind("change", function (aA, aB) {
                    z.settings.autoselect_chosen = $(
                      "#showautoselect_select"
                    ).val();
                    z.showroutes_autoselect_chosen(1);
                    z.update_routediv(false);
                    z.request_redraw();
                  });
                  this.addbutton(
                    "showautoselect",
                    "setfav",
                    "Set Favs",
                    "Set favourites. If AutoSelect is on and Favs\nare chosen under AutoShow, these are always shown"
                  );
                  $("#setfav").bind("click", function (aA, aC) {
                    for (var aB = 0; aB < z.routes.length; aB++) {
                      if (z.routes[aB].show) {
                        z.routes[aB].fav = 1;
                      } else {
                        z.routes[aB].fav = 0;
                      }
                      z.update_routediv(false);
                    }
                  });
                  this.addbutton(
                    "showautoselect",
                    "settottime",
                    "Set TotTime",
                    "Set total time of the competitors. Total times are taken from\nthe current split times for each competitor. The total time\nis used for showing Top N in AutoShow and\nwill also be used for other 2DRerun functionality in the future.\nNote! Time is only set for shown competitors!"
                  );
                  $("#settottime").bind("click", function (aC, aE) {
                    var aA = new Array();
                    for (var aD = 0; aD < z.routes.length; aD++) {
                      if (z.routes[aD].show) {
                        tottime = z.routes[aD].segmenttime;
                        if (tottime < 0) {
                          tottime = 1e99;
                        }
                      } else {
                        tottime = 1e99;
                      }
                      z.routes[aD].tottime = tottime;
                      aA.push(tottime);
                    }
                    sortWithIndeces(aA);
                    tmptmp = aA;
                    for (var aD = 0; aD < z.routes.length; aD++) {
                      var aB = aA.sortIndices[aD];
                      z.routes[aB].totplace = aD + 1;
                      z.routes[aB].totbehind =
                        z.routes[aB].tottime -
                        z.routes[aA.sortIndices[0]].tottime;
                      if (z.routes[aB].tottime == 1e99) {
                        z.routes[aB].totbehind = 9999;
                        z.routes[aB].totplace = 9999;
                      }
                    }
                  });
                }
              }
            }
            if (z.settings.analyzecourse == 1 && z.coursecoords.length > 0) {
              $("#" + z.routemenudiv).append("<hr>");
              var ax = "<h4>Course settings</h4>";
              var W = "";
              if (X == 2) {
                W = " selected";
              }
              ax +=
                '<br>Autorotate map <select id="showcourserotate" name="showcourserotate" onChange="mapviewer.update_routediv(0);"><option value="1">Yes</option><option ' +
                W +
                ' value="2">No</option></select>';
              var am = "";
              var al = "";
              var ak = "";
              var aj = "";
              if (z.settings.showtagmode == 0) {
                am = " selected";
              } else {
                if (z.settings.showtagall) {
                  aj = " selected";
                } else {
                  if (
                    z.settings.showtagmode == 1 &&
                    z.settings.tagging_timealt == 0
                  ) {
                    al = " selected";
                  } else {
                    if (
                      z.settings.showtagmode == 1 &&
                      z.settings.tagging_timealt == 4
                    ) {
                      ak = " selected";
                    }
                  }
                }
              }
              var R =
                '<hr><h4>Show drawn routechoices</h4><select id="showtagsselect" name="showtagsselect" onChange="mapviewer.showtagcoursetoggle();"><option ' +
                al +
                ' value="1">Show for selected leg</option><option ' +
                aj +
                ' value="99">Show all</option><option value="0"' +
                am +
                ">Hide all routes</option><option " +
                ak +
                ' value="2">Hide lengths</option></select>';
              if (!courseplanning) {
                al = "";
                am = "";
                if (z.settings.tagmode == 3) {
                  al = " selected";
                } else {
                  am = " selected";
                }
                R +=
                  '<br>Tag mode <select id="tagmodechoose" name="tagmodechoose"><option value="0"' +
                  am +
                  ">Off</option><option " +
                  al +
                  ' value="3">On</option></select>';
              } else {
                R +=
                  "<br><button onclick=\"$('#showtagsselect').val('0').change()\">Hide all</button> <button onclick=\"$('#showtagsselect').val('1').change()\">Show this</button>";
                z.settings.tagmode = 3;
              }
              $("#" + z.routedescdiv).append("<hr>" + R);
              $("#" + z.routedescdiv).append(
                "<h4>Name variants</h4><font size=1>Automatic name the variants for each leg A, B, C etc., and set standard colors.</font><br>"
              );
              var V = "";
              if (ao == "SPAS") {
                V = " selected ";
              }
              $("#" + z.routedescdiv).append(
                '<select id="autoname_colors"><option value="normal">Normal color scheme</option><option ' +
                  V +
                  'value="SPAS">SPAS color scheme</option></select>'
              );
              this.addbutton(
                z.routedescdiv,
                "autonametags",
                "Set names and colors"
              );
              $("#" + z.routedescdiv).append(
                '<br><font size=1><a href="javascript:void(0);" onclick="mapviewer.convert_shown_paths_to_route();">Convert shown variants to routes</a></font>'
              );
              $("#autonametags").bind("click", function (aA, aB) {
                z.autoname_tags();
                z.request_redraw();
              });
              $("#" + z.routedescdiv).append("<hr>" + ax);
              if (courseplanning) {
                $("#" + z.routemenudiv).append(
                  "<h4>Instructions</h4><font size=1>Draw a routechoice by clicking the mouse along a path - hold the Shift key to delete the last point. Finish the route by doubleclicking the last point, or by holding the Alt key while clicking the mouse.  Finished routes can be deleted by holding Ctrl while clicking the label with the mouse and modified by holding Shift while clicking the label with the mouse. The label for a routechoice can be moved by holding Alt, clicking the label and panning. Use the 'Set names and colors' button to name the variants A, B, C ...</font>"
                );
                $("#" + z.routemenudiv).append("<h4>Select leg</h4>");
              }
              this.addbutton(
                z.routemenudiv,
                "ac-back|analyzecontrol",
                "< Prev"
              );
              this.addbutton(
                z.routemenudiv,
                "ac-forward|analyzecontrol",
                "Next >"
              );
              if (!courseplanning) {
                if ($("#selectmode").val() == "replay") {
                  this.addbutton(z.routemenudiv, "ac-play|analyzecontrol", "A");
                } else {
                  this.addbutton(z.routemenudiv, "ac-play|analyzecontrol", "P");
                }
              }
              this.addbutton(z.routemenudiv, "ac-showtags|analyzecontrol", "T");
              $("#" + z.routemenudiv).append("<br>");
              for (var ap = 1; ap < z.coursecoords.length; ap++) {
                this.addbutton(
                  z.routemenudiv,
                  "ac-" + ap + "|analyzecontrol",
                  ap
                );
              }
              if (courseplanning) {
                if (typeof showeleprofilebutton != "undefined") {
                  $("#" + z.routemenudiv).append(
                    '<br><button onclick="mapviewer.showeleprofiles(0);">Show elevation profile</button>'
                  );
                }
              }
              for (var az = 0; az < z.coursecoords.length - 2; az++) {
                $("#ac-" + az).css("background-color", "#DDDDDD");
              }
              $("#ac-" + z.settings.centerlegnum).css(
                "background-color",
                "#88FF88"
              );
              $(".analyzecontrol").bind("click", function (aE, aG) {
                z.settings.autoanalysis = 0;
                var aC = this.id.split("-");
                var aD = aC[1];
                if (aD == "back" || aD == "forward") {
                  var aH = aD;
                  aD = z.settings.centerlegnum;
                  if (aD == null) {
                    aD = 1;
                  } else {
                    if (aD > z.coursecoords.length - 2 && aH == "forward") {
                      aD = 1;
                    } else {
                      if (aD == 1 && aH == "back") {
                        aD = z.coursecoords.length - 1;
                      } else {
                        if (aH == "back") {
                          aD--;
                        } else {
                          if (aH == "forward") {
                            aD++;
                          }
                        }
                      }
                    }
                  }
                }
                if (aD == "play" && $("#ac-play").text() == "A") {
                  $("#selectmode").val("analyzecourse");
                  $("#selectmode").change();
                  $("#ac-play").text("P");
                  if (z.playing) {
                    z.toggleplay();
                  }
                  aD = z.settings.centerlegnum;
                }
                if (aD == "showtags") {
                  z.waitforclick = 1;
                  z.waitforclickfunction = function (aO, aM, aI) {
                    mapviewer.waitforclick = 0;
                    var aP = 0;
                    for (var aJ = 0; aJ < z.tags.length; aJ++) {
                      var aN = z.tags[aJ];
                      if (aN.type == "route") {
                        var aQ = aN.pointsxy[0].split(",");
                        var aK = aN.pointsxy[aN.pointsxy.length - 1].split(",");
                        var aL = 15;
                        if (
                          (aQ[0] - aO) * (aQ[0] - aO) +
                            (aQ[1] - aM) * (aQ[1] - aM) <
                            aL * aL ||
                          (aK[0] - aO) * (aK[0] - aO) +
                            (aK[1] - aM) * (aK[1] - aM) <
                            aL * aL
                        ) {
                          aN.show = 1;
                          aP++;
                        } else {
                          aN.show = 0;
                        }
                      }
                    }
                    if (aP == 0) {
                      for (var aJ = 0; aJ < z.tags.length; aJ++) {
                        var aN = z.tags[aJ];
                        if (aN.type == "route") {
                          aN.show = 1;
                        }
                      }
                    }
                    mapviewer.request_redraw();
                  };
                } else {
                  if (aD == "play") {
                    if (z.settings.centerlegnum < 1) {
                      z.settings.centerlegnum = 1;
                    }
                    var aD = z.settings.centerlegnum;
                    var aA = $("#showcourserotate");
                    if (aA.length != 0) {
                      aA = parseInt(aA.val());
                    }
                    if (aA == 1 || !aA) {
                      var aB = 0.4;
                      z.centerleg(parseInt(aD - 1), aB);
                    } else {
                      var aB = 0.6;
                      z.centerleg_norotate(parseInt(aD - 1), aB);
                    }
                    aD--;
                    z.drawroutechoice_leg(aD, 1);
                    z.update_routediv(0);
                    $("#selectmode").val("replay");
                    $("#selectmode").change();
                    $("#ac-play").text("A");
                    if (!z.playing) {
                      z.toggleplay();
                    }
                  } else {
                    z.settings.centerlegnum = aD;
                    z.centerleg_frominput(aD);
                    if (z.settings.showtagall) {
                      z.showtags_control(-1);
                    }
                    for (var aF = 0; aF < z.coursecoords.length - 2; aF++) {
                      $("#ac-" + aF).css("background-color", "#DDDDDD");
                    }
                    $("#ac-" + aD).css("background-color", "#88FF88");
                  }
                }
              });
              $("#tagmodechoose").bind("change", function (aA) {
                mapviewer.settings.tagmode = parseInt(
                  $("#tagmodechoose").val()
                );
                if (mapviewer.settings.tagmode == 3) {
                  mapviewer.settings.showtagmode = 1;
                  mapviewer.currenttag = null;
                  mapviewer.request_redraw();
                  $("#showtagsselect").val(1);
                  $("#selectmode").change();
                } else {
                  z.currenttag = null;
                  z.request_redraw();
                  z.settings.infotxt = "";
                }
              });
              if (!courseplanning) {
                $("#" + z.routedescdiv).append(
                  "<hr><b>Load splits</b><br><font size=1>Note that this is very experimental functionality. IOF XML format files can be dragged onto this area to be loaded. Alternatively you can load splits from Winsplits online using the button below</font><br>"
                );
                this.addbutton(
                  z.routedescdiv,
                  "loadsplitswinsplits",
                  "Load from Winsplits"
                );
                $("#" + z.routedescdiv).append(
                  '<div id="winsplitsdiv-date"></div>'
                );
                $("#" + z.routedescdiv).append(
                  '<div id="winsplitsdiv-event"></div>'
                );
                $("#" + z.routedescdiv).append(
                  '<div id="winsplitsdiv-class"></div>'
                );
                $("#" + z.routedescdiv).append(
                  '<div id="winsplitsdiv-info"></div>'
                );
                $("#loadsplitswinsplits").bind("click", function (aA, aB) {
                  z.loadwinsplits_clickbutton("dates");
                });
                $("#" + z.routedescdiv).append(
                  "<hr><b>Analyze best/worst legs</b><br><font size=1>Experimental functionality. Works best with official split times imported. Currently shows clickable list of time losses based on selection criteria (best or worst legs)</font>"
                );
                $("#" + z.routedescdiv).append(
                  '<br>Athletes: <select id="nummistakes" name="nummistakes"><option value="3">Top 3</option><option value="6">Top 6</option><option value="10">Top 10</option><option value="All">All</option><option value="Selected">Selected</option></select>'
                );
                $("#" + z.routedescdiv).append(
                  '<br>Timeloss <select id="minmistake" name="minmistake"><option value="0">All controls</option><option value="0">- Worst legs -</option><option value="300">> 5:00</option><option value="180">> 3:00</option><option value="120">> 2:00</option><option value="90">> 1:30</option><option value="60">> 1:00</option><option value="45">> 0:45</option><option selected value="30">> 0:30</option><option value="20">> 0:20</option><option value="15">> 0:15</option><option value="10">> 0:10</option><option value="5">> 0:05</option><option value="3">> 0:03</option><option value="0">- Best legs -</option><option value="-10">< 0:10</option><option value="-20">< 0:20</option><option value="-30">< 0:30</option><option value="-60">< 1:00</option><option value="-120">< 2:00</option></select>'
                );
                if (
                  getURLParameter("test") ||
                  getURLParameter("tt") ||
                  getURLParameter("printscreen") ||
                  getURLParameter("dragdrop") ||
                  window.location.host == "localhost" ||
                  privatemaps == 2
                ) {
                  $("#" + z.routedescdiv).append(
                    '<br>Save type <select id="savemistaketype" name="savemistaketype"><option value="1">Show table</option><option value="0">Save to files</option></select>'
                  );
                }
                this.addbutton(
                  z.routedescdiv,
                  "savemistakes",
                  "Time loss overview"
                );
                $("#savemistakes").bind("click", function (aC, aD) {
                  var aB = 1;
                  if ($("#savemistaketype").val() != undefined) {
                    aB = parseInt($("#savemistaketype").val());
                  }
                  var aE = $("#minmistake").val();
                  var aA = $("#nummistakes").val();
                  z.savemistakes(aB, aE, aA);
                });
              }
              if (z.settings.enableprintscreen || courseplanning) {
                $("#" + z.routedescdiv).append("<hr><h4>Export legs</h4>");
                $("#" + z.routedescdiv).append(
                  z.printselect(
                    "Scaling of image",
                    "savezoom",
                    "0:As shown|100:Original map size|300:300% of shown size|200:200% of shown size|150:150% of shown size|90:90% of shown size|80:80% of shown size|70:70% of shown size|60:60% of shown size|50:50% of shown size|25:25% of shown size",
                    Z
                  )
                );
                this.addbutton(z.routedescdiv, "saveleg", "Save leg");
                $("#" + z.routedescdiv).append(
                  '<select id="savelegxinfo" title="Choose all to save four files for each leg. In some browsers you may have to save each of the four files separately, choose A, B, C and D and click save for each"><option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option><option value="All">All</option></select>'
                );
                $("#" + z.routedescdiv).append(
                  "<br><font size=1><i>(Works only in Google Chrome)</i></font>"
                );
                var U = "";
                if (getURLParameter("makespas") == "1") {
                  U =
                    '<br><br><button onclick="mapviewer.open_makespas_dialog();">Make SPAS</button><br><i>Very experimental feature</i><br>';
                } else {
                  U =
                    "<br><br><button disabled>Make SPAS</button><br><i>Very experimental feature only available to expert users on request.</i><br>";
                }
                $("#" + z.routedescdiv).append(
                  "<br><font size=1><i>Experimental: <a href=\"javascript:void(0);\" onclick=\"mapviewer.dosavecourse_new2('h1000','ABC',0,-1);\">Save all legs A</a>  <a href=\"javascript:void(0);\" onclick=\"mapviewer.dosavecourse_new2('h1000','nova',0,-1);\">N</a> <a href=\"javascript:void(0);\" onclick=\"mapviewer.dosavecourse_new2('w700h1000','ABC',0,-1);\">P</a></i>" +
                    U +
                    "</font>"
                );
                $("#saveleg").bind("click", function (aA, aM) {
                  z.settings.centerlegnum = parseInt(z.settings.centerlegnum);
                  var aI = "";
                  if (!z.settings.savenamecounter) {
                    z.settings.savenamecounter = new Array();
                  }
                  if (
                    !z.settings.savenamecounter[
                      parseInt(z.settings.centerlegnum)
                    ]
                  ) {
                    z.settings.savenamecounter[
                      parseInt(z.settings.centerlegnum)
                    ] = 0;
                  }
                  z
                    .settings.savenamecounter[parseInt(z.settings.centerlegnum)]++;
                  if (
                    z.settings.savenamecounter[
                      parseInt(z.settings.centerlegnum)
                    ] > 1
                  ) {
                    aI =
                      "_" +
                      parseInt(
                        z.settings.savenamecounter[
                          parseInt(z.settings.centerlegnum)
                        ]
                      )
                        .toFixed()
                        .pad(2, "0");
                  }
                  var aJ;
                  if (z.map.id == "localimage") {
                    aJ = z.map.name;
                  } else {
                    aJ = "img";
                  }
                  aJ = aJ.replace(/\.jpg/g, "");
                  aJ = aJ.replace(/_\d+/g, "");
                  aJ = aJ.replace(/[\. 骧邃鯻]/g, "");
                  var aC =
                    "leg_" +
                    parseInt(z.settings.centerlegnum).toFixed().pad(2, "0") +
                    "_" +
                    aJ +
                    aI;
                  var aH = parseInt($("#savezoom").val());
                  if (1) {
                    z.settings.isprinting = 1;
                    var aE = mapviewer.settings.tagging_timealt;
                    var aG = mapviewer.settings.showtagmode;
                    if (
                      $("#savelegxinfo").val() == "All" ||
                      $("#savelegxinfo").val() == "C"
                    ) {
                      mapviewer.settings.tagging_timealt = 0;
                      mapviewer.settings.showtagmode = 1;
                      aC =
                        "leg_" +
                        parseInt(z.settings.centerlegnum)
                          .toFixed()
                          .pad(2, "0") +
                        "_" +
                        aJ +
                        "_C";
                      z.redraw();
                      if (aH == 0) {
                        z.redraw();
                        z.play_loop();
                        z.canvas.saveDataURL(aC);
                      } else {
                        z.savearea_zoom(parseFloat(aH / 100), aC);
                      }
                    }
                    if (
                      $("#savelegxinfo").val() == "All" ||
                      $("#savelegxinfo").val() == "A"
                    ) {
                      mapviewer.settings.tagging_timealt = 0;
                      mapviewer.settings.showtagmode = 0;
                      aC =
                        "leg_" +
                        z.settings.centerlegnum.toFixed().pad(2, "0") +
                        "_" +
                        aJ +
                        "_A";
                      z.redraw();
                      if (aH == 0) {
                        z.redraw();
                        z.play_loop();
                        z.canvas.saveDataURL(aC);
                      } else {
                        z.savearea_zoom(parseFloat(aH / 100), aC);
                      }
                    }
                    if (
                      $("#savelegxinfo").val() == "All" ||
                      $("#savelegxinfo").val() == "B"
                    ) {
                      mapviewer.settings.tagging_timealt = 4;
                      mapviewer.settings.showtagmode = 1;
                      aC =
                        "leg_" +
                        z.settings.centerlegnum.toFixed().pad(2, "0") +
                        "_" +
                        aJ +
                        "_B";
                      z.redraw();
                      if (aH == 0) {
                        z.redraw();
                        z.play_loop();
                        z.canvas.saveDataURL(aC);
                      } else {
                        z.savearea_zoom(parseFloat(aH / 100), aC);
                      }
                    }
                    if (
                      $("#savelegxinfo").val() == "All" ||
                      $("#savelegxinfo").val() == "D"
                    ) {
                      aC =
                        "leg_" +
                        z.settings.centerlegnum.toFixed().pad(2, "0") +
                        "_" +
                        aJ +
                        ".txt";
                      var aF = "";
                      for (var aB = 0; aB < z.tags.length; aB++) {
                        var aL = z.tags[aB];
                        if (aL.type == "route" && aL.show) {
                          aF += aL.name + ";" + parseInt(aL.length) + "\n";
                        }
                      }
                      z.savetxtfile(aC, aF);
                    }
                    mapviewer.settings.tagging_timealt = aE;
                    mapviewer.settings.showtagmode = aG;
                    z.settings.isprinting = 0;
                  } else {
                    z.savearea_zoom(parseFloat(aH / 100), aC);
                    if (0) {
                      var aK = z.settings.centerlegnum;
                      if (aK) {
                        var aD = $("#showcourserotate");
                        if (aD.length != 0) {
                          aD = parseInt(aD.val());
                        }
                        if (aD == 1 || !aD) {
                          var aN = 0.4;
                          z.centerleg(parseInt(aK - 1), aN);
                        } else {
                          var aN = 0.6;
                          z.centerleg_norotate(parseInt(aK - 1), aN);
                        }
                      }
                    }
                  }
                });
              }
            }
            if (z.settings.routedesc_prependinfo) {
              $("#" + z.routedescdiv).prepend(z.settings.routedesc_prependinfo);
            }
          }
        }
      }
    }
  };
  this.showtagcoursetoggle = function () {
    var M = parseInt($("#showtagsselect").val());
    if (M == 0) {
      z.settings.showtagmode = 0;
      z.settings.showtagall = 0;
    } else {
      if (M == 1) {
        z.settings.showtagmode = 1;
        z.settings.showtagall = 0;
        z.settings.tagging_timealt = 0;
      } else {
        if (M == 2) {
          z.settings.showtagmode = 1;
          z.settings.showtagall = 0;
          z.settings.tagging_timealt = 4;
        } else {
          if (M == 99) {
            z.settings.showtagmode = 1;
            z.settings.showtagall = 1;
            z.settings.tagging_timealt = 0;
          }
        }
      }
    }
    if (z.settings.centerlegnum && !z.settings.showtagall) {
      z.drawroutechoice_leg(z.settings.centerlegnum, z.playing);
    } else {
      z.showtags_control(-1);
    }
    z.request_redraw();
    z.update_routediv(0);
  };
  this.setdpiscale_frominput = function () {
    var M = parseInt($("#dpi").val());
    if (!M) {
      M = 300;
    }
    $("#dpi").val(M);
    var N = parseInt($("#mapscale").val());
    if (!N) {
      N = 4000;
    }
    $("#mapscale").val(N);
    z.setdpiscale(M, N);
    z.update_courselength();
    z.update_taglength();
    z.request_redraw();
  };
  this.setdpiscale = function (N, R) {
    var M = z.map.width;
    var Y = z.map.height;
    var O = (M / N) * 2.54;
    var Q = (Y / N) * 2.54;
    var U = (O * R) / 100;
    var aa = (Q * R) / 100;
    $("#mapsize").html(
      "<i>Map size: " + parseInt(U) + " x " + parseInt(aa) + " m</i>"
    );
    var S = 60;
    var X = 5;
    var V = 0.01;
    var W = 0.01;
    var ab = calcdistance(S, X, S + V, X);
    var V = (V * U) / ab;
    var ab = calcdistance(S, X, S + V, X);
    var Z = calcdistance(S, X, S, X + W);
    var W = (W * aa) / Z;
    var Z = calcdistance(S, X, S, X + W);
    var T =
      X +
      "|" +
      S +
      "|1|1|" +
      X +
      "|" +
      (S + V) +
      "|" +
      M +
      "|1|" +
      (X + W) +
      "|" +
      S +
      "|1|" +
      Y;
    z.map.initcalibration(T);
    z.map.calstring = T;
    z.redraw();
  };
  this.applysetcal = function () {
    var M = $("#setcal").val();
    mapviewer.map.initcalibration(M);
    mapviewer.map.calstring = M;
    mapviewer.redraw();
  };
  this.make_routedesc_prependinfo = function (M) {
    if (M) {
      z.settings.routedesc_prependinfo =
        "<div id='prependinfo' style='background:#c88;font-size:10px;padding:2px;margin:2px;'>" +
        M +
        '<br><i><a href="javascript:void(0);" id="showvarlink" onclick="mapviewer.show_variant(-1)">Show variants</a></i> <a href="javascript:void(0);" onclick="$(\'#prependinfo\').hide();mapviewer.settings.routedesc_prependinfo=\'\';">Clear variants</a> <a href="javascript:void(0);" onclick="mapviewer.recolorbyvariants();">RC</a></div>';
    } else {
      z.settings.routedesc_prependinfo = "";
    }
  };
  this.interpolate_o_coursecoords = function (M) {
    var Z = z.coursecoords;
    coursecoords_alongline_arr = new Array();
    coursecoords_index = new Array();
    coursecoords_alongline_arr_latlng = new Array();
    coursecoords_alongline_arr.push(Z[0]);
    coursecoords_index.push(0);
    for (var ad = 0; ad < Z.length - 1; ad++) {
      var W = Z[ad].split(",");
      var ac = parseInt(W[0]);
      var Q = parseInt(W[1]);
      var W = Z[ad + 1].split(",");
      var ab = parseInt(W[0]);
      var N = parseInt(W[1]);
      var V = mapviewer.map.tolatlng(ac, Q);
      var S = mapviewer.map.tolatlng(ab, N);
      var U = V.lat;
      var T = S.lat;
      var af = V.lng;
      var ae = S.lng;
      if (ad == 0) {
        coursecoords_alongline_arr_latlng.push(V);
      }
      L = Math.sqrt((ab - ac) * (ab - ac) + (N - Q) * (N - Q));
      Lreal = calcdistance(U, af, T, ae);
      theta = Math.atan2(N - Q, ab - ac);
      var Y = Math.round(Lreal / M);
      for (var R = 1; R <= Y; R++) {
        var aa = R / Y;
        var X = interpolate(ac, Q, ab, N, aa);
        coursecoords_alongline_arr.push(X.xn + "," + X.yn);
        var V = z.map.tolatlng(X.xn, X.yn);
        coursecoords_alongline_arr_latlng.push(V);
      }
      coursecoords_index.push(coursecoords_alongline_arr.length - 1);
    }
    var O = new Object();
    O.xy = coursecoords_alongline_arr;
    O.latlng = coursecoords_alongline_arr_latlng;
    O.index = coursecoords_index;
    z.coursecoords_alongline_o = O;
  };
  this.check_compasses = function () {
    var N = 10;
    z.interpolate_o_coursecoords(N);
    z.compass_checks = 0;
    if (z.coursecoords.length < 1) {
      alert("Error: No course defined!");
      return;
    }
    $("#compass_isworking").show();
    $("#compass_isworking").html('<center><img src="loading.gif"></center>');
    for (var M = 0; M < z.routes.length; M++) {
      if (z.routes[M].show) {
        setTimeout("mapviewer.check_compass_runner(" + M + ");", 0);
        z.compass_checks++;
      }
    }
  };
  this.check_compass_runner = function (M) {
    z.check_compass_runner_part(M);
    z.compass_checks--;
    if (z.compass_checks == 0) {
      z.settings.corridoranalysis = 0;
      $("#id_showcorreval").prop("checked", false);
      z.settings.compassanalysis = 1;
      $("#id_showcompasseval").prop("checked", true);
      z.request_redraw();
      z.update_routediv(false);
      $("#compass_isworking").html("");
      $("#compass_isworking").hide();
    }
  };
  this.check_compass_runner_part = function (N) {
    var M = z.routes[N];
    M.offset_compass = fillarray(M.latarray.length, NaN);
    M.offset_compass_within = fillarray(M.latarray.length, NaN);
    M.offset_compass_angle = fillarray(M.latarray.length, NaN);
    if (!M.results) {
      M.results = new Object();
    }
    M.results.compass = new Object();
    M.results.compass.score = new Array();
    M.results.compass.length_score = new Array();
    M.results.compass.max_offset = new Array();
    M.results.compass.percent_offset = new Array();
    M.results.compass_overall = 0;
    var O = 0;
    for (var Q = 1; Q < z.coursecoords.length; Q++) {
      if ($.inArray(Q, z.otechinfo.compass_includelegs) >= 0) {
        z.check_compass_runner_leg(N, Q);
        M.results.compass_overall =
          M.results.compass_overall + M.results.compass.score[Q];
        O++;
      }
    }
    if (O > 0) {
      M.results.compass_overall = M.results.compass_overall / O;
    }
  };
  this.check_compass_runner_leg = function (S, ag) {
    var Q = z.coursecoords_alongline_o.index[ag - 1];
    var ae = z.coursecoords_alongline_o.index[ag];
    var N = z.routes[S];
    var am = N.splits[ag - 1].index;
    var Y = N.splits[ag].index;
    var aj = 0;
    var X = 0;
    var R = 0;
    var V = 0;
    var af = 0;
    var ah = 0;
    if (am < 0 || Y < 0) {
    } else {
      var ab = calcdistance(
        coursecoords_alongline_arr_latlng[Q].lat,
        coursecoords_alongline_arr_latlng[Q].lng,
        coursecoords_alongline_arr_latlng[ae].lat,
        coursecoords_alongline_arr_latlng[ae].lng
      );
      var Z = z.settings.compasswidth;
      var O = z.settings.compassangle;
      var aa = Math.tan((O * 2 * 3.1415) / 360);
      var ac = 0;
      var M = ab * aa;
      if (M < Z) {
        M = Z;
      }
      var U = 0;
      var ai = 0;
      for (var T = Q; T < ae; T++) {
        var ak = 1e99;
        var W = z.coursecoords_alongline_o.latlng[T];
        for (var al = am; al < Y; al++) {
          Ldist = calcdistance(W.lat, W.lng, N.latarray[al], N.lngarray[al]);
          if (Ldist < ak) {
            ak = Ldist;
          }
        }
        if (ac) {
          if (T > Q) {
            ai = ai + calcdistance(Pprev.lat, Pprev.lng, W.lat, W.lng);
          }
          Pprev = W;
          M = ai * aa;
          if (M < Z) {
            M = Z;
          }
        }
        if (ak <= M) {
          U++;
        }
      }
      var ad = (U / (ae - Q)) * 100;
      R = 0;
      for (var al = am; al < Y; al++) {
        var ak = 1e99;
        var ai = 0;
        N.offset_compass_within[al] = 0;
        for (var T = Q; T < ae; T++) {
          var W = z.coursecoords_alongline_o.latlng[T];
          Ldist = calcdistance(W.lat, W.lng, N.latarray[al], N.lngarray[al]);
          if (ac) {
            if (T > Q) {
              ai = ai + calcdistance(Pprev.lat, Pprev.lng, W.lat, W.lng);
            }
            Pprev = W;
            M = ai * aa;
            if (M < Z) {
              M = Z;
            }
          }
          if (Ldist <= M) {
            N.offset_compass_within[al] = 1;
          }
          if (Ldist < ak) {
            ak = Ldist;
          }
        }
        N.offset_compass[al] = ak;
        if (ak > ah) {
          ah = ak;
        }
        if (ak <= M) {
          af++;
        }
        R = R + ak;
      }
      R = R / (Y - am);
      aj = (af / (Y - am)) * 100;
      X = 100 - (ah / ab) * 100;
      routelength = N.calc_length(am, Y);
      V = (ab / routelength) * 100;
    }
    if (!N.results) {
      N.results = new Object();
    }
    if (!N.results.compass) {
      N.results.compass = new Object();
    }
    N.results.compass.score[ag] = aj;
    N.results.compass.length_score[ag] = V;
    N.results.compass.max_offset[ag] = ah;
    N.results.compass.percent_offset[ag] = ah / ab;
  };
  this.check_corridor_alongcorr_part = function (U, V, W, N, R) {
    var T = z.routes[U];
    for (var Q = V; Q < W; Q++) {
      var M = z.coursecoords_alongline_o.latlng[Q];
      var O = 1e99;
      for (var S = N; S < R; S++) {
        Ldist = calcdistance(M.lat, M.lng, T.latarray[S], T.lngarray[S]);
        if (Ldist < O) {
          O = Ldist;
        }
      }
      T.offset_course[Q] = O;
    }
  };
  this.check_corridor_alongroute_part = function (Q, U, T) {
    var O = z.routes[Q];
    for (var R = U; R < T; R++) {
      var N = 1e99;
      for (var S = 0; S < z.coursecoords_alongline_o.latlng.length; S++) {
        var M = z.coursecoords_alongline_o.latlng[S];
        Ldist = calcdistance(M.lat, M.lng, O.latarray[R], O.lngarray[R]);
        if (Ldist < N) {
          N = Ldist;
        }
      }
      O.offset_route[R] = N;
    }
  };
  this.check_corridors = function () {
    z.corridor_checks = 0;
    if (z.coursecoords.length < 1) {
      alert("Error: No course defined!");
      return;
    }
    z.is_working("corridor_isworking", 0.1);
    var N = 10;
    z.interpolate_o_coursecoords(N);
    for (var M = 0; M < z.routes.length; M++) {
      if (z.routes[M].show) {
        z.check_corridor(M);
        z.corridor_checks++;
      }
    }
  };
  this.is_working = function (N, M) {
    if (M != 0) {
      $("#" + N).show();
      $("#" + N).html(
        '<center><img src="loading.gif"> ' + Math.round(M) + " %</center>"
      );
    } else {
      $("#" + N).html("");
      $("#" + N).hide();
      if (N == "corridor_isworking") {
        z.settings.corridoranalysis = 1;
        $("#id_showcorreval").prop("checked", true);
        z.settings.compassanalysis = 0;
        $("#id_showcompasseval").prop("checked", false);
        z.request_redraw();
      }
    }
  };
  this.check_corridor = function (N, R, M, O) {
    if (!R) {
      R = 1;
      z.routes[N].offset_course = fillarray(
        z.coursecoords_alongline_o.xy.length,
        NaN
      );
      z.routes[N].offset_route = fillarray(z.routes[N].latarray.length, NaN);
      M = z.routes[N].currenttime(z.playtime) - z.routes[N].taillength;
      O = z.routes[N].currenttime(z.playtime);
    }
    var Q = z.check_corridor_part(N, R, M, O);
    if (Q != 0) {
      R++;
      setTimeout(function () {
        z.check_corridor(N, R, M, O);
      }, 0);
    } else {
      z.routes[N].calc_corridor_results();
      z.corridor_checks--;
      if (z.corridor_checks == 0) {
        z.update_routediv(false);
      }
    }
    z.is_working("corridor_isworking", Q);
  };
  this.check_corridor_part = function (W, V, M, O) {
    var Q = 10;
    var R = 0;
    var U = z.routes[W];
    var S = (O - M + z.coursecoords_alongline_o.xy.length) / Q;
    var N = 0;
    while (N < z.coursecoords_alongline_o.xy.length) {
      R++;
      var Y = N;
      var X = N + Q;
      if (X > z.coursecoords_alongline_o.xy.length) {
        X = z.coursecoords_alongline_o.xy.length;
      }
      if (R == V) {
        z.check_corridor_alongcorr_part(W, Y, X, M, O);
        return 100 * (R / S);
      }
      N = N + Q;
    }
    var T = M;
    while (T < O) {
      R++;
      var Y = T;
      var X = T + Q;
      if (X > U.latarray.length) {
        X = U.latarray.length;
      }
      if (R == V) {
        z.check_corridor_alongroute_part(W, Y, X);
        return 100 * (R / S);
      }
      T = T + Q;
    }
    return 0;
  };
  this.snaproutesto_o_course = function () {
    for (var N = 0; N < z.routes.length; N++) {
      var M = z.routes[N];
      M.snapto_o_course(N);
    }
    z.courseinfo.neednewsnap = 0;
  };
  this.removeroute = function (M) {
    mapviewer.routes.splice(M, 1);
    mapviewer.update_routediv(0);
  };
  this.refit = function () {
    var M = new Object();
    M.coursecoords = z.coursecoords;
    var N = jQuery.extend(true, {}, M);
    z.courseeditor_data.coursecoords = N.coursecoords;
  };
  this.snaproutestocourse = function () {
    var S = "";
    if (z.courseinfo.coursetype == "o") {
      z.snaproutesto_o_course();
      return;
    }
    if (!z.coursecoords.length || !z.courseinfo) {
      alert("No course defined!");
      return;
    }
    $("#snapcourseinfo").html("");
    for (var Q = 0; Q < z.routes.length; Q++) {
      var N = z.routes[Q];
      var O = N.snaptocourse(Q);
      var M = 0;
      if (N.lapdata.length > 0) {
        for (var R = 0; R < N.lapdata.length; R++) {
          M += N.lapdata[R].average_offset;
        }
        M = parseInt((10 * M) / N.lapdata.length) / 10;
      } else {
        M = "-";
      }
      N.calc_averages_course();
      S +=
        "&raquo; " +
        N.runnername +
        ": Fit " +
        N.lapdata.length +
        " laps (Average offset " +
        M +
        ' m)<a href="javascript:void(0)" onclick="toggle_div(\'fitinfo_route' +
        Q +
        '\');mapviewer.settings.coursedefinition_mode=0;mapviewer.request_redraw();">&nbsp;[Details]</a><br><div style="display:none;margin-top:3px;margin-bottom:6px;font-size:10px;" id="fitinfo_route' +
        Q +
        '">' +
        O.html +
        "</div>";
    }
    if ($("#snapcourseinfo").html() == "") {
      $("#snapcourseinfo").html("Found no matching routes!");
    }
    z.courseinfo.neednewsnap = 0;
    return S;
  };
  this.find_best_course = function () {
    z = mapviewer;
    var Q = new Array();
    for (var M = 0; M < z.routes.length; M++) {
      Q[M] = new Array();
      Q[M].lapdata = new Array();
      for (var T = 0; T < z.routes[M].lapdata.length; T++) {
        Q[M].lapdata[T] = new Object();
        Q[M].lapdata[T].starttime = z.routes[M].lapdata[T].starttime;
        Q[M].lapdata[T].time = z.routes[M].lapdata[T].time;
      }
    }
    for (var M = 0; M < Q.length; M++) {
      for (var T = 0; T < Q[M].lapdata.length; T++) {
        var U = M;
        var W = T;
        for (var O = 0; O < z.routes.length; O++) {
          z.routes[O].show = 0;
        }
        z.routes[U].show = 1;
        var R = z.routes[U];
        R.setpos(Q[M].lapdata[T].starttime + Q[M].lapdata[T].time, z.playtime);
        R.taillength = Q[M].lapdata[T].time + 1;
        z.auto_makecourse(2);
        z.snaproutestocourse();
        var S = 0;
        var V = 0;
        for (var O = 0; O < z.routes.length; O++) {
          for (var N = 0; N < z.routes[O].lapdata.length; N++) {
            if (z.routes[O].lapdata[N].average_offset) {
              S = S + z.routes[O].lapdata[N].average_offset;
              V++;
            }
          }
        }
        S = S / V;
        Q[M].lapdata[T].average_offset = S;
        Q[M].lapdata[T].num_fits = V;
      }
    }
  };
  this.defpointoncourse_biathlon = function (Z) {
    if (!z.courseinfo.biathlonvariables) {
      z.courseinfo.biathlonvariables = new Object();
    }
    if (z.courseeditor_data.courseinfo) {
      if (!z.courseeditor_data.courseinfo.biathlonvariables) {
        z.courseeditor_data.courseinfo.biathlonvariables = new Object();
      }
    }
    var M = z.courseinfo.biathlonvariables;
    var U = z.coursedef_drawing.currentrnr;
    var O = z.coursedef_drawing.currentpnr;
    var W = z.routes[U].latarray[parseInt(O)];
    var X = z.routes[U].lngarray[parseInt(O)];
    M[Z] = new Object();
    M[Z].lat = W;
    M[Z].lng = X;
    var M = z.courseeditor_data.courseinfo.biathlonvariables;
    M[Z] = new Object();
    M[Z].lat = W;
    M[Z].lng = X;
    z.find_biathlon_keyinfo(1);
    thisinfo = "";
    var ab = [
      "pos_beforerange",
      "pos_intorange",
      "pos_outofrange",
      "pos_afterpenalty",
    ];
    for (var Y = 1; Y < ab.length; Y++) {
      var T = new Array();
      for (var U = 0; U < z.routes.length; U++) {
        for (var aa = 0; aa < z.courseinfo.lap_spacing.length - 1; aa++) {
          if (
            z.routes[U].shootinfo[aa][ab[Y - 1]] &&
            z.routes[U].shootinfo[aa][ab[Y]]
          ) {
            var R = z.routes[U].shootinfo[aa][ab[Y - 1]]["ind"];
            var Q = z.routes[U].shootinfo[aa][ab[Y]]["ind"];
            var V = 0;
            for (var N = parseInt(R); N < parseInt(Q); N++) {
              V =
                V +
                calcdistance(
                  z.routes[U].latarray[N],
                  z.routes[U].lngarray[N],
                  z.routes[U].latarray[N + 1],
                  z.routes[U].lngarray[N + 1]
                );
            }
            T.push(V);
          }
        }
      }
      var S =
        ab[Y - 1] +
        " - " +
        ab[Y] +
        ": " +
        parseInt(T.sum() / T.length) +
        " m (" +
        parseInt(T.min()) +
        " m - " +
        parseInt(T.max()) +
        " m)<br>";
      thisinfo = thisinfo + S;
    }
    $("#biathlon_defpoints").html(thisinfo);
  };
  this.auto_makecourse = function (aa) {
    z.courseinfo.splitpos = new Array();
    var aj = 1;
    if (aa == 2) {
      aj = 0;
      aa = 0;
    }
    finished = 0;
    z.settings.autocourse_separation = parseInt($("#AutoCourseSep").val());
    z.courseinfo.lap_spacing = new Array();
    z.courseinfo.neednewsnap = 1;
    for (var O = 0; O < z.routes.length; O++) {
      if (z.routes[O].show == 1) {
        var M = z.routes[O];
        O = z.routes.length + 1;
        var ac = parseInt(M.currenttime(z.playtime) - M.segmenttime);
        var N = parseInt(M.currenttime(z.playtime));
        z.coursecoords = new Array();
        var T = z.settings.autocourse_separation;
        var Z = 0;
        var U = 0;
        var ah = 0;
        var ab = 0;
        var W;
        var Q;
        var ad;
        var ae;
        ele_moveaverage_points = z.settings.ele_moveaverage_points;
        for (var X = ac; X <= N; X++) {
          var S = M.latarray[X];
          var ai = M.lngarray[X];
          if (M.elevation) {
            if (
              z.settings.autocourse_separation >= 100 ||
              ele_moveaverage_points == 0
            ) {
              W = M.elevation[X];
            } else {
              starteind = X - ele_moveaverage_points;
              if (starteind < ac) {
                starteind = ac;
              }
              stopeind = X + ele_moveaverage_points;
              if (stopeind > N) {
                stopeind = N;
              }
              avele = 0;
              for (var af = starteind; af <= stopeind; af++) {
                avele = avele + M.elevation[af];
              }
              W = avele / (stopeind - starteind + 1);
            }
          }
          var V = 0;
          if (X != ac) {
            d = calcdistance(ah, ab, S, ai);
            Z = Z + d;
            if (Z - U > T) {
              V = 1;
              U = Z;
            }
          } else {
            V = 1;
          }
          if (X == N) {
            V = 1;
          }
          if (V) {
            var R = z.map.toxy(M.latarray[X], M.lngarray[X]);
            if (!M.elevation) {
              W = -1;
            }
            point = R.x + "," + R.y + "," + W + "," + Z;
            z.coursecoords.push(point);
          }
          ah = S;
          ab = ai;
        }
        finished = 1;
      }
    }
    if (finished) {
      z.findhills_eleprofile();
      if (aa) {
        var ag = new Object();
        ag.coursecoords = z.coursecoords;
        var Y = jQuery.extend(true, {}, ag);
        z.courseeditor_data = new Object();
        z.courseeditor_data.courseinfo = jQuery.extend(true, {}, z.courseinfo);
        z.courseeditor_data.coursecoords = Y.coursecoords;
      }
      z.settings.orunningwild.showcourse = 1;
      if (aj) {
        z.courseeditor_start();
      }
      z.request_redraw();
    } else {
      alert("No routes chosen!");
    }
  };
  this.plot_routeinfograph = function () {
    z = mapviewer;
    divtodraw = "routeinfomaingraph";
    $("#" + divtodraw).html("");
    plottitle = "Elevation";
    highlightstring =
      '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Elevation:</td><td>%s</td></tr></table>';
    yaxisformat = "%d m";
    avpoints = 2;
    var Z = new Array();
    var R = new Array();
    var S = 0;
    var U = -1e99;
    var T = 1e99;
    totdist = 0;
    for (var Y = 0; Y < z.routes.length; Y++) {
      var Q = z.routes[Y];
      if (Q.show && Q.elevation) {
        var V = new Array();
        var X = Q.currenttime(z.playtime) - Q.segmenttime;
        var W = Q.currenttime(z.playtime);
        var O = 0;
        for (var M = X; M < W; M++) {
          ele = Q.elevation[M];
          if (M == X) {
            d = 0;
            ele0 = ele;
          } else {
            d = calcdistance(
              Q.latarray[M],
              Q.lngarray[M],
              Q.latarray[M - 1],
              Q.lngarray[M - 1]
            );
          }
          ele = ele - ele0;
          O = O + d;
          V.push([O / 1000, ele]);
          if (ele < T) {
            T = ele;
          }
          if (ele > U) {
            U = ele;
          }
        }
        thislabel = Q.runnername;
        thiscolor = Q.color;
        R.push({
          color: thiscolor,
          showLine: true,
          showMarker: true,
          fill: true,
          showMarker: false,
          fillAndStroke: true,
          fillAlpha: 0.2,
          label: thislabel,
        });
        Z.push(V);
        if (O > totdist) {
          totdist = O;
        }
      }
    }
    var N = $.jqplot(divtodraw, Z, {
      cursor: { show: true, zoom: true, showTooltip: false },
      legend: {
        show: true,
        placement: "insideGrid",
        renderer: $.jqplot.EnhancedLegendRenderer,
        show: true,
      },
      series: R,
      highlighter: {
        show: true,
        sizeAdjust: 7.5,
        bringSeriesToFront: true,
        formatString: highlightstring,
      },
      axes: {
        xaxis: {
          min: 0,
          max: totdist / 1000,
          tickOptions: { formatString: "%.1f km" },
        },
        yaxis: { tickOptions: { formatString: yaxisformat } },
      },
      seriesDefaults: { color: "#ff0000" },
      title: plottitle,
      canvasOverlay: {
        show: true,
        objects: [
          {
            verticalLine: {
              name: "posline",
              x: 0.3,
              lineWidth: 6,
              color: "#000000",
              shadow: true,
              show: false,
            },
          },
        ],
      },
    });
    return N;
  };
  this.autogensplits = function (M) {
    if (!M) {
      M = 500;
    }
    mapviewer.courseinfo.splitpos = [];
    var O =
      mapviewer.courseinfo.distarray[mapviewer.courseinfo.distarray.length - 1];
    for (var N = M; N < O; N = N + M) {
      cc = closest(mapviewer.courseinfo.distarray, N);
      mapviewer.courseinfo.splitpos.push(cc[1]);
    }
  };
  this.calc_xc_splitpos = function (R) {
    z = mapviewer;
    var O = z.courseinfo.splitpos.slice(0);
    O.push(z.courseinfo.distarray.length - 1);
    var Y = "";
    Y +=
      '<div style="-webkit-user-select: all;-ms-user-select: all;-moz-user-select: all;"><table class="table" border=1 cellpadding=3 cellspacing=0>';
    Y += "<tr><th>Name</th>";
    Y += "<th>Time</th>";
    for (var T = 0; T < O.length; T++) {
      var X = parseInt(z.courseinfo.distarray[O[T]] / 100) / 10;
      Y += "<th>Split " + (T + 1) + "<br><font size=1>" + X + " km</font></th>";
    }
    Y += "</tr>";
    for (var V = 0; V < z.routes.length; V++) {
      var M = z.routes[V];
      var af = new Array();
      var ae = M.lapdata;
      if (ae.length) {
        for (var Q = 0; Q < ae.length; Q++) {
          var W = ae[Q];
          lapname = z.routes[V].runnername;
          if (ae.length > 1) {
            lapname = lapname + " - " + (Q + 1);
          }
          Y += "<tr><td>" + lapname + "</td>";
          if (R == 1) {
            Y +=
              "<td>" +
              tominsec(Math.round(W.times[W.times.length - 1] - W.times[0])) +
              "</td>";
          } else {
            if (R == 2 || R == 4) {
              Y +=
                "<td>00:" +
                tominsec(Math.round(W.times[W.times.length - 1] - W.times[0])) +
                "</td>";
            } else {
              if (R == 3) {
                Y +=
                  "<td>" +
                  Math.round(W.times[W.times.length - 1] + M.zerotime) +
                  "</td>";
              }
            }
          }
          var Z = 0;
          var N = W.times[0];
          var U = 0;
          for (var T = 0; T < O.length; T++) {
            var ac = W.times[O[T]];
            var ad = ac - W.times[0];
            var S = ac - W.times[0];
            var ab = O[T];
            var aa = ac - N;
            if (R == 1) {
              Y +=
                "<td>" +
                tominsec(Math.round(aa)) +
                "<br><font size=1>" +
                tominsec(Math.round(ad)) +
                "</font></td>";
            } else {
              if (R == 2) {
                Y += "<td>00:" + tominsec(Math.round(ad)) + "</td>";
              } else {
                if (R == 3) {
                  Y += "<td>" + Math.round(ac + M.zerotime) + "</td>";
                } else {
                  if (R == 4) {
                    Y += "<td>00:" + tominsec(Math.round(aa)) + "</td>";
                  }
                }
              }
            }
            N = ac;
            U = ab;
          }
          Y += "</tr>";
        }
      }
    }
    Y += "</table></div>";
    z.open_dialog("Split times", Y);
  };
  this.graphsettings = function (O, Q) {
    if (!Q) {
      z.open_dialog("graphsettings", O, null);
    } else {
      if (Q == "change") {
        if ($("#avpoints")) {
          z.settings.graphs[O].avpoints = parseFloat($("#avpoints").val());
          var R = z.settings.graphs[O].plottype;
          var N = z.settings.graphs[O].avpoints;
          if (R != 0) {
            if (R >= 1 && R < 5) {
              z.datafieldtypes_basic_avpoints[R] = N;
            } else {
              if (R >= 5 && R < 99) {
                z.datafieldtypes_avpoints[R - 5] = N;
              } else {
                if (R >= 101) {
                  z.datafieldtypes_avpoints_o[R] = N;
                }
              }
            }
          }
        }
        if ($("#aggregate_hillsegments").val() != undefined) {
          var M = $("#aggregate_hillsegments").val();
          if (M == 0) {
            z.settings.graphs[O].aggregate_hillsegments = 0;
          } else {
            z.settings.graphs[O].aggregate_hillsegments_type = M;
            z.settings.graphs[O].aggregate_hillsegments = 1;
          }
        } else {
          z.settings.graphs[O].aggregate_hillsegments = 0;
        }
      } else {
        if (Q == "change-exp") {
          if ($("#plot_average_segments")) {
            z.settings.graphs[O].plot_average_segments = parseInt(
              $("#plot_average_segments").val()
            );
          }
          z.settings.graphs[O].plotdiff = parseInt($("#plotdiff").val());
          z.settings.graphs[O].includeele_percent_min = parseInt(
            $("#includeele_percent_min").val()
          );
          z.settings.graphs[O].includeele_percent_max = parseInt(
            $("#includeele_percent_max").val()
          );
          z.settings.graphs[O].fraction_for_zero =
            parseFloat($("#fraction_for_zero").val()) / 100;
          z.close_dialog();
        }
      }
    }
  };
  this.plotgraph = function (bn, b0, bf) {
    var aE = z.settings.graphs[bf].plot_average_segments;
    force_aggregate_hillsegments = 0;
    if (b0 == 998) {
      force_aggregate_hillsegments = 1;
      b0 = 1;
    }
    if (b0 == 4 && z.courseinfo.coursetype != "o") {
      var a4 = z.ploteleprofile(bn);
      return a4;
    } else {
      if (b0 == 999 && z.courseinfo.coursetype != "o") {
        var a4 = z.makelapanimation(bn);
        return a4;
      }
    }
    bn = bn.substr(1);
    $("#" + bn).html("");
    var aR = "normal";
    var bi = 2;
    if (b0 >= 1 && b0 < 5) {
      bi = z.datafieldtypes_basic_avpoints[b0];
    } else {
      if (b0 >= 5 && b0 < 99) {
        bi = z.datafieldtypes_avpoints[b0 - 5];
        aR = z.datafieldtypes_avtypes[b0 - 5];
      } else {
        if (b0 >= 101) {
          bi = z.datafieldtypes_avpoints_o[b0];
          aR = z.datafieldtypes_avtypes_o[b0];
        }
      }
    }
    if (
      z.settings.graphs[bf].aggregate_hillsegments ||
      force_aggregate_hillsegments
    ) {
      var cd = z.settings.graphs[bf].aggregate_hillsegments_type;
      if (!cd) {
        cd = "Complete";
      }
      if (b0 == 1) {
        z.plot_persegment(bn, "times", cd);
      } else {
        if (b0 == 5) {
          z.plot_persegment(bn, "pulse", cd);
        } else {
          $("#" + bn).html(
            "<b>Can not plot this datatype aggregated over hillsegment types!</b>"
          );
        }
      }
      return;
    }
    if (b0 == 1) {
      if (z.settings.graphs[bf].plot_average_segments) {
        z.settings.graphs[bf].plotdiff = 1;
      }
      plottitle = "Time behind virtual leader [seconds]";
      highlightstring =
        '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Time behind:</td><td>%s</td></tr></table>';
      yaxisformat = "%d s";
    } else {
      if (b0 == 2) {
        plottitle = "Comparison of speed [m/s]";
        highlightstring =
          '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Speed:</td><td>%#.1f m/s</td></tr></table>';
        yaxisformat = "%.1f ";
      } else {
        if (b0 == 3) {
          plottitle = "Comparison of pace [min/km]";
          highlightstring =
            '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Pace:</td><td>%#.1f min/km</td></tr></table>';
          yaxisformat = "%.1f ";
        } else {
          if (b0 == 4) {
            plottitle = "Comparison of elevation [m]";
            highlightstring =
              '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Pace:</td><td>%#.1f m</td></tr></table>';
            yaxisformat = "%.1f ";
          } else {
            if (b0 == 101) {
              plottitle = "Comparison of pulse";
              highlightstring =
                '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Pulse:</td><td>%d </td></tr></table>';
              yaxisformat = "%.1f";
            } else {
              if (b0 == 102) {
                plottitle = "Comparison of distance from line";
                highlightstring =
                  '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>From line:</td><td>%d m</td></tr></table>';
                yaxisformat = "%d";
              } else {
                if (b0 == 103) {
                  plottitle = "Comparison of distance along line";
                  highlightstring =
                    '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Along line:</td><td>%d m</td></tr></table>';
                  yaxisformat = "%d";
                } else {
                  if (z.datafieldtypes[b0 - 5] == "power") {
                    plottitle = "Comparison of power [W]";
                    highlightstring =
                      '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Power:</td><td>%#.1f W</td></tr></table>';
                    yaxisformat = "%.1f ";
                  } else {
                    if (z.datafieldtypes[b0 - 5] == "pgravity") {
                      plottitle = "Comparison of pgravity (M=80kg) [W]";
                      highlightstring =
                        '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Power:</td><td>%#.1f W</td></tr></table>';
                      yaxisformat = "%.1f ";
                    } else {
                      if (z.datafieldtypes[b0 - 5] == "pfriction") {
                        plottitle =
                          "Comparison of Pfriction (m=80kg, u=0.04) [W]";
                        highlightstring =
                          '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Power:</td><td>%#.1f W</td></tr></table>';
                        yaxisformat = "%.1f ";
                      } else {
                        if (z.datafieldtypes[b0 - 5] == "pdrag") {
                          plottitle =
                            "Comparison of Pdrag (A*Cd=0.35, rho=1.2255) [W]";
                          highlightstring =
                            '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Power:</td><td>%#.1f W</td></tr></table>';
                          yaxisformat = "%.1f ";
                        } else {
                          if (z.datafieldtypes[b0 - 5] == "pacc") {
                            plottitle = "Comparison of Pacceleration [m/s^2]";
                            highlightstring =
                              '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>Power:</td><td>%#.1f W</td></tr></table>';
                            yaxisformat = "%.1f ";
                          } else {
                            if (
                              b0 - 5 ==
                              $.inArray("pulse_break", z.datafieldtypes)
                            ) {
                              var a7 = z.plot_var_in_break(bn, "pulse");
                              return a7;
                            } else {
                              if (
                                b0 - 5 ==
                                $.inArray("speed_break", z.datafieldtypes)
                              ) {
                                var a7 = z.plot_var_in_break(bn, "speed");
                                return a7;
                              } else {
                                if (
                                  b0 - 5 ==
                                  $.inArray(
                                    "bia_pulse_shooting",
                                    z.datafieldtypes
                                  )
                                ) {
                                  var a7 = z.plot_biabars(bn, "pulse", null);
                                  return a7;
                                } else {
                                  if (
                                    b0 - 5 ==
                                    $.inArray(
                                      "bia_time_shooting",
                                      z.datafieldtypes
                                    )
                                  ) {
                                    var a7 = z.plot_biabars(bn, "time", null);
                                    return a7;
                                  } else {
                                    if (b0 >= 5 && b0 < 99) {
                                      var aO = mapviewer.datafieldtypes;
                                      var ad =
                                        mapviewer.datafieldtypes_avpoints;
                                      var bb = mapviewer.datafieldtypes_avtypes;
                                      var aT = aO[b0 - 5];
                                      var aG =
                                        mapviewer.datafieldtypes_display[
                                          b0 - 5
                                        ];
                                      plottitle = "Comparison of " + aG;
                                      highlightstring =
                                        '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>%s</td></tr> <tr><td>' +
                                        aT +
                                        ":</td><td>%.1f </td></tr></table>";
                                      yaxisformat = "%.1f";
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var aF = z.settings.graphs[bf].fraction_for_zero;
    var T = z.settings.graphs[bf].includeele_percent_min;
    var az = z.settings.graphs[bf].includeele_percent_max;
    var ay = 0;
    var bd = $("#cmplapnumber").val();
    var aU;
    if (bd) {
      aU = bd.split(" - ");
      if (aU[1]) {
        if (aU[1].indexOf("lap-by-lap") != -1) {
          ay = 1;
        }
      }
    }
    if (ay) {
      var aU = bd.split(" - ");
      bd = aU[0];
      for (var aS = 0; aS < z.routes.length; aS++) {
        if (z.routes[aS].lapdata.length > 1) {
          alert(
            "Compare lap by lap only works after you have used split-routes-by-lap. Sorry!"
          );
          return;
        }
      }
    }
    var bC = 0;
    var aD = 0;
    if (z.settings.graph_compare_winner) {
      if (bd == 1) {
        aD = 1;
      } else {
        if (bd == 2) {
          aD = 2;
        }
      }
      if (bd == 99) {
        bC = 1;
      }
    }
    var ac = new Array();
    var aa = 0;
    var R = 0;
    var bN = 0;
    var a2 = 1e99;
    for (var aS = 0; aS < z.routes.length; aS++) {
      var bc = z.routes[aS];
      if (bc.show && bc.zerotime < a2) {
        a2 = bc.zerotime;
      }
      if (bc.show || aD) {
        if (aD && z.settings.exclude_averagejoe[z.routes[aS].runnername]) {
        } else {
          var aX = new Array();
          var Q = bc.lapdata;
          if (Q.length) {
            for (var U = 0; U < Q.length; U++) {
              var M = Q[U];
              for (var bW = 0; bW < M.times.length; bW++) {
                if (aa == 0) {
                  if (aD) {
                    ac[bW] = 0;
                  } else {
                    ac[bW] = 1e99;
                  }
                }
                var bM = M.times[bW];
                if (aD) {
                  ac[bW] += bM;
                } else {
                  if (bM < ac[bW]) {
                    ac[bW] = bM;
                  }
                }
              }
              aa++;
              R++;
            }
          }
        }
      }
    }
    var ao = ac[0];
    for (var bW = 0; bW < ac.length; bW++) {
      ac[bW] = parseFloat(ac[bW]) - ao;
    }
    if (aD && R > 1) {
      for (var bW = 0; bW < ac.length; bW++) {
        ac[bW] = ac[bW] / R;
      }
    }
    var b4 = mapviewer.courseinfo.hillsegments;
    var aY = null;
    var aL = null;
    if (b4) {
      var aW = new Array();
      var bR = new Array();
      var aa = 0;
      var R = 0;
      for (var aS = 0; aS < z.routes.length; aS++) {
        var bc = z.routes[aS];
        var aX = new Array();
        var Q = bc.lapdata;
        if (Q.length) {
          for (var U = 0; U < Q.length; U++) {
            var M = Q[U];
            lapname = z.routes[aS].runnername;
            if (Q.length > 1) {
              lapname = lapname + " - " + (U + 1);
            }
            comparethis = 0;
            if (z.settings.graph_compare_winner) {
              if (aD) {
                comparethis = 1;
              } else {
                if (bd == lapname && !ay && !bC) {
                  aY = aS + "-" + U;
                  comparethis = 1;
                } else {
                  if (bC) {
                    var aU = lapname.split(" - ");
                    bV = aU[0];
                    lapnum = aU[1];
                    if (lapnum == 1 && bc.show) {
                      comparethis = 1;
                      aY = aS + "-" + U;
                    }
                  } else {
                    if (ay) {
                      var aU = lapname.split(" - ");
                      bV = aU[0];
                      if (bd == bV) {
                        comparethis = 1;
                        aY = aS;
                      }
                    }
                  }
                }
              }
            }
            if (bc.show || comparethis) {
              if (
                aD &&
                !z.settings.exclude_averagejoe[z.routes[aS].runnername]
              ) {
                R++;
              }
              var ca = 0;
              for (var bW = 0; bW < M.averages.times.length; bW++) {
                if (aD && aa == 0) {
                  aW[bW] = 0;
                  bR[bW] = 0;
                } else {
                  if (aa == 0) {
                    aW[bW] = 1e99;
                    bR[bW] = 1e99;
                  }
                }
                var bM = M.averages.times[bW];
                ca = ca + bM;
                if (aD) {
                  if (!z.settings.exclude_averagejoe[z.routes[aS].runnername]) {
                    aW[bW] = aW[bW] + bM;
                  }
                } else {
                  if (bM < aW[bW]) {
                    aW[bW] = bM;
                  }
                }
                if (aD) {
                  if (!z.settings.exclude_averagejoe[z.routes[aS].runnername]) {
                    bR[bW] = bR[bW] + ca;
                  }
                } else {
                  if (ca < bR[bW]) {
                    bR[bW] = ca;
                    if (bW == M.averages.times.length - 1) {
                      aL = aS + "-" + U;
                    }
                  }
                }
              }
              aa++;
            }
          }
        }
      }
      if (aD && R > 1) {
        aL = "X-X";
        for (var bW = 0; bW < aW.length; bW++) {
          aW[bW] = aW[bW] / R;
          bR[bW] = bR[bW] / R;
        }
      }
    }
    var a3 = z.settings.autocourse_separation;
    var bo = -1;
    var bK = -1;
    var aj = "raskeste";
    if (aL) {
      var V = aL.split("-");
      var bo = V[0];
      var bK = V[1];
      var aj;
    } else {
    }
    if (aD == 2) {
      bo = -1;
      bK = -1;
      aj = "tidsjustert Average Joe";
    } else {
      if (aD) {
        bo = -1;
        bK = -1;
        aj = "Average Joe";
      } else {
        if (z.settings.graph_compare_winner && aY) {
          if (!ay) {
            V = aY.split("-");
            bo = V[0];
            bK = V[1];
          } else {
            bo = aY;
            bK = "";
          }
          aj = z.routes[bo].runnername;
          if (z.routes[bo].lapdata.length > 1 && !ay && !bC) {
            aj = aj + " lap " + (bK + 1);
          } else {
            if (bC) {
              aj = " (sammenlignet med forste runde)";
            } else {
              var aU = aj.split(" - ");
              var Y = aU[0];
              aj = Y + " (runde for runde)";
            }
          }
        }
      }
    }
    var b2 = new Array();
    var bU = new Array();
    var bu = new Array();
    var an = new Array();
    var aa = 0;
    var O = 0;
    var b5 = z.settings.graphs[bf].graphannotate;
    for (var aS = 0; aS < b5.length; aS++) {
      if (b5[aS].xinfo == "statdiv") {
        b5.splice(aS, 1);
        aS--;
      }
    }
    var by = new Array();
    by.push({
      verticalLine: {
        name: "posline",
        x: 0.3,
        lineWidth: 6,
        color: "#000000",
        shadow: true,
        show: false,
      },
    });
    $("#statdiv").val("");
    var b8 = "Tids";
    if (b0 == 5 || b0 == 101) {
      b8 = "Puls";
    } else {
      if (b0 >= 6) {
        b8 = mapviewer.datafieldtypes_display[b0 - 5];
      }
    }
    for (var aS = 0; aS < z.routes.length; aS++) {
      var bc = z.routes[aS];
      if (bc.show) {
        var Q = bc.lapdata;
        if (Q.length) {
          var aA = new Array();
          for (var U = 0; U < Q.length; U++) {
            aa++;
            var aX = new Array();
            var M = Q[U];
            lapname = z.routes[aS].runnername;
            if (Q.length > 1) {
              lapname = lapname + " lap " + (U + 1);
            }
            if (U == 0 && aS == 0) {
              firstlapname = lapname;
            }
            var bA;
            var aM;
            var ak;
            if (ay) {
              var aU = z.routes[aS].runnername.split(" - ");
              b1 = parseInt(aU[1]);
              var aU = z.routes[bo].runnername.split(" - ");
              bA = aU[0];
              aM = z.settings.routenumbers[bA + " - " + b1];
              ak = 0;
            }
            if (bC) {
              var aU = z.routes[aS].runnername.split(" - ");
              var bA = aU[0];
              var b1 = parseInt(aU[1]);
              aM = z.settings.routenumbers[bA + " - 1"];
              ak = 0;
            }
            var af = 0;
            for (var bW = 1; bW < M.times.length; bW++) {
              var ah;
              var a3;
              ah = M.times[bW] - M.times[bW - 1];
              a3 = z.courseinfo.distarray[bW] - z.courseinfo.distarray[bW - 1];
              if (a3 != 0) {
                thispace = ((ah / a3) * 1000) / 60;
                thisspeed = a3 / ah;
              } else {
                thispace = 0;
                thisspeed = 0;
              }
              thispos2 = z.courseinfo.distarray[bW];
              if (z.settings.graphs[bf].plotdiff && b0 == 1) {
                thisbehind = M.times[bW] - M.times[1];
                plottitle =
                  b8 +
                  "differanse i forhold til " +
                  firstlapname +
                  " (" +
                  firstlapname +
                  " er null-linjen)";
              } else {
                if (!z.settings.graph_compare_winner) {
                  aA[bW] = ac[bW] - ac[0];
                  thisbehind = -(M.times[bW] - M.times[0] - aA[bW]);
                } else {
                  if (aD) {
                    if (aD == 1) {
                      aA[bW] = ac[bW] - ac[1];
                      plottitle = b8 + "differanse i forhold til Average Joe";
                    } else {
                      var aC =
                        (1 / (ac[ac.length - 1] - ac[0])) *
                        (M.times[M.times.length - 1] - M.times[0]);
                      aA[bW] = ac[bW] * aC - ac[1];
                      plottitle =
                        b8 + "differanse i forhold til tidsjustert Average Joe";
                    }
                    thisbehind = -(M.times[bW] - M.times[1] - aA[bW]);
                  } else {
                    if (!ay && !bC) {
                      if (bo == -1) {
                        bo = 0;
                      }
                      if (bK == -1) {
                        bK = 0;
                      }
                      aA[bW] =
                        z.routes[bo].lapdata[bK].times[bW] -
                        z.routes[bo].lapdata[bK].times[1];
                      thisbehind = -(M.times[bW] - M.times[1] - aA[bW]);
                      if (b0 == 5 || b0 == 101) {
                        plottitle = "Sammenligning av hjertefrekvens";
                      } else {
                        if (b0 >= 6) {
                          b8 =
                            "Sammenligning av " +
                            mapviewer.datafieldtypes_display[b0 - 5];
                        } else {
                          plottitle =
                            b8 +
                            "differanse i forhold til " +
                            z.routes[bo].runnername +
                            " (" +
                            z.routes[bo].runnername +
                            " er null-linjen)";
                        }
                      }
                    } else {
                      if (bC) {
                        aA[bW] =
                          z.routes[aM].lapdata[ak].times[bW] -
                          z.routes[aM].lapdata[ak].times[1];
                        thisbehind = -(M.times[bW] - M.times[1] - aA[bW]);
                        plottitle =
                          b8 + "differanse i forhold til f&oslash;rste runde";
                      } else {
                        aA[bW] =
                          z.routes[aM].lapdata[ak].times[bW] -
                          z.routes[aM].lapdata[ak].times[1];
                        thisbehind = -(M.times[bW] - M.times[1] - aA[bW]);
                        plottitle =
                          b8 +
                          "differanse i forhold til " +
                          bA +
                          " (f&oslash;rste runde sammenlignes med f&oslash;rste, andre med andre osv.)";
                      }
                    }
                  }
                }
              }
              var bJ = z.settings.graph_showrealtime;
              if (bJ) {
                thisbehind = thisbehind - (bc.zerotime - a2);
              }
              if (b0 == 1) {
                if (bW == 1) {
                  if (bJ) {
                    aX.push([0, thisbehind]);
                  } else {
                    aX.push([0, 0]);
                  }
                }
                aX.push([thispos2 / 1000, thisbehind]);
              } else {
                if (b0 == 2) {
                  aX.push([thispos2 / 1000, thisspeed]);
                } else {
                  if (b0 == 3) {
                    aX.push([thispos2 / 1000, thispace]);
                  } else {
                    if (b0 == 4) {
                      bv = NaN;
                      if (M.elevation) {
                        bv = M.elevation[bW];
                      }
                      aX.push([thispos2 / 1000, bv]);
                    } else {
                      if (b0 == 101) {
                        bv = NaN;
                        if (M.pulse) {
                          bv = M.pulse[bW];
                          if (z.courseinfo.coursetype != "o") {
                            bv = (bv / bc.maxpulse) * 100;
                          }
                        }
                        aX.push([thispos2 / 1000, bv]);
                      } else {
                        if (b0 == 102) {
                          bv = Math.abs(M.dist_from_line[bW]);
                          aX.push([thispos2 / 1000, bv]);
                        } else {
                          if (b0 == 103) {
                            bv = M.routedist[bW] - M.dist_along_line[bW];
                            aX.push([thispos2 / 1000, bv]);
                          } else {
                            if (
                              z.datafieldtypes[b0 - 5] == "power" ||
                              z.datafieldtypes[b0 - 5] == "pgravity" ||
                              z.datafieldtypes[b0 - 5] == "pfriction" ||
                              z.datafieldtypes[b0 - 5] == "pdrag" ||
                              z.datafieldtypes[b0 - 5] == "pacc"
                            ) {
                              var aV = z.settings.power_mass;
                              var a1 = 9.81;
                              var al = z.settings.power_mu_g;
                              var bB = z.settings.power_air_ACD;
                              var b7 = 1.2255;
                              power_av_points_each_side = 5;
                              var bm;
                              var b3;
                              if (power_av_points_each_side == 0) {
                                bm = bW - 1;
                                b3 = bW;
                              } else {
                                bm = bW - power_av_points_each_side;
                                b3 = bW + power_av_points_each_side;
                              }
                              if (bm < 0) {
                                bm = 0;
                              }
                              if (b3 > z.courseinfo.distarray.length - 1) {
                                b3 = z.courseinfo.distarray.length - 1;
                              }
                              var X =
                                z.courseinfo.distarray[b3] -
                                z.courseinfo.distarray[bm];
                              var bL = M.times[b3] - M.times[bm];
                              var bT = 0;
                              var br = 0;
                              if (X != 0) {
                                bT = X / bL;
                                var bI = z.coursecoords[bm].split(",");
                                var bG = z.coursecoords[b3].split(",");
                                br = parseFloat(bG[2]) - parseFloat(bI[2]);
                              }
                              var aN = bT;
                              var a6 = (bT - af) / ah;
                              var bl = Math.atan2(br, X);
                              var at = (bl * 360) / (2 * 3.1415926);
                              var bz = aN;
                              var bD = aV * a1 * Math.sin(bl) * aN;
                              var bh =
                                (1 - 0.05) * aV * a1 * Math.cos(bl) * al * bz;
                              var bt = 0.5 * b7 * (aN * aN) * bB * aN;
                              var a0 = aV * a6 * aN;
                              var ai = bD + bh + bt + a0;
                              if (z.datafieldtypes[b0 - 5] == "power") {
                                aX.push([thispos2 / 1000, ai]);
                              } else {
                                if (z.datafieldtypes[b0 - 5] == "pgravity") {
                                  aX.push([thispos2 / 1000, bD]);
                                } else {
                                  if (z.datafieldtypes[b0 - 5] == "pfriction") {
                                    aX.push([thispos2 / 1000, bh]);
                                  } else {
                                    if (z.datafieldtypes[b0 - 5] == "pdrag") {
                                      aX.push([thispos2 / 1000, bt]);
                                    } else {
                                      if (z.datafieldtypes[b0 - 5] == "pacc") {
                                        aX.push([thispos2 / 1000, a0]);
                                      }
                                    }
                                  }
                                }
                              }
                              af = bT;
                            } else {
                              if (b0 >= 4) {
                                if (M[aT]) {
                                  bv = M[aT][bW];
                                } else {
                                  bv = 0;
                                }
                                aX.push([thispos2 / 1000, bv]);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (aE) {
              var N = average_line_segments(aX, z.settings.graphs[bf]);
              b2.push(N);
            } else {
              if (bi > 0) {
                var N = average_line(aX, bi, aR);
                b2.push(N);
              } else {
                b2.push(aX);
              }
            }
            var ax = lapname;
            if (U == 0) {
              aK = "#" + bc.color;
            } else {
              aK = "#" + z.linecolors[aa + z.routes.length];
            }
            z.courseinfo.coursecolortype = parseInt(
              $("#courseprofiletype").val()
            );
            z.settings.courseprofileshowgrade = parseInt(
              $("#courseprofilegrade").val()
            );
            var ba = parseInt($("#timegraphfilled").val());
            var a8 = true;
            if (
              (z.settings.graph_compare_winner &&
                aS == bo &&
                U == bK &&
                b0 == 1) ||
              !ba
            ) {
              a8 = false;
            }
            if (O == 1) {
              bU.push({
                color: aK,
                showLine: true,
                showMarker: true,
                fill: a8,
                showMarker: false,
                pointLabels: { show: true, location: "x" },
                fillAndStroke: a8,
                fillAlpha: 0.2,
                label: ax,
              });
            } else {
              bU.push({
                color: aK,
                showLine: true,
                showMarker: true,
                fill: a8,
                showMarker: false,
                fillAndStroke: a8,
                fillAlpha: 0.2,
                label: ax,
              });
            }
            var bx = 1;
            var a5 = 1;
            if (bC) {
              a5 = 0;
            }
            if (a5 && b4 && b0 == 1) {
              var bQ = new Array();
              var aI = new Array();
              if (!z.settings.graph_compare_winner) {
                bQ = aW.slice(0);
                aI = bR.slice(0);
              } else {
                var b6;
                if (aD) {
                  if (aD == 1) {
                    b6 = aW.slice(0);
                  } else {
                    b6 = aW.slice(0);
                    var aC =
                      (1 / (ac[ac.length - 1] - ac[0])) *
                      (M.times[M.times.length - 1] - M.times[0]);
                    for (var bX = 0; bX < bR.length; bX++) {
                      b6[bX] = b6[bX] * aC;
                    }
                  }
                } else {
                  if (!ay) {
                    b6 = z.routes[bo].lapdata[bK].averages.times;
                  } else {
                    b6 = z.routes[aM].lapdata[ak].averages.times;
                  }
                }
                bQ = b6.slice(0);
                aI[0] = b6[0];
                for (var bw = 1; bw < aW.length; bw++) {
                  aI[bw] = b6[bw] + aI[bw - 1];
                }
              }
              var aX = new Array();
              var bg = 0;
              var ab = 0;
              var bE = 0;
              var bF = 0;
              var ar = [0, 0, 0, 0];
              for (var bW = 0; bW < M.averages.times.length; bW++) {
                var bk = bE + b4[bW].thelength;
                var ah = M.averages.times[bW] - bQ[bW];
                bg = bg + ah;
                ab = ab + M.averages.times[bW];
                var av = ab - aI[bW];
                ddt = av - bF;
                ar[b4[bW].thetypeint + 1] += ddt;
                var a9 = z.hilltypes;
                var am = 1;
                if (
                  Math.abs(ddt) >= mapviewer.settings.timegraphlimit &&
                  aS + "-" + bW != aL
                ) {
                  if (ddt > 0) {
                    plusminus = "+ ";
                  } else {
                    plusminus = "- ";
                  }
                  var au = (bE + bk) / 2;
                  var bv = -(bF + av) / 2;
                  if (bJ) {
                    bv = bv - (bc.zerotime - a2);
                  }
                  if (mapviewer.settings.timegraphtype) {
                    aX.push([
                      au / 1000,
                      bv,
                      plusminus + Math.round(Math.abs(ddt)) + " s",
                    ]);
                  }
                  var aB = "rgba(0,0,0,0.3)";
                } else {
                  if (mapviewer.settings.timegraphtype == 1) {
                    am = 0;
                  }
                }
                if (
                  !mapviewer.settings.timegraphtype ||
                  mapviewer.settings.timegraphtype == 3
                ) {
                  am = 0;
                }
                if (am) {
                  by.push({
                    horizontalLine: {
                      xmin: bE / 1000,
                      xmax: bk / 1000,
                      y: -bF,
                      lineWidth: 1,
                      color: aB,
                      shadow: false,
                    },
                  });
                  by.push({
                    horizontalLine: {
                      xmin: bE / 1000,
                      xmax: bk / 1000,
                      y: -av,
                      lineWidth: 1,
                      color: aB,
                      shadow: false,
                    },
                  });
                  by.push({
                    verticalLine: {
                      x: bE / 1000,
                      ymin: -av,
                      ymax: -bF,
                      lineWidth: 1,
                      color: aB,
                      shadow: false,
                    },
                  });
                  by.push({
                    verticalLine: {
                      x: bk / 1000,
                      ymin: -av,
                      ymax: -bF,
                      lineWidth: 1,
                      color: aB,
                      shadow: false,
                    },
                  });
                }
                if (mapviewer.settings.timegraphtype == 2) {
                  var aK = z.hillcolorsongraph2[b4[bW].thetypeint + 1];
                  by.push({
                    rectangle: {
                      xmin: bE / 1000,
                      xmax: bk / 1000,
                      ymin: -av,
                      ymax: -bF,
                      color: aK,
                      shadow: false,
                    },
                  });
                }
                bE = bk;
                bF = av;
              }
              if (!(aS == bo && U == bK) && b0 == 1) {
                var bV = lapname.replace(/ - /gi, "-");
                var ap;
                if (aj) {
                  ap = aj.replace(/ - /gi, "-");
                } else {
                  ap = "raskeste";
                }
                timediffstr =
                  bV +
                  "|" +
                  ap +
                  "|" +
                  plusminusr(av) +
                  "|" +
                  plusminusr(ar[2]) +
                  "|" +
                  plusminusr(ar[0]) +
                  "|" +
                  plusminusr(ar[1]);
                if (ar[3]) {
                  timediffstr += "|" + plusminusr(ar[3]);
                }
                $("#statdiv").val(
                  $("#statdiv").val() + timediffstr + " s\n---------------\n"
                );
                obj = new Object();
                obj.txt = timediffstr;
                obj.type = "text";
                obj.xinfo = "statdiv";
                obj.txtsize = Math.round(
                  mapviewer.settings.graphannotatetxtsize * 0.85
                );
                z.settings.graphs[bf].graphannotate.push(obj);
              }
              if (aX.length) {
                if (O == 1) {
                  bx = 0;
                  prevline = b2[b2.length - 1];
                  bw = 0;
                  for (var bW = 0; bW < prevline.length; bW++) {
                    thisxpoint = aX[bw];
                    thispoint = prevline[bW];
                    if (thisxpoint == null) {
                      prevline[bW].push(null);
                    } else {
                      if (thispoint[0] >= thisxpoint[0]) {
                        prevline[bW].push(thisxpoint[2]);
                        bw++;
                      } else {
                        prevline[bW].push(null);
                      }
                    }
                  }
                } else {
                  bu.push(aX);
                  an.push({
                    color: aK,
                    showMarker: false,
                    showLabel: false,
                    showLine: false,
                    pointLabels: { show: true, location: "x" },
                    fillAlpha: 1,
                    label: ax,
                  });
                }
              }
            }
            if (O == 1) {
              if (bx) {
                prevline = b2[b2.length - 1];
                for (var bW = 0; bW < prevline.length; bW++) {
                  prevline[bW].push(null);
                }
              }
            }
          }
        }
      }
    }
    if (aE && b0 != 1) {
      plottitle =
        plottitle +
        ", averaged over hill segments, showing for " +
        T +
        "% to " +
        az +
        "%";
    }
    if (b2.length > 0) {
      totdist = thispos2 / 1000;
      if (z.settings.graphs[bf].plotdiff && b2.length > 1) {
        var bH = b2[0];
        for (var bw = 1; bw < b2.length; bw++) {
          var aX = b2[bw];
          for (var aq = 0; aq < aX.length; aq++) {
            if (bH[aq][1] == 0 || aX[aq][1] == 0) {
              aX[aq][1] = 0;
            } else {
              aX[aq][1] = aX[aq][1] - bH[aq][1];
            }
          }
        }
        for (var aq = 0; aq < bH.length; aq++) {
          bH[aq][1] = 0;
        }
      }
      var b4 = z.courseinfo.hillsegments;
      if (
        (mapviewer.settings.timegraphtype == 1 ||
          mapviewer.settings.timegraphtype == 3) &&
        b4
      ) {
        bE = 0;
        for (var U = 0; U < b4.length; U++) {
          bk = bE + b4[U].thelength;
          if (b4[U].thetypeint >= -1) {
            var aK = z.hillcolorsongraph[b4[U].thetypeint + 1];
            by.push({
              rectangle: {
                xmin: bE / 1000,
                xmax: bk / 1000,
                xminOffset: "0px",
                xmaxOffset: "0px",
                yminOffset: "0px",
                ymaxOffset: "0px",
                color: aK,
                showTooltip: false,
              },
            });
          }
          bE = bk;
        }
      }
      var bp = 0;
      var bq = parseInt($("#timegraphgridlines").val());
      if (bq == 1 || bq == 0) {
        bp = bq;
      } else {
        if (bq == 2) {
          bq = 1;
          bp = 0;
        } else {
          bq = 0;
          bp = 1;
        }
      }
      var bj = "insideGrid";
      var S = "ne";
      var bO = 3;
      if (bu.length > 6) {
        bj = "outsideGrid";
        S = "s";
        bO = 6;
      }
      var a7 = $.jqplot(bn, b2.concat(bu), {
        cursor: { show: true, zoom: true, showTooltip: false },
        legend: {
          show: true,
          placement: bj,
          location: S,
          renderer: $.jqplot.EnhancedLegendRenderer,
          rendererOptions: { numberColumns: bO },
          show: true,
        },
        series: bU.concat(an),
        highlighter: {
          show: true,
          sizeAdjust: 7.5,
          bringSeriesToFront: true,
          formatString: highlightstring,
        },
        axes: {
          xaxis: {
            min: 0,
            max: totdist,
            tickOptions: { formatString: "%.1f km", showGridline: bq },
          },
          yaxis: {
            tickOptions: { formatString: yaxisformat, showGridline: bp },
          },
        },
        seriesDefaults: { color: "#ff0000" },
        title: plottitle,
        canvasOverlay: { show: true, objects: by },
      });
      if (bu.length) {
        $("#" + bn + " .jqplot-point-label").css("color", "#000000");
        $("#" + bn + " .jqplot-point-label").css("font-size", "13px");
        $("#" + bn + " .jqplot-point-label").css("font-weight", "bold");
      }
      var bY = $("#graph-" + (bf + 1) + " .jqplot-event-canvas");
      var W = bY.width();
      var ag = bY.height();
      var aQ = parseInt(
        $("#graph-" + (bf + 1) + " .jqplot-event-canvas").css("top")
      );
      var aZ = parseInt(
        $("#graph-" + (bf + 1) + " .jqplot-event-canvas").css("left")
      );
      var bS = document.createElement("canvas");
      bS.style.display = "block";
      bS.style.position = "absolute";
      bS.style.top = aQ;
      bS.style.left = aZ;
      var b9 = parseInt($("#jqtextfront").val());
      bS.style.zIndex = b9;
      bS.style.width = W;
      bS.style.height = ag;
      bS.width = W;
      bS.height = ag;
      $(bS).insertBefore("#graph-" + (bf + 1) + " .jqplot-event-canvas");
      thisgraphcontext = bS.getContext("2d");
      mapviewer.settings.graphs[bf].acanvas = bS;
      mapviewer.settings.graphs[bf].acontext = thisgraphcontext;
      mapviewer.settings.graphs[bf].acontext.font =
        mapviewer.settings.graphannotatetxtsize + "px Arial";
      var bZ = mapviewer.settings.graphs[bf].acontext;
      bZ.fillStyle = "#000000";
      bZ.strokeStyle = "#000000";
      bZ.shadowColor = "#ffffff";
      bZ.shadowOffsetX = 2;
      bZ.shadowOffsetY = 2;
      bZ.shadowBlur = 8;
      var bP = mapviewer.settings.graphs[bf].graphannotate;
      be = 0;
      for (var U = 0; U < bP.length; U++) {
        tobj = bP[U];
        if (tobj.xinfo == "statdiv") {
          be++;
          txtsize = tobj.txtsize;
        }
      }
      if (be) {
        var ae = [0, 0];
        var cb = (txtsize / W) * 6;
        thisdx = (txtsize / W) * 10;
        for (var U = 0; U < 5; U++) {
          ae.push(thisdx);
          thisdx = thisdx + cb;
        }
        var aw = mapviewer.settings.graphs[bf].statinfox;
        var Z = mapviewer.settings.graphs[bf].statinfoy;
        aH = Z - ((be + 0.1) * (txtsize * 1.3)) / ag;
        z.writetxtonjqplot(bf, aw + ae[2], aH, "Totalt", txtsize);
        z.writetxtonjqplot(bf, aw + ae[3], aH, "Opp", txtsize);
        z.writetxtonjqplot(bf, aw + ae[4], aH, "Ned", txtsize);
        z.writetxtonjqplot(bf, aw + ae[5], aH, "Lettparti", txtsize);
        var bs = 0;
        for (var aP = 0; aP < z.courseinfo.hillsegments.length; aP++) {
          if (z.courseinfo.hillsegments[aP].thetypeint == 2) {
            bs = 1;
          }
        }
        if (bs) {
          z.writetxtonjqplot(bf, aw + ae[6], aH, "Sep", txtsize);
        }
      }
      statdivinfos = 0;
      for (var U = 0; U < bP.length; U++) {
        tobj = bP[U];
        if (tobj.type == "text") {
          var aJ = tobj.x;
          var aH = tobj.y;
          var be;
          if (tobj.xinfo == "statdiv") {
            statdivinfos++;
            var aw = mapviewer.settings.graphs[bf].statinfox;
            var Z = mapviewer.settings.graphs[bf].statinfoy;
            aJ = aw;
            aH = Z - ((statdivinfos - 1) * (txtsize * 1.3)) / ag;
            var aU = tobj.txt.split("|");
            for (var aq = 0; aq < aU.length; aq++) {
              if (aU[aq].indexOf(" - ") != -1) {
                bZ.shadowColor = "#008800";
              }
              if (aU[aq].indexOf(" + ") != -1) {
                bZ.shadowColor = "#880000";
              }
              if (z.settings.routecolors[aU[0]] && aq <= 0) {
                bZ.shadowColor = "#" + z.settings.routecolors[aU[0]];
              }
              if (aq == 0) {
                if (aU[0].length > 15) {
                  aU[0] = aU[0].substr(0, 15);
                }
              }
              if (aq != 1) {
                z.writetxtonjqplot(bf, aJ + ae[aq], aH, aU[aq], txtsize);
              } else {
                if (statdivinfos == 1) {
                  z.writetxtonjqplot(
                    bf,
                    aJ + ae[aq],
                    Z - ((be + 1.5) * (txtsize * 1.3)) / ag,
                    "Oppsummering: " +
                      b8 +
                      "differanser i forhold til " +
                      aU[aq],
                    txtsize
                  );
                }
              }
              bZ.shadowColor = "#ffffff";
            }
          } else {
            z.writetxtonjqplot(bf, aJ, aH, tobj.txt, txtsize);
          }
        } else {
          if (tobj.type == "line") {
            z.lineonjqplot(bf, tobj.x, tobj.y, tobj.x2, tobj.y2);
          }
        }
      }
      $("#" + bn).bind("jqplotMouseMove", function (cm, cf, ck, cj, ci) {
        if (!cj) {
          if (z.courseinfo.coursetype != "o") {
            thiscoursecoords = z.coursecoords;
          } else {
            thiscoursecoords = mapviewer.coursecoords_alongline;
          }
          var cg = thiscoursecoords.length;
          var ce = a7._width;
          pointIndex = parseInt((cf.x * cg) / ce);
          if (a7.plugins.cursor._zoom.isZoomed) {
          } else {
            z.visualizeindexonmap(pointIndex);
          }
        }
      });
      $("#" + bn).bind("jqplotDataMouseOver", function (cg, ce, cf, ci) {
        z.showgraphpos(cf);
        z.visualizeindexonmap(cf);
      });
      $(bS).bind("click", function (cz) {
        var cn = cz.offsetX;
        var cl = cz.offsetY;
        var cx = cz.shiftKey;
        var cC = cz.altKey;
        var cm = cz.ctrlKey || cz.metaKey;
        var cu = $("#graph-" + (bf + 1) + " .jqplot-event-canvas");
        var cp = cu.width();
        var cv = cu.height();
        if (!cx && !cm && !cC) {
          var cy = new Object();
          cy.x = cn / cp;
          cy.y = cl / cv;
          cy.txt = $("#addtextval").val();
          if (cy.txt) {
            cy.type = "text";
            mapviewer.settings.graphs[bf].graphannotate.push(cy);
            cy.txtsize = mapviewer.settings.graphannotatetxtsize;
            var cq = mapviewer.writetxtonjqplot(
              bf,
              cy.x,
              cy.y,
              cy.txt,
              txtsize
            );
            cy.obj = cq;
          }
        } else {
          if (cx) {
            var ci = cn / cp;
            var cg = cl / cv;
            var cr = 1e99;
            var cB = -1;
            var cA = mapviewer.settings.graphs[bf].graphannotate;
            for (var ce = 0; ce < cA.length; ce++) {
              thistxtobj = cA[ce];
              au = thistxtobj.x;
              thisy = thistxtobj.y;
              if (thistxtobj.x2) {
                au = (au + thistxtobj.x2) / 2;
                thisy = (thisy + thistxtobj.y2) / 2;
              }
              offset = (au - ci) * (au - ci) + (thisy - cg) * (thisy - cg);
              if (offset < cr) {
                cr = offset;
                cB = ce;
              }
            }
            if (cA.length) {
              thistxtobj = cA[cB];
              if (thistxtobj.type == "text") {
                $("#addtextval").val(thistxtobj.txt);
              } else {
              }
              cA.splice(cB, 1);
              mapviewer.plotgraphs();
            }
          } else {
            if (cm) {
              var cf = z.settings.graphs[bf];
              var ct = cf.prevx;
              var cs = cf.prevy;
              if (ct && cs) {
                var ck = cn / cp;
                var cj = cl / cv;
                var cy = new Object();
                cy.x = ct;
                cy.y = cs;
                cy.x2 = ck;
                cy.y2 = cj;
                cy.type = "line";
                z.lineonjqplot(bf, ct, cs, ck, cj);
                z.settings.graphs[bf].graphannotate.push(cy);
                cf.prevx = null;
                cf.prevy = null;
              } else {
                cf.prevx = cn / cp;
                cf.prevy = cl / cv;
              }
            } else {
              if (cC) {
                var ck = cn / cp;
                var cj = cl / cv;
                z.settings.graphs[bf].statinfox = ck;
                z.settings.graphs[bf].statinfoy = cj;
                z.plotgraphs();
              }
            }
          }
        }
      });
      $("#" + bn).bind("jqplotDataUnhighlight", function (cg, ce, cf, ci) {
        z.visualize_point = null;
        z.request_redraw();
        z.hidegraphpos(cf);
      });
      return a7;
    } else {
      $("#" + bn).html(
        "<center><font size=1 color=#999>No data to plot</font></center>"
      );
      return null;
    }
  };
  this.visualizeindexonmap = function (O) {
    if (z.courseinfo.coursetype != "o") {
      thiscoursecoords = z.coursecoords;
    } else {
      thiscoursecoords = mapviewer.coursecoords_alongline;
    }
    var S = thiscoursecoords[O];
    if (S) {
      var T = S.split(",");
      var R = T[0];
      var U = T[1];
      z.visualize_point = new Object();
      z.visualize_point.x = R;
      z.visualize_point.y = U;
      if (z.courseinfo.coursetype != "o") {
        z.move_mapxy_to_center(R, U);
      }
      if (0) {
        for (var N = 0; N < z.routes.length; N++) {
          var M = z.routes[N];
          if (M.show) {
            if (M.lapdata[0].distindarr) {
              var Q = M.lapdata[0].distindarr[O];
              M.offset = parseInt(Q) - (mapviewer.zerotime - M.zerotime);
            }
          }
        }
      }
      z.request_redraw();
    }
  };
  this.showgraphpos = function (N) {
    for (var M = 0; M < z.settings.graphobjs.length; M++) {
      var O = z.settings.graphobjs[M];
      if (O) {
        co = O.plugins.canvasOverlay;
        if (co.get("posline")) {
          co.get("posline").options.x = z.courseinfo.distarray[N] / 1000;
          co.get("posline").options.show = true;
          co.draw(O);
        }
      }
    }
  };
  this.hidegraphpos = function (N) {
    for (var M = 0; M < z.settings.graphobjs.length; M++) {
      var O = z.settings.graphobjs[M];
      if (O) {
        co = O.plugins.canvasOverlay;
        if (co.get("posline")) {
          co.get("posline").options.x = z.courseinfo.distarray[N] / 1000;
          co.get("posline").options.show = false;
          co.draw(O);
        }
      }
    }
  };
  this.autoname_tags = function (Z) {
    if (!Z) {
      Z = $("#autoname_colors").val();
    }
    var aa;
    if (Z == "SPAS") {
      aa = new Array(
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000",
        "004400",
        "000044",
        "440088",
        "884400",
        "008844",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000",
        "004400",
        "000044",
        "440088",
        "884400",
        "008844",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000"
      );
    } else {
      aa = new Array(
        "ff0000",
        "006600",
        "0000ff",
        "993399",
        "0099FF",
        "008888",
        "000044",
        "440088",
        "884400",
        "008844",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000",
        "004400",
        "000044",
        "440088",
        "884400",
        "008844",
        "880000",
        "008800",
        "000088",
        "880088",
        "888800",
        "008888",
        "880000"
      );
    }
    for (controlnu = 1; controlnu < z.coursecoords.length; controlnu++) {
      var U = z.coursecoords[controlnu - 1];
      var S = U.split(",");
      var Q = S[0];
      var Y = S[1];
      var U = z.coursecoords[controlnu];
      var S = U.split(",");
      var ad = S[0];
      var R = S[1];
      var ab = 0;
      for (var N = 0; N < z.tags.length; N++) {
        var T = z.tags[N];
        if (T.type == "route") {
          var W = T.pointsxy;
          if (W) {
            var U = W[0];
            if (U) {
              var S = U.split(",");
              var O = S[0];
              var M = S[1];
              var U = W[W.length - 1];
              var S = U.split(",");
              var ae = S[0];
              var ac = S[1];
              var X = (O - Q) * (O - Q) + (M - Y) * (M - Y);
              var V = (ae - ad) * (ae - ad) + (ac - R) * (ac - R);
              if (X < 800 && V < 800) {
                T.name = String.fromCharCode(65 + ab);
                T.color = aa[ab];
                ab++;
              }
            }
          }
        }
      }
    }
  };
  this.showtags_control = function (S) {
    if (S < 0) {
      for (var M = 0; M < z.tags.length; M++) {
        var Y = z.tags[M];
        if (Y.type == "route") {
          Y.show = 1;
        }
      }
    } else {
      if (S == 0) {
      } else {
        var X = z.coursecoords[S - 1];
        if (!X) {
        }
        var ac = X.split(",");
        var N = ac[0];
        var aa = ac[1];
        var X = z.coursecoords[S];
        if (!X) {
        } else {
        }
        if (X) {
          var ac = X.split(",");
          var O = ac[0];
          var ab = ac[1];
          for (var M = 0; M < z.tags.length; M++) {
            var Y = z.tags[M];
            if (Y.type == "route") {
              var Z = Y.pointsxy;
              if (Z) {
                if (Z.length > 0) {
                  var X = Z[0];
                  var ac = X.split(",");
                  var R = ac[0];
                  var Q = ac[1];
                  var X = Z[Z.length - 1];
                  var ac = X.split(",");
                  var W = ac[0];
                  var U = ac[1];
                  var V = (R - N) * (R - N) + (Q - aa) * (Q - aa);
                  var T = (W - O) * (W - O) + (U - ab) * (U - ab);
                  if (V < 800 && T < 800) {
                    Y.show = 1;
                  } else {
                    Y.show = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  this.move_mapxy_to_center = function (N, U) {
    var M = this.canvas.canvaselement.width;
    if (z.settings.menu_isvisible) {
      M = M - $("#" + this.menudiv).width();
    }
    var Q = this.canvas.canvaselement.height;
    if (z.canvas.use_rotate) {
      var O = z.canvas.rotate_angle;
      var T = N - this.canvas.canvaselement.width / 2 / z.canvas.zoomfactor;
      var S = U - this.canvas.canvaselement.height / 2 / z.canvas.zoomfactor;
      this.canvas.move_canvasxy_to_origin(T, S);
    } else {
      var R = this.max_whiteborder_when_centering_map;
      var T = N - M / 2 / z.canvas.zoomfactor;
      var S = U - Q / 2 / z.canvas.zoomfactor;
      if (!xc) {
        if (T < -R) {
          T = -R;
        }
        if (S < -R) {
          S = -R;
        }
        if (T > parseInt(this.map.width) + R) {
          T = parseInt(this.map.width) + R;
        }
        if (S > parseInt(this.map.height) + R) {
          S = parseInt(this.map.height) + R;
        }
      }
      this.canvas.move_canvasxy_to_origin(T, S);
    }
  };
  this.showroutes_autoselect_chosen = function (S) {
    if (S) {
      for (var Q = 0; Q < z.routes.length; Q++) {
        z.routes[Q].show = 1;
      }
    }
    z.update_routediv(false);
    var N = z.settings.autoselect_chosen;
    var R = N.split("-");
    var M = R[0];
    var O;
    if (R[1] == "F" || R[1] == "O") {
      O == 0;
    } else {
      O = R[1];
    }
    for (var Q = 0; Q < z.routes.length; Q++) {
      if (Q <= M - 1) {
        z.routes[Q].show = 1;
      } else {
        if (z.routes[Q].fav == 1 && R[1] == "F") {
          z.routes[Q].show = 1;
        } else {
          if (z.routes[Q].totplace <= O) {
            z.routes[Q].show = 1;
          } else {
            z.routes[Q].show = 0;
          }
        }
      }
    }
  };
  this.showroutes = function (M) {
    for (var N = 0; N < z.routes.length; N++) {
      if (N < M) {
        z.routes[N].show = 1;
      } else {
        z.routes[N].show = 0;
      }
    }
    z.update_routediv();
    z.segments = new Array();
    z.numsegments = 0;
    z.request_redraw();
  };
  this.showvariants = function () {
    var R = new Array();
    var M = new Array();
    z.variant_array = new Array();
    for (var N = this.routes.length - 1; N >= 0; N--) {
      this.routes[N].show = 1;
    }
    z.update_segmenttime_from_taillength();
    z.routes.sort(sort_segmenttimelength);
    z.drawroutes();
    z.routes[0].show = 1;
    R.push(0);
    var O = 0;
    var Q = 0;
    z.variant_array[Q] = O;
    M[Q] =
      "<b><a href='javascript:void(0);' onclick='mapviewer.show_variant(" +
      Q +
      ")'>Variant 1:</a></b><br>";
    var W = z.routes[O].segmenttime;
    var S = z.routes[O].segmentlength;
    M[Q] =
      M[Q] +
      z.routes[O].runnername +
      " " +
      tominsec(z.routes[O].taillength) +
      " (" +
      Math.floor(S) +
      " m)<br>";
    for (var N = 1; N < z.routes.length; N++) {
      if (z.routes[N].segmenttime > 1 && z.routes[N].segmenttime < 9999) {
        O = N;
        L1 = z.DrawnLines[O];
        var U = 1;
        var Q = -1;
        for (var T = 0; T < R.length; T++) {
          r2 = R[T];
          L2 = z.DrawnLines[r2];
          same_routes = z.check_if_same_routechoice(
            O,
            r2,
            L1.start,
            L1.end,
            L2.start,
            L2.end
          );
          if (same_routes) {
            Q = T;
            T = R.length + 1;
            U = 0;
          }
        }
        if (U) {
          R.push(O);
          Q = R.length - 1;
          z.variant_array[Q] = O;
          z.routes[O].show = 1;
          M[Q] =
            '<b><a href="javascript:void(0);" onclick="mapviewer.show_variant(' +
            Q +
            ')">Variant ' +
            (Q + 1) +
            '</a>:</b> (<a href="javascript:void(0);" onclick="mapviewer.mod_variant(' +
            Q +
            ',0)">To -> </a>)<br>';
        } else {
          z.variant_array[Q] = z.variant_array[Q] + " " + O;
          z.routes[O].show = 0;
        }
        var W = z.routes[O].segmenttime;
        var S = z.routes[O].segmentlength;
        M[Q] =
          M[Q] +
          z.routes[O].runnername +
          " " +
          tominsec(W) +
          " (" +
          Math.floor(S) +
          " m)<br>";
      } else {
        z.routes[N].show = 0;
      }
    }
    var V = "";
    for (var T = 0; T < R.length; T++) {
      V = V + M[T];
    }
    z.make_routedesc_prependinfo(V);
    z.update_routediv();
    z.segments = new Array();
    z.numsegments = 0;
    z.request_redraw();
  };
  this.write_variantinfo = function () {
    var M = new Array();
    for (var N = 0; N < z.variant_array.length; N++) {
      routes = z.variant_array[N].toString();
      var R = routes.split(" ");
      var Q = N;
      M[Q] =
        '<b><a href="javascript:void(0);" onclick="mapviewer.show_variant(' +
        Q +
        ')">Variant ' +
        (Q + 1) +
        '</a>:</b> (<a href="javascript:void(0);" onclick="mapviewer.mod_variant(' +
        Q +
        ',0)">To -> </a>)<br>';
      for (jj = 0; jj < R.length; jj++) {
        var O = R[jj];
        var U = z.routes[O].segmenttime;
        var S = z.routes[O].segmentlength;
        M[Q] =
          M[Q] +
          z.routes[O].runnername +
          " " +
          tominsec(U) +
          " (" +
          Math.floor(S) +
          " m)<br>";
      }
    }
    var V = "";
    for (var T = 0; T < M.length; T++) {
      V = V + M[T];
    }
    z.make_routedesc_prependinfo(V);
    z.update_routediv();
  };
  this.mod_variant = function (M, Q) {
    if (Q == 0) {
      z.settings.variant_changefrom = M;
      alert("Now click the variant you want to change these routes to");
    } else {
      var O = z.settings.variant_changefrom;
      var N = M;
      if (O != N) {
        z.variant_array[N] = z.variant_array[N] + " " + z.variant_array[O];
        z.variant_array.splice(O, 1);
      }
      z.write_variantinfo();
      z.settings.variant_changefrom = null;
    }
  };
  this.show_variant = function (N) {
    var M;
    if (N >= 0) {
      if (z.settings.variant_changefrom != null) {
        z.mod_variant(N);
      }
      routes = z.variant_array[N].toString();
      M = routes.split(" ");
    } else {
      M = new Array();
      for (var O = 0; O < z.variant_array.length; O++) {
        routes = z.variant_array[O].toString();
        tmpshowarray = routes.split(" ");
        M[M.length] = tmpshowarray[0];
      }
    }
    for (var O = this.routes.length - 1; O >= 0; O--) {
      this.routes[O].show = 0;
    }
    for (var O = 0; O < M.length; O++) {
      this.routes[M[O]].show = 1;
    }
    z.update_routediv();
    z.request_redraw();
  };
  this.showroute = function (R) {
    var Q = R.split("-");
    var O = Q[1];
    var M = -1;
    if (z.routes[O].show == 1) {
      z.routes[O].show = 0;
    } else {
      z.routes[O].show = 1;
      M = O;
    }
    if (z.settings.definecourse) {
      for (var N = 0; N < z.routes.length; N++) {
        if (N == M) {
          z.routes[N].show = 1;
        } else {
          z.routes[N].show = 0;
        }
      }
      if ($("#course-slider").length > 0) {
        $("#course-slider").slider(
          "values",
          $("#course-slider").slider("values")
        );
      }
    }
    if (z.settings.calibrationmode) {
      for (var N = 0; N < z.routes.length; N++) {
        z.routes[N].show = 0;
      }
      z.routes[0].show = 1;
      alert("Calibration only works with first route!");
    }
    z.update_routediv();
    z.request_redraw();
  };
  this.addsplits_opendialog = function (O) {
    var N = O.split("-");
    var M = N[1];
    z.open_dialog("Add splits manually", M, 0);
    $("input#changeinfo_color").simpleColorPicker();
  };
  this.changenamestart_opendialog = function (O) {
    var N = O.split("-");
    var M = N[1];
    z.open_dialog("Change name/info", M, 0);
    $("input#changeinfo_color").simpleColorPicker();
  };
  m.onmousemove = function (ax, aw, ab, Z, ae) {
    if (!z.canvas.rotate_angle) {
      ba = ab / z.canvas.zoomfactor;
      ddy = Z / z.canvas.zoomfactor;
    } else {
      ba =
        (ab / z.canvas.zoomfactor) * Math.cos(z.canvas.rotate_angle) +
        (Z / z.canvas.zoomfactor) * Math.sin(z.canvas.rotate_angle);
      ddy =
        -((ab / z.canvas.zoomfactor) * Math.sin(z.canvas.rotate_angle)) +
        (Z / z.canvas.zoomfactor) * Math.cos(z.canvas.rotate_angle);
    }
    if (z.settings.calibrationmode) {
      if (ae == 1) {
        var N = mapviewer.calpoint_onmousedown.calpoint;
        var aO = mapviewer.calpoint_onmousedown.x;
        var aN = mapviewer.calpoint_onmousedown.y;
        var aW = mapviewer.map.calstring;
        var a4 = aW.split("|");
        var aB = parseFloat(a4[0]);
        var aR = parseFloat(a4[1]);
        var aA = parseFloat(a4[4]);
        var aQ = parseFloat(a4[5]);
        var az = parseFloat(a4[8]);
        var aP = parseFloat(a4[9]);
        var an = parseFloat(a4[2]);
        var X = parseFloat(a4[3]);
        var am = parseFloat(a4[6]);
        var V = parseFloat(a4[7]);
        var ak = parseFloat(a4[10]);
        var U = parseFloat(a4[11]);
        var aV = parseInt(Math.floor(aO) + ba);
        var aU = parseInt(Math.floor(aN) + ddy);
        if (N == 0) {
          an = aV;
          X = aU;
        } else {
          if (N == 1) {
            am = aV;
            V = aU;
          } else {
            if (N == 2) {
              ak = aV;
              U = aU;
            }
          }
        }
        aW =
          aB +
          "|" +
          aR +
          "|" +
          an +
          "|" +
          X +
          "|" +
          aA +
          "|" +
          aQ +
          "|" +
          am +
          "|" +
          V +
          "|" +
          az +
          "|" +
          aP +
          "|" +
          ak +
          "|" +
          U;
        z.map.calstring = aW;
        z.map.initcalibration(aW);
        if (z.map.id == "localimage") {
          var ap = z.map.name;
          localStorage_setItem("calstring_" + ap, aW);
        }
      }
    } else {
      if (
        z.settings.modifyroutes ||
        (z.settings.routeedit_mode == 2 &&
          z.settings.coursedefinition_mode == 3)
      ) {
        var aD = 0;
        var aK = 0;
        for (var R = 0; R < z.routes.length; R++) {
          if (z.routes[R].show) {
            aF = z.routes[R];
            R = z.routes.length + 1;
          }
        }
        if (
          z.settings.routeedit_mode == 2 &&
          z.settings.coursedefinition_mode == 3
        ) {
          aK = parseInt(aF.currenttime(z.playtime));
          aD = parseInt(aK - aF.taillength);
          aF.modifyroute_stablepoints = new Array();
          var ac = new Object();
          ac.index = parseInt(aD);
          aF.modifyroute_stablepoints.push(ac);
          var ac = new Object();
          ac.index = parseInt(aK);
          aF.modifyroute_stablepoints.push(ac);
          aF.modifyroute_stablepoints.sort(sort_index);
        } else {
          var a6 = z.settings.modifyroute_mousedown.index;
          if (aF.modifyroute_stablepoints) {
            for (var at = 0; at < aF.modifyroute_stablepoints.length; at++) {
              if (aF.modifyroute_stablepoints[at].index >= a6) {
                if (at == 0) {
                  aD = 0;
                  aK = aF.modifyroute_stablepoints[at].index;
                } else {
                  aD = aF.modifyroute_stablepoints[at - 1].index;
                  aK = aF.modifyroute_stablepoints[at].index;
                }
                at = 1e99;
              }
            }
          }
        }
        if (aK > 0) {
          var a9 = (aK - aD) / 2;
          var aM = (aK + aD) / 2;
          for (var at = aD; at <= aK; at++) {
            Pxy = z.map.toxy(
              aF.latarray_mousedown[at],
              aF.lngarray_mousedown[at]
            );
            var ai = 0.5 * (1 - Math.abs(at - aM) / a9);
            thisdx = ba * ai * 2;
            thisdy = ddy * ai * 2;
            aI = z.map.tolatlng(Pxy.x + thisdx, Pxy.y + thisdy);
            aF.latarray[at] = aI.lat;
            aF.lngarray[at] = aI.lng;
          }
        }
      } else {
        if (z.settings.mode == z.settings.modes.DrawCourseMode && ae == 1) {
          if (!z.control_onmousedown) {
            var aJ = z.map.tolatlng(ax, aw);
            z.control_onmousedown = z.findclosestcontrol(aJ.lat, aJ.lng);
          }
          var aE = mapviewer.control_onmousedown.controlnu;
          var aO = mapviewer.control_onmousedown.x;
          var aN = mapviewer.control_onmousedown.y;
          tmp = z.coursecoords[aE].split(",");
          z.coursecoords[aE] =
            Math.floor(aO) + ba + "," + (Math.floor(aN) + ddy);
          if (tmp[2]) {
            z.coursecoords[aE] = z.coursecoords[aE] + "," + tmp[2];
          }
          if (z.coursecontrolcoords[aE]) {
            z.coursecontrolcoords[aE] = null;
          }
          z.update_courselength();
        } else {
          if (z.settings.mode == z.settings.modes.DrawCourseMode && ae == 2) {
            if (!z.control_onmousedown) {
              var aJ = z.map.tolatlng(ax, aw);
              z.control_onmousedown = z.findclosestcontrolnumber(
                aJ.lat,
                aJ.lng
              );
            }
            var aE = mapviewer.control_onmousedown.controlnu;
            var aO = mapviewer.control_onmousedown.x;
            var aN = mapviewer.control_onmousedown.y;
            tmp = z.coursecontrolcoords[aE].split(",");
            z.coursecontrolcoords[aE] =
              Math.floor(aO) + ba + "," + (Math.floor(aN) + ddy);
            if (tmp[2]) {
              z.coursecontrolcoords[aE] =
                z.coursecontrolcoords[aE] + "," + tmp[2];
            }
          } else {
            if (z.settings.tagmode == 3 && z.currenttag && ae == 1) {
              var aO = mapviewer.tagpoint_onmousedown.x;
              var aN = mapviewer.tagpoint_onmousedown.y;
              var ar = mapviewer.tagpoint_onmousedown.pnu;
              if (ar != null) {
                tmp = z.currenttag.pointsxy[ar].split(",");
                tmp[0] = Math.floor(aO) + ba;
                tmp[1] = Math.floor(aN) + ddy;
                z.currenttag.pointsxy[ar] = tmp.join(",");
                var aJ = z.map.tolatlng(tmp[0], tmp[1]);
                z.currenttag.points[ar] = aJ.lat + "," + aJ.lng;
                var ao = 0;
                var aJ = z.currenttag.points[0];
                var aX = aJ.split(",");
                var aa = aX[0];
                var W = aX[1];
                for (var R = 1; R < z.currenttag.points.length; R++) {
                  var aJ = z.currenttag.points[R];
                  var aX = aJ.split(",");
                  var aj = aX[0];
                  var ad = aX[1];
                  d = calcdistance(aa, W, aj, ad);
                  ao = ao + d;
                  aa = aj;
                  W = ad;
                }
                z.currenttag.length = ao;
                z.request_redraw();
              }
            } else {
              if (
                z.settings.mode == z.settings.modes.AnalysisMode &&
                z.settings.definecourse == 1 &&
                z.settings.coursedefinition_mode >= 1 &&
                z.settings.coursedefinition_mode <= 2
              ) {
                var aO = mapviewer.control_onmousedown.x;
                var aN = mapviewer.control_onmousedown.y;
                if (ae == 1) {
                  var aE = mapviewer.control_onmousedown.controlnu;
                  if (aE != null) {
                    tmp = z.coursecoords[aE].split(",");
                    tmp[0] = Math.floor(aO) + ba;
                    tmp[1] = Math.floor(aN) + ddy;
                    z.coursecoords[aE] = tmp.join(",");
                    if (xc == 1) {
                      var aT = z.map.tolatlng(tmp[0], tmp[1]);
                      var al = 0;
                      if (aE > 0) {
                        al = aE - 1;
                      }
                      if (aE > z.coursecoords.length - 1) {
                        al = z.coursecoords.length - 1;
                      }
                      var aT = z.map.tolatlng(tmp[0], tmp[1]);
                      tmp = z.coursecoords[al].split(",");
                      var aS = z.map.tolatlng(tmp[0], tmp[1]);
                      var O = calcdistance(aT.lat, aT.lng, aS.lat, aS.lng);
                      var a8 = 150;
                      if (O > a8) {
                        z.coursecoords.splice(aE, 1);
                        z.findhills_eleprofile();
                        z.snaproutestocourse();
                        z.control_onmousedown.controlnu = null;
                        z.request_redraw();
                      }
                    }
                  }
                  $("#courserefit").show();
                } else {
                  if (ae == 2) {
                    var aJ = z.map.tolatlng(aO + ba, aN + ddy);
                    var aF = z.routes[z.settings.coursefit_rnr];
                    if (aF) {
                      if (aF.lapdata) {
                        var M = aF.lapdata[z.settings.coursefit_lnr];
                        if (M) {
                          var aL = M.times;
                          var ah = 1e99;
                          var aC = -1;
                          for (
                            var R = Math.floor(aL[0]);
                            R < Math.ceil(aL[aL.length - 1]);
                            R++
                          ) {
                            var O = calcdistance(
                              aF.latarray[R],
                              aF.lngarray[R],
                              aJ.lat,
                              aJ.lng
                            );
                            if (O < ah) {
                              aC = R;
                              ah = O;
                            }
                          }
                          var aj = aJ.lat;
                          var ad = aJ.lng;
                          l_from = aC - 1;
                          l_to = aC + 1;
                          l_steps = 10;
                          l_dt = 1 / l_steps;
                          var av = aF.latarray;
                          var Q = aF.lngarray;
                          mindist_l = 1e99;
                          minind_l = aC;
                          prevlat_l = av[l_from - 1];
                          prevlng_l = Q[l_from - 1];
                          for (var a7 = l_from; a7 <= l_to; a7++) {
                            lat_l = av[a7];
                            lng_l = Q[a7];
                            var a1 = lat_l - prevlat_l;
                            var aZ = lng_l - prevlng_l;
                            for (var T = 0; T < l_steps; T++) {
                              var ay = prevlat_l + (a1 * T) / l_steps;
                              var S = prevlng_l + (aZ * T) / l_steps;
                              var aY = a7 + T * l_dt;
                              var au = calcdistance(ay, S, aj, ad);
                              if (au < mindist_l) {
                                mindist_l = au;
                                minind_l = aY;
                              }
                            }
                            prevlat_l = lat_l;
                            prevlng_l = lng_l;
                          }
                          aF.lapdata[z.settings.coursefit_lnr].times[
                            z.settings.coursefit_modpoint
                          ] = minind_l;
                          z.request_redraw();
                        }
                      }
                    }
                  }
                }
              } else {
                if (
                  z.settings.analyzecourse &&
                  ae < 3 &&
                  !mapviewer.waitfordrag &&
                  mapviewer.settings.mode != mapviewer.settings.modes.ReplayMode
                ) {
                  controlnu = null;
                  if (z.control_onmousedown) {
                    controlnu = z.control_onmousedown.controlnu;
                  }
                  var af = null;
                  for (var R = z.routes.length - 1; R >= 0; R--) {
                    if (z.routes[R].highlight) {
                      af = R;
                    }
                  }
                  if (af != null && controlnu != null) {
                    if (!z.control_onmousedown.orgsplit) {
                      z.control_onmousedown.orgsplit =
                        z.routes[af].splits[controlnu].index;
                    }
                    var ba = ab / z.canvas.zoomfactor;
                    z.routes[af].splits[controlnu].index = parseInt(
                      z.control_onmousedown.orgsplit + ba
                    );
                    z.routes[af].manualsplits = 1;
                  } else {
                    if (af != null) {
                      if (!z.initvalue_mousemove) {
                        z.initvalue_mousemove = z.routes[af].splits[0].index;
                      }
                      var ba = ab / z.canvas.zoomfactor;
                      var ag =
                        z.routes[af].splits[0].index - z.initvalue_mousemove;
                      for (var R = 0; R < z.routes[af].splits.length; R++) {
                        z.routes[af].splits[R].index = parseInt(
                          z.routes[af].splits[R].index + (ba - ag)
                        );
                      }
                      z.routes[af].manualsplits = 1;
                    }
                  }
                } else {
                  if (ae == 1) {
                    var a2 = z.marker_onmousedown;
                    if (a2) {
                      if (z.settings.mode == z.settings.modes.AnalysisMode) {
                        if (a2.modifyend == "end") {
                          z.routes[a2.markernu].taillength = a2.taillength + ab;
                          z.routes[a2.markernu].offset = a2.offset + ab;
                        } else {
                          z.routes[a2.markernu].taillength = a2.taillength + ab;
                        }
                        if (z.routes[a2.markernu].taillength < 1) {
                          z.routes[a2.markernu].taillength = -1;
                        }
                        if (
                          z.routes[a2.markernu].taillength >
                          z.routes[a2.markernu].currenttime(z.playtime)
                        ) {
                          z.routes[a2.markernu].taillength = z.routes[
                            a2.markernu
                          ].currenttime(z.playtime);
                        }
                      } else {
                        z.routes[a2.markernu].offset = a2.offset + ab;
                        if (z.IsLive) {
                          if (z.routes[a2.markernu].offset > 0) {
                            z.routes[a2.markernu].offset = 0;
                          }
                        }
                      }
                      z.highlight_route(a2.markernu);
                      var R = a2.markernu;
                      var aI = z.routes[R].poslatlng(z.playtime);
                      var aJ = z.map.toxy(aI.lat, aI.lng);
                    }
                  } else {
                    if (ae == 2) {
                      if (!z.IsLive) {
                        z.playtime = z.playtime_onmousedown + ab;
                        z.reset_replaystarttime();
                      }
                    } else {
                      if (ae >= 3) {
                        if (z.canvas.mouse_rotate) {
                          sgn = (ab + Z > 0) | -(ab + Z < 0);
                          var a5 =
                            sgn * Math.sqrt(ab * ab + Z * Z) -
                            z.settings.rotateoffset;
                          z.settings.rotateoffset =
                            sgn * Math.sqrt(ab * ab + Z * Z);
                          z.canvas.context.rotate(a5 / 150);
                          z.move_mapxy_to_center(
                            z.settings.rotate_centerx,
                            z.settings.rotate_centery
                          );
                        } else {
                          if (z.settings.tagmode > 0) {
                            if (
                              z.settings.movetagnum == null ||
                              z.settings.movetagnum == undefined
                            ) {
                              var aq = 1e99;
                              closestkk = -1;
                              for (var R = 0; R < z.tags.length; R++) {
                                if (z.tags[R].show) {
                                  Y = z.tags[R];
                                  var a0 = Y.pointsxy;
                                  if (a0.length > 0) {
                                    var aJ = a0[Math.floor(a0.length / 2)];
                                    var a3 = aJ.split(",");
                                    var aH = a3[0];
                                    var aG = a3[1];
                                    thisdis =
                                      (z.settings.rotate_x0 -
                                        parseInt(aH) -
                                        Y.offsettxt_x) *
                                        (z.settings.rotate_x0 -
                                          parseInt(aH) -
                                          Y.offsettxt_x) +
                                      (z.settings.rotate_y0 -
                                        parseInt(aG) -
                                        Y.offsettxt_y) *
                                        (z.settings.rotate_y0 -
                                          parseInt(aG) -
                                          Y.offsettxt_y);
                                    if (thisdis < aq) {
                                      aq = thisdis;
                                      closestkk = R;
                                    }
                                  }
                                }
                              }
                              z.settings.movetagnum = closestkk;
                              z.tags[z.settings.movetagnum].offsettxt_basex =
                                z.tags[z.settings.movetagnum].offsettxt_x;
                              z.tags[z.settings.movetagnum].offsettxt_basey =
                                z.tags[z.settings.movetagnum].offsettxt_y;
                            } else {
                              var Y = z.tags[z.settings.movetagnum];
                              if (ae == 3) {
                                Y.offsettxt_x = Y.offsettxt_basex + ba;
                                Y.offsettxt_y = Y.offsettxt_basey + ddy;
                              } else {
                                if (!Y.angle) {
                                  Y.angle = 0;
                                }
                                if (ba > 0) {
                                  Y.angle = Y.angle + 0.05;
                                } else {
                                  Y.angle = Y.angle - 0.05;
                                }
                              }
                            }
                          } else {
                            if (
                              z.settings.legendtype ==
                                z.settings.modes.SingleLegend ||
                              z.settings.legendtype ==
                                z.settings.modes.SingleLegend2 ||
                              z.settings.legendtype ==
                                z.settings.modes.SingleLegend3
                            ) {
                              if (z.settings.legendroutenum < 0) {
                                var aq = 1e99;
                                closestkk = -1;
                                for (var R = 0; R < z.routes.length; R++) {
                                  if (z.routes[R].show) {
                                    aF = z.routes[R];
                                    thisdis =
                                      (z.settings.rotate_x0 - aF.legendpos_x) *
                                        (z.settings.rotate_x0 -
                                          aF.legendpos_x) +
                                      (z.settings.rotate_y0 - aF.legendpos_y) *
                                        (z.settings.rotate_y0 - aF.legendpos_y);
                                    if (thisdis < aq) {
                                      aq = thisdis;
                                      closestkk = R;
                                    }
                                  }
                                }
                                z.settings.legendroutenum = closestkk;
                              }
                              if (ae == 3) {
                                if (z.settings.legendroutenum >= 0) {
                                  z.routes[
                                    z.settings.legendroutenum
                                  ].legendoffset_x =
                                    z.routes[z.settings.legendroutenum]
                                      .legendoffset_basex + ba;
                                  z.routes[
                                    z.settings.legendroutenum
                                  ].legendoffset_y =
                                    z.routes[z.settings.legendroutenum]
                                      .legendoffset_basey + ddy;
                                }
                              } else {
                                if (ae == 4) {
                                  if (
                                    !z.routes[z.settings.legendroutenum].angle
                                  ) {
                                    z.routes[
                                      z.settings.legendroutenum
                                    ].angle = 0;
                                  }
                                  if (ba > 0) {
                                    z.routes[
                                      z.settings.legendroutenum
                                    ].angle += 0.05;
                                  } else {
                                    z.routes[z.settings.legendroutenum].angle +=
                                      -0.05;
                                  }
                                } else {
                                  if (ae == 5) {
                                    if (
                                      !z.routes[z.settings.legendroutenum]
                                        .middleval &&
                                      z.routes[z.settings.legendroutenum]
                                        .middleval != 0
                                    ) {
                                      z.routes[
                                        z.settings.legendroutenum
                                      ].middleval = 0.5;
                                    }
                                    if (ba > 0) {
                                      z.routes[
                                        z.settings.legendroutenum
                                      ].middleval += 0.01;
                                    } else {
                                      z.routes[
                                        z.settings.legendroutenum
                                      ].middleval += -0.01;
                                    }
                                    if (
                                      z.routes[z.settings.legendroutenum]
                                        .middleval > 1
                                    ) {
                                      z.routes[
                                        z.settings.legendroutenum
                                      ].middleval = 0;
                                    }
                                    if (
                                      z.routes[z.settings.legendroutenum]
                                        .middleval < 0
                                    ) {
                                      z.routes[
                                        z.settings.legendroutenum
                                      ].middleval = 1;
                                    }
                                  }
                                }
                              }
                            } else {
                              z.settings.legendoffset_x =
                                z.settings.legendoffset_basex + ba;
                              z.settings.legendoffset_y =
                                z.settings.legendoffset_basey + ddy;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!ae) {
    }
  };
  this.highlight_route = function (M) {
    for (var N = 0; N < z.routes.length; N++) {
      z.routes[N].highlight = 0;
    }
    if (M >= 0) {
      z.routes[M].highlight = 1;
    }
  };
  this.recalc_legtimes = function () {
    if (z.settings.calc_inout_times) {
      for (var M = 0; M < z.routes.length; M++) {
        if (z.routes[M].Pointinfo_from && z.routes[M].Pointinfo_to) {
          if (
            z.routes[M].Pointinfo_from.chosen >= 0 &&
            z.routes[M].Pointinfo_to.chosen >= 0
          ) {
            var O =
              z.routes[M].Pointinfo_from.splits[
                z.routes[M].Pointinfo_from.chosen
              ].indexslowest;
            var N =
              z.routes[M].Pointinfo_to.splits[z.routes[M].Pointinfo_to.chosen]
                .indexslowest;
            if (z.routes[M].segmenttime != N - O) {
            }
            z.routes[M].segmenttime = N - O;
            z.routes[M].taillength = N - O;
          }
        }
      }
    }
    z.update_routediv(true);
    z.request_redraw();
  };
  this.move_all_runners_to = function (Y, W, O) {
    z.settings.lastclick_x = z.settings.thisclick_x;
    z.settings.lastclick_y = z.settings.thisclick_y;
    z.settings.thisclick_x = Y;
    z.settings.thisclick_y = W;
    var T = z.map.tolatlng(Y, W);
    thislat = T.lat;
    thislng = T.lng;
    minoffset = 1e99;
    for (var N = 0; N < z.routes.length; N++) {
      var U = z.routes[N];
      var S = U.findclosestpoint(thislat, thislng, "completeroute", -1);
      if (S.distance > z.min_moveto_distance) {
        U.offset = -1e99;
        U.Pointinfo_to = null;
      } else {
        if (O == "searchnextsplit") {
          U.Pointinfo_from = U.Pointinfo_to;
        }
        U.Pointinfo_to = S;
        if (U.Pointinfo_from && U.Pointinfo_to) {
          if (U.Pointinfo_from.splits && U.Pointinfo_to.splits) {
            U = z.routes[N];
            var aa = 1e99;
            var M = -1;
            var V = -1;
            for (var Z = 0; Z < U.Pointinfo_from.splits.length; Z++) {
              for (var R = 0; R < U.Pointinfo_to.splits.length; R++) {
                var Q =
                  U.Pointinfo_to.splits[R].index -
                  U.Pointinfo_from.splits[Z].index;
                if (Q > 0 && Q < aa) {
                  aa = Q;
                  M = Z;
                  V = R;
                }
              }
            }
            U.Pointinfo_from.chosen = M;
            U.Pointinfo_to.chosen = V;
            if (V >= 0) {
              X = z.map.toxy(
                U.Pointinfo_to.splits[V].P.lat,
                U.Pointinfo_to.splits[V].P.lng
              );
              U.offset =
                U.Pointinfo_to.splits[V].index - (z.zerotime - U.zerotime);
            } else {
              var X = z.map.toxy(S.P.lat, S.P.lng);
              U.offset = S.index - (z.zerotime - U.zerotime);
            }
            if (U.offset < minoffset) {
              minoffset = U.offset;
            }
          } else {
            var X = z.map.toxy(S.P.lat, S.P.lng);
            U.offset = S.index - (z.zerotime - U.zerotime);
            if (U.offset < minoffset) {
              minoffset = U.offset;
            }
          }
        } else {
          var X = z.map.toxy(S.P.lat, S.P.lng);
          U.offset = S.index - (z.zerotime - U.zerotime);
          if (U.offset < minoffset) {
            minoffset = U.offset;
          }
        }
      }
    }
    if (minoffset < 1e99) {
      for (var N = 0; N < z.routes.length; N++) {
        z.routes[N].offset = z.routes[N].offset - minoffset;
      }
      z.playtime = z.zerotime + minoffset;
      z.reset_replaystarttime();
    }
  };
  this.currenttime = function (M) {
    return M - z.zerotime + z.offset;
  };
  this.draw_routechoices_to = function (N, R) {
    var M = new Array();
    var Q = new Array();
    for (var O = 0; O < z.routes.length; O++) {
      M[O] = z.routes[O].currenttime(z.playtime);
    }
    this.move_all_runners_to(N, R, "searchnextsplit");
    if (z.settings.previousmode == z.settings.mode) {
      for (var O = 0; O < z.routes.length; O++) {
        if (z.routes[O].Pointinfo_from) {
          if (z.routes[O].Pointinfo_from.chosen >= 0) {
            M[O] =
              z.routes[O].Pointinfo_from.splits[
                z.routes[O].Pointinfo_from.chosen
              ].index;
          }
        }
        if (M[O] < 1e-10) {
          Q[O] = 0;
          z.routes[O].segmenttime = -1;
          z.routes[O].segmentlength = -1;
          z.routes[O].taillength = -1;
        } else {
          Q[O] = z.routes[O].currenttime(z.playtime) - M[O];
          z.routes[O].taillength = Q[O];
          z.routes[O].show_prev = z.routes[O].show;
          z.routes[O].segmenttime = Q[O];
          z.routes[O].segmentlength = z.routes[O].calc_length(
            M[O],
            z.routes[O].currenttime(z.playtime)
          );
        }
        if (z.routes[O].segmenttime == -1 || isNaN(z.routes[O].segmentlength)) {
          z.routes[O].segmentlength = -1;
        }
      }
    } else {
      for (var O = 0; O < z.routes.length; O++) {
        z.routes[O].taillength = -1;
      }
    }
    if (!z.settings.showautoselect) {
      for (var O = 0; O < z.routes.length; O++) {
        if (!z.routes[O].show_prev) {
          z.routes[O].segmenttime = -1;
          z.routes[O].segmentlength = -1;
        }
      }
    } else {
      z.showroutes_autoselect_chosen(0);
    }
    if (
      z.center_map_on_runner &&
      z.settings.mode == z.settings.modes.AnalysisMode &&
      z.settings.autoanalysis == 0
    ) {
      z.rotatesplit();
    }
  };
  z.straightroute_part = function () {
    for (var N = 0; N < z.routes.length; N++) {
      var M = z.routes[N];
      if (M.show) {
        M.straightroute_shown(1);
      }
    }
    z.request_redraw();
  };
  z.trimroute = function () {
    for (var N = 0; N < z.routes.length; N++) {
      var M = z.routes[N];
      if (M.show) {
        M.trim_shown(1);
      }
    }
    z.request_redraw();
  };
  z.routeedit_changemode = function () {
    var N = $("#routeedit_select").val();
    z.settings.routeedit_mode = N;
    for (var M = 1; M <= 10; M++) {
      if ($("#routeedit_select_part" + M)) {
        $("#routeedit_select_part" + M).hide();
      }
    }
    $("#routeedit_select_part" + N).css("display", "inline");
  };
  z.drawroutechoice_leg = function (T, Q) {
    if (T < 1) {
      z.lastcontrol = T;
      minoffset = 1e99;
      for (var S = 0; S < z.routes.length; S++) {
        var O = z.routes[S];
        var U = O.splits[T];
        if (U) {
          var N = U.index;
          var M = mapviewer.settings.taillength;
          O.offset = U.index - (z.zerotime - O.zerotime);
          O.taillength = mapviewer.settings.taillength;
          if (O.offset < minoffset) {
            minoffset = O.offset;
          }
        }
      }
      if (minoffset < 1e99) {
        for (var S = 0; S < z.routes.length; S++) {
          z.routes[S].offset = z.routes[S].offset - minoffset;
        }
        z.playtime = z.zerotime + minoffset;
        z.reset_replaystarttime();
      }
    } else {
      z.lastcontrol = T;
      minoffset = 1e99;
      var O = null;
      for (var S = 0; S < z.routes.length; S++) {
        var O = z.routes[S];
        var U = O.splits[T];
        var R = O.splits[T - 1];
        if (U && R) {
          var N = U.index;
          var M = N - R.index;
          O.offset = U.index - (z.zerotime - O.zerotime);
          if (Q) {
            O.taillength = mapviewer.settings.taillength;
          } else {
            if (M >= 9999) {
              O.segmenttime = -1;
              O.segmentlength = -1;
              O.segmentpace = 0;
              O.taillength = -1;
            } else {
              O.taillength = M;
              O.segmenttime = M;
              O.segmentlength = O.calc_length(R.index, U.index);
            }
          }
          if (O.offset < minoffset) {
            minoffset = O.offset;
          }
        } else {
          O.segmenttime = -1;
          O.segmentlength = -1;
          O.segmentpace = 0;
          O.taillength = -1;
        }
        if (O.segmenttime == -1 || isNaN(O.segmentlength)) {
          O.segmentlength = -1;
        }
      }
      if (minoffset < 1e99) {
        for (var S = 0; S < z.routes.length; S++) {
          z.routes[S].offset = z.routes[S].offset - minoffset;
        }
        z.playtime = z.zerotime + minoffset;
        z.reset_replaystarttime();
      }
      if (z.settings.variants_showmode == 1) {
        for (var S = 0; S < z.routes.length; S++) {
          if (!z.routes[S].variants) {
            z.routes[S].variants = new Array();
          }
          if (z.routes[S].variants[T] >= 0) {
            z.routes[S].show = 0;
          } else {
            z.routes[S].show = 1;
          }
        }
      } else {
        if (z.settings.showautoselect) {
          z.showroutes_autoselect_chosen(0);
        }
      }
      if (z.settings.colormode == z.settings.modes.colorbysplit) {
        z.recolorbysplit();
      } else {
        if (z.settings.colormode == z.settings.modes.colorbylength) {
          z.recolorbylength();
        }
      }
    }
    if (!Q) {
      z.showtags_control(T);
    } else {
      z.showtags_control(T + 1);
    }
  };
  m.onmouseclick = function (aK, aH, M) {
    if (z.waitforclick == 1) {
      z.waitforclickfunction(aK, aH, M);
      return;
    }
    mapviewer.settings.replayleg = 0;
    if (z.is_save_animation) {
      z.stop_save_animation();
    }
    z.make_routedesc_prependinfo("");
    if (M == 4 && (z.settings.runningwild || z.settings.tagmode == 3)) {
      M = 0;
    } else {
      if (M == 4) {
        M = -1;
      }
    }
    var aD = 1;
    if (M == -1) {
      aD = 0;
    } else {
      if (z.IsLive) {
        aD = 0;
      } else {
        if (z.settings.runningwild) {
          aD = 0;
          if (!z.settings.orunningwild.started) {
            z.settings.orunningwild.autorotate = 1;
            if (globrunningwild) {
              if (!globrunningwild.autorotate) {
                z.settings.orunningwild.autorotate = 0;
              }
            }
            z.settings.orunningwild.linestr = "";
            var aM = new Date().getTime();
            z.settings.orunningwild.previousdraw = aM;
            z.settings.orunningwild.previousline = aM;
            z.settings.orunningwild.prevdistpoint = 1e99;
            z.settings.orunningwild.angle = null;
            z.settings.orunningwild.finished = 0;
            $("#" + z.canvasid).css("cursor", "crosshair");
            if (isnarrowscreen) {
            } else {
              $("#" + z.infodiv).html(
                '<b>RunningWild! Draw your route - the faster the better!</b> <button onclick="mapviewer.runningwild_finished()">Click here when finished</button>'
              );
            }
            $("#" + z.infodiv).css("background", "#f00");
            $("#" + z.menudiv).css("z-index", -1);
            $("#" + z.menudiv).css("width", 1);
            z.settings.menu_isvisible = 0;
            if (z.routes) {
              for (var aQ = 0; aQ < z.routes.length; aQ++) {
                z.routes[aQ].show = 0;
              }
            }
            z.request_redraw();
            z.settings.orunningwild.overtime = 0;
            z.settings.orunningwild.starttime = aM;
            if (!z.settings.autosplits_calculated && z.coursecoords) {
              z.calculate_autosplits();
            }
            var S = z.runningwild_findstart();
            var ah = S.startlat;
            var W = S.startlng;
            if (!ah || !W) {
              z.open_dialog(
                "Error",
                "Looks like this RunningWild does not have a course, an ideal route or a route - so it does not work. The course creator probably made an error....<p><a href='http://3drerun.worldofo.com'>Go to 3DRerun main page</a>",
                0
              );
              return;
            }
            var S = z.map.toxy(ah, W);
            var aV = S.x;
            var aU = S.y;
            z.settings.orunningwild.x = aV;
            z.settings.orunningwild.y = aU;
            z.settings.orunningwild.futurepoints = new Array();
            z.settings.orunningwild.allpoints = new Array();
            z.settings.orunningwild.allpoints.push(aV + "," + aU);
            z.settings.orunningwild.started = 1;
            if (z.coursecoords) {
              if (z.coursecoords.length > 1) {
                z.settings.orunningwild.currentcontrol = 1;
                if (z.settings.orunningwild.autorotate) {
                  z.centerleg(0, 0.3);
                } else {
                  z.move_mapxy_to_center(aV, aU);
                }
              }
            } else {
              z.move_mapxy_to_center(aV, aU);
            }
          } else {
            if (z.settings.orunningwild.finished) {
              aD = 1;
            } else {
              if (
                z.settings.orunningwild.futurepoints.length <
                z.settings.orunningwild.maxfuturepoints
              ) {
                z.settings.orunningwild.futurepoints.push(aK + "," + aH);
                z.settings.orunningwild.allpoints.push(aK + "," + aH);
                if (
                  z.settings.orunningwild.futurepoints.length ==
                  z.settings.orunningwild.maxfuturepoints
                ) {
                  $("#" + z.canvasid).css("cursor", "progress");
                }
                if (z.settings.orunningwild.futurepoints.length == 1) {
                  $("#" + z.canvasid).css("cursor", "crosshair");
                }
                z.request_redraw();
              }
            }
          }
        }
      }
    }
    if (aD) {
      for (var aQ = 0; aQ < z.routes.length; aQ++) {
        z.routes[aQ].legendoffset_x = 0;
        z.routes[aQ].legendoffset_y = 0;
        z.routes[aQ].legendoffset_basex = 0;
        z.routes[aQ].legendoffset_basey = 0;
      }
      if (
        z.settings.autoanalysis &&
        z.settings.mode == z.settings.modes.AnalysisMode &&
        z.numsegments > 0 &&
        M == 2 &&
        !z.settings.runningwild
      ) {
        var ao = null;
        var at = 1e99;
        for (var aQ = 0; aQ < z.segments.length; aQ++) {
          var T = z.segments[aQ];
          if (1) {
            var af = z.autornr1;
            var ae = z.autornr2;
            var ay = T.pos1end;
            var ax = T.pos2end;
            var aL = z.routes[af].latarray[ay];
            var an = z.routes[af].lngarray[ay];
            var aI = z.routes[ae].latarray[ax];
            var al = z.routes[ae].lngarray[ax];
            var aA = (aL + aI) / 2;
            var au = (an + al) / 2;
            var S = z.map.toxy(aA, au);
            var aV = S.x;
            var aU = S.y;
            R = (aK - aV) * (aK - aV) + (aH - aU) * (aH - aU);
            if (R < at) {
              at = R;
              ao = aQ;
            }
          }
        }
        if (!(ao == null)) {
          removesegment = z.segments[ao + 1];
          if (removesegment) {
            z.segments.splice(ao + 1, 1);
            T = z.segments[ao];
            T.pos1end = removesegment.pos1end;
            T.pos2end = removesegment.pos2end;
            T.length1 = T.pos1end - T.pos1start;
            T.length2 = T.pos2end - T.pos2start;
            z.numsegments--;
          }
        }
      } else {
        if (
          z.settings.autoanalysis &&
          z.settings.mode == z.settings.modes.AnalysisMode &&
          z.numsegments > 0 &&
          M == 1 &&
          !z.settings.runningwild
        ) {
          af = z.segments[0].rnr1;
          ae = z.segments[0].rnr2;
          var S = z.map.tolatlng(aK, aH);
          thispoint1 = z.routes[af].findclosestpoint(
            S.lat,
            S.lng,
            "shownsegment2",
            z.playtime
          );
          thispoint2 = z.routes[ae].findclosestpoint(
            S.lat,
            S.lng,
            "shownsegment2",
            z.playtime
          );
          dist1 = thispoint1.distance;
          dist2 = thispoint2.distance;
          if (!z.autoanalysis_split_in_progress) {
            z.autoanalysis_split_in_progress = new Object();
            if (dist1 <= dist2) {
              z.autoanalysis_split_in_progress.thispoint1 = thispoint1;
              z.autoanalysis_split_in_progress.thispoint2 = null;
            } else {
              z.autoanalysis_split_in_progress.thispoint1 = null;
              z.autoanalysis_split_in_progress.thispoint2 = thispoint2;
            }
          } else {
            equallength = 0;
            if (z.autoanalysis_split_in_progress.thispoint1) {
              thispoint1 = z.autoanalysis_split_in_progress.thispoint1;
              if (dist1 < dist2) {
                equallength = 1;
              }
            } else {
              thispoint2 = z.autoanalysis_split_in_progress.thispoint2;
              if (dist2 < dist1) {
                equallength = 2;
              }
            }
            z.autoanalysis_split_in_progress = null;
            pos1_split = thispoint1.index;
            pos2_split = thispoint2.index;
            insert_index = null;
            if ((pos1_split >= 0) & (pos2_split >= 0)) {
              for (var aQ = 0; aQ < z.segments.length; aQ++) {
                T = z.segments[aQ];
                if (
                  (T.pos1end >= pos1_split) &
                    (T.pos1start <= pos1_split) &
                    (T.pos2end >= pos2_split) &
                    (T.pos2start <= pos2_split) ||
                  (T.pos1end >= pos1_split) &
                    (T.pos1start <= pos1_split) &
                    (equallength == 1) ||
                  (T.pos2end >= pos2_split) &
                    (T.pos2start <= pos2_split) &
                    (equallength == 2)
                ) {
                  insert_index = aQ;
                }
              }
            }
            if (insert_index != null) {
              insertatend = 0;
              if (equallength == 1) {
                pos2_split =
                  z.segments[insert_index].pos2start +
                  (pos1_split - z.segments[insert_index].pos1start);
              } else {
                if (equallength == 2) {
                  pos1_split =
                    z.segments[insert_index].pos1start +
                    (pos2_split - z.segments[insert_index].pos2start);
                }
              }
              if (insert_index < z.segments.length - 1) {
                z.segments.splice(
                  insert_index + 1,
                  0,
                  new Segment(
                    pos1_split,
                    pos2_split,
                    1,
                    z.segments[0].rnr1,
                    z.segments[0].rnr2
                  )
                );
              } else {
                z.segments.push(
                  new Segment(
                    pos1_split,
                    pos2_split,
                    1,
                    z.segments[0].rnr1,
                    z.segments[0].rnr2
                  )
                );
                insertatend = 1;
              }
              z.numsegments = z.numsegments + 1;
              T = z.segments[insert_index + 1];
              prevsegment = z.segments[insert_index];
              if (!insertatend) {
                nextsegment = z.segments[insert_index + 2];
                T.pos1end = nextsegment.pos1start;
                T.pos2end = nextsegment.pos2start;
                nextsegment.pos1start = T.pos1end;
                nextsegment.pos2start = T.pos2end;
                nextsegment.length1 =
                  nextsegment.pos1end - nextsegment.pos1start;
                nextsegment.length2 =
                  nextsegment.pos2end - nextsegment.pos2start;
              } else {
                T.pos1end = prevsegment.pos1end;
                T.pos2end = prevsegment.pos2end;
              }
              T.length1 = T.pos1end - T.pos1start;
              T.length2 = T.pos2end - T.pos2start;
              T.show = 2;
              prevsegment.pos1end = T.pos1start;
              prevsegment.pos2end = T.pos2start;
              prevsegment.length1 = prevsegment.pos1end - prevsegment.pos1start;
              prevsegment.length2 = prevsegment.pos2end - prevsegment.pos2start;
            }
          }
        } else {
          if (
            z.settings.detailedanalysis &&
            z.settings.mode == z.settings.modes.DetailedMode &&
            !z.settings.runningwild
          ) {
            if (M == 0) {
              at = 1e99;
              foundroute = null;
              foundpoint = null;
              for (var aQ = 0; aQ < z.routes.length; aQ++) {
                var O = z.routes[aQ];
                if (O.show) {
                  var S = z.map.tolatlng(aK, aH);
                  aN = O.findclosestpoint(S.lat, S.lng, "completeroute", -1);
                  thismindist = aN.distance;
                  if (thismindist < at) {
                    at = thismindist;
                    foundpoint = aN;
                    foundroute = aQ;
                  }
                }
              }
              if (foundpoint) {
                detailedpoint = new Object();
                detailedpoint.routemd5 = z.routes[foundroute].md5;
                detailedpoint.point = foundpoint;
                z.detailedpoints.push(detailedpoint);
                z.request_redraw();
              }
            } else {
              if (M == 2) {
                var at = 1e99;
                foundpointnum = null;
                for (jj = 0; jj < z.detailedpoints.length; jj++) {
                  var aN = z.detailedpoints[jj];
                  aA = aN.point.P.lat;
                  au = aN.point.P.lng;
                  var S = z.map.toxy(aA, au);
                  var aV = S.x;
                  var aU = S.y;
                  var V = (aV - aK) * (aV - aK) + (aU - aH) * (aU - aH);
                  if (V < at) {
                    at = V;
                    foundpointnum = jj;
                  }
                }
                if (foundpointnum != null) {
                  z.detailedpoints.splice(foundpointnum, 1);
                }
              }
            }
          } else {
            if (z.settings.calibrationmode) {
              if (z.routes.length > 0) {
                var S = z.map.tolatlng(aK, aH);
                var Q = z.findclosestcalpoint(S.lat, S.lng).calpoint;
                var aa = mapviewer.map.calstring;
                var aq = aa.split("|");
                var an = parseFloat(aq[0]);
                var aL = parseFloat(aq[1]);
                var al = parseFloat(aq[4]);
                var aI = parseFloat(aq[5]);
                var ak = parseFloat(aq[8]);
                var aF = parseFloat(aq[9]);
                var ad = parseFloat(aq[2]);
                var aW = parseFloat(aq[3]);
                var ac = parseFloat(aq[6]);
                var aT = parseFloat(aq[7]);
                var Z = parseFloat(aq[10]);
                var aS = parseFloat(aq[11]);
                var aN = mapviewer.routes[0].findclosestpoint(
                  S.lat,
                  S.lng,
                  "completeroute"
                );
                var az = aN.P.lat;
                var ap = aN.P.lng;
                var aB = z.map.toxy(az, ap);
                var ab = aB.x;
                var aG = aB.y;
                if (Q == 0) {
                  aL = az;
                  an = ap;
                  ad = ab;
                  aW = aG;
                } else {
                  if (Q == 1) {
                    aI = az;
                    al = ap;
                    ac = ab;
                    aT = aG;
                  } else {
                    if (Q == 2) {
                      aF = az;
                      ak = ap;
                      Z = ab;
                      aS = aG;
                    }
                  }
                }
                aa =
                  an +
                  "|" +
                  aL +
                  "|" +
                  ad +
                  "|" +
                  aW +
                  "|" +
                  al +
                  "|" +
                  aI +
                  "|" +
                  ac +
                  "|" +
                  aT +
                  "|" +
                  ak +
                  "|" +
                  aF +
                  "|" +
                  Z +
                  "|" +
                  aS;
                mapviewer.map.calstring = aa;
                mapviewer.map.initcalibration(aa);
              } else {
                alert("Note! You need to add route(s) to calibrate the map!");
              }
            } else {
              if (z.settings.modifyroutes) {
                var S = z.map.tolatlng(aK, aH);
                for (var aQ = 0; aQ < z.routes.length; aQ++) {
                  if (z.routes[aQ].show) {
                    O = z.routes[aQ];
                    aQ = z.routes.length + 1;
                  }
                }
                var aN = O.findclosestpoint(S.lat, S.lng, "completeroute", -1);
                O.modifyroute_stablepoints.push(aN);
                O.modifyroute_stablepoints.sort(sort_index);
              } else {
                if (z.currenttag == null && z.settings.tagmode == 3 && M >= 1) {
                  var ar = new Array();
                  for (var aQ = 0; aQ < z.routes.length; aQ++) {
                    ar[z.routes[aQ].md5] = aQ;
                  }
                  var aC = null;
                  var at = 1e99;
                  var ag = "none";
                  for (var aQ = 0; aQ < z.tags.length; aQ++) {
                    var aj = z.tags[aQ];
                    if (aj.type != "route" && aj.type != "deleted") {
                      var U = aj.md5;
                      var aE = ar[U];
                      if (z.routes[aE].show) {
                        var Y =
                          z.routes[aE].currenttime(z.playtime) -
                          z.routes[aE].taillength;
                        var aR = z.routes[aE].currenttime(z.playtime);
                        if (aj.ind >= Y && aj.ind <= aR) {
                          if (aj.type == "point") {
                            aV = aj.x;
                            aU = aj.y;
                          } else {
                            aV = (aj.x + aj.tox) / 2;
                            aU = (aj.y + aj.toy) / 2;
                          }
                          R = (aK - aV) * (aK - aV) + (aH - aU) * (aH - aU);
                          if (R < at) {
                            at = R;
                            aC = aQ;
                            ag = "";
                          }
                        }
                      }
                    } else {
                      if (aj.type != "deleted") {
                        if (aj.show && aj.pointsxy.length > 0) {
                          var av = aj.pointsxy;
                          var S = av[Math.floor(av.length / 2)];
                          var aw = S.split(",");
                          var aP = aw[0];
                          var aO = aw[1];
                          var R =
                            (aK - parseInt(aP) - aj.offsettxt_x) *
                              (aK - parseInt(aP) - aj.offsettxt_x) +
                            (aH - parseInt(aO) - aj.offsettxt_y) *
                              (aH - parseInt(aO) - aj.offsettxt_y);
                          if (R < at) {
                            at = R;
                            aC = aQ;
                            ag = "route";
                          }
                        }
                      }
                    }
                  }
                  if (ag == "none" && M == 2) {
                    for (var aQ = 0; aQ < z.tags.length; aQ++) {
                      z.tags[aQ].show = 1;
                    }
                  } else {
                    if (!(aC == null)) {
                      if (ag != "route") {
                        alert(z.tags[aC].name);
                      } else {
                        if (z.settings.tagging_deletemode && M == 2) {
                          z.tags[aC].type = "deleted";
                          z.tags[aC].show = 0;
                        } else {
                          if (M == 1) {
                            z.currenttag = z.tags[aC];
                            z.request_redraw();
                          } else {
                            var ai = z.tags[aC].name;
                            if (!ai) {
                              ai = "Noname";
                            }
                            aJ = z.lastcontrol;
                            z.settings.infotxt =
                              "Control " +
                              aJ +
                              ", route " +
                              ai +
                              " (" +
                              parseInt(z.tags[aC].length) +
                              " m): ";
                            for (var aQ = 0; aQ < z.routes.length; aQ++) {
                              var O = z.routes[aQ];
                              if (O.show && O.segmenttime > 0) {
                                if (!O.variants) {
                                  O.variants = new Array();
                                }
                                aJ = z.lastcontrol;
                                if (
                                  aJ &&
                                  z.settings.mode ==
                                    z.settings.modes.AnalysisMode
                                ) {
                                  O.variants[aJ] = aC;
                                  z.settings.infotxt =
                                    z.settings.infotxt +
                                    " " +
                                    z.routes[aQ].runnername +
                                    ".";
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (z.settings.tagmode != 0) {
                    if (z.settings.tagmode == 1) {
                      type = "point";
                    } else {
                      if (z.settings.tagmode == 2) {
                        type = "segment";
                      } else {
                        if (z.settings.tagmode == 3) {
                          type = "route";
                        }
                      }
                    }
                    z.do_tagging(aK, aH, type, M);
                    z.request_redraw();
                  } else {
                    if (
                      z.settings.mode == z.settings.modes.ReplayMode &&
                      M != 1
                    ) {
                      if (z.realtime == 0) {
                        if (
                          z.settings.colormode == z.settings.modes.colorbyorg
                        ) {
                          z.recolorbyorg();
                        }
                        z.reset_taillengths();
                        z.move_all_runners_to(aK, aH, "closest");
                        z.update_routediv(true);
                        z.request_redraw();
                      }
                    } else {
                      if (z.settings.mode == z.settings.modes.DrawCourseMode) {
                        if (M == 0) {
                          z.coursecoords.push(aK + "," + aH);
                          z.update_courselength();
                        } else {
                          if (M == 2) {
                            var S = z.map.tolatlng(aK, aH);
                            var am = z.findclosestcontrol(S.lat, S.lng);
                            if (am.distance <= 50) {
                              z.coursecoords.splice(am.controlnu, 1);
                            } else {
                              var N = am.controlnu;
                              if (am.controlnu_next > am.controlnu) {
                                N = am.controlnu_next;
                              }
                              z.coursecoords.splice(N, 0, aK + "," + aH);
                            }
                            z.update_courselength();
                            z.request_redraw();
                          }
                        }
                      } else {
                        if (
                          z.settings.mode == z.settings.modes.AnalysisMode &&
                          M != 1
                        ) {
                          z.settings.infotxt = "";
                          z.segments = new Array();
                          z.numsegments = 0;
                          var aJ = null;
                          if (z.settings.analyzecourse) {
                            var S = z.map.tolatlng(aK, aH);
                            var X = z.findclosestleg(S.lat, S.lng);
                            if (X) {
                              aJ = X.controlnu;
                            }
                            if (aJ != null) {
                              z.drawroutechoice_leg(aJ);
                              z.update_routediv(true);
                              z.request_redraw();
                            } else {
                              alert("Found no course. Define a course first");
                            }
                          } else {
                            z.draw_routechoices_to(aK, aH);
                            if (
                              z.settings.colormode ==
                              z.settings.modes.colorbysplit
                            ) {
                              z.recolorbysplit();
                            } else {
                              if (
                                z.settings.colormode ==
                                z.settings.modes.colorbylength
                              ) {
                                z.recolorbylength();
                              }
                            }
                            z.update_routediv(true);
                            z.request_redraw();
                          }
                        } else {
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    z.settings.previousmode = z.settings.mode;
  };
  m.redraw = function () {
    z.redraw();
  };
  m.request_redraw = function () {
    z.request_redraw();
  };
  function H() {
    requestAnimFrame(H);
    z.play_loop();
  }
  this.do_tagging = function (ar, aq, ay, N) {
    var ac = z.map.tolatlng(ar, aq);
    var O = ac.lat;
    var aw = ac.lng;
    if (ay == "route") {
      if (!z.currenttag) {
        z.currenttag = new Object();
        z.currenttag.type = ay;
        z.currenttag.opened_dialog = 0;
        z.currenttag.ready_for_dialog = 0;
        z.currenttag.runnername = "Route";
        var ap = new Array();
        z.currenttag.points = ap;
        var M = new Array();
        z.currenttag.pointsxy = M;
        z.currenttag.currenttime = 0;
        z.currenttag.currentalt = 0;
        z.currenttag.totalup = 0;
        z.currenttag.show = 1;
        z.currenttag.offsettxt_x = 0;
        z.currenttag.offsettxt_y = 0;
        z.currenttag.offsettxt_basex = 0;
        z.currenttag.offsettxt_basey = 0;
        z.currenttag.group = this.settings.tagging_lastgroup;
      }
      if (!N) {
        var ae = 0;
        if (z.currenttag.points.length > 0) {
          z.currenttag.currenttime =
            z.currenttag.currenttime + z.currenttime_delta;
          if (
            Math.abs(ar - z.currenttag.x) <= 3 &&
            Math.abs(aq - z.currenttag.y) <= 3
          ) {
            z.currenttag.ready_for_dialog = 1;
            ae = 1;
          }
        }
        if (!ae) {
          z.currenttag.pointsxy[z.currenttag.pointsxy.length] =
            ar +
            "," +
            aq +
            "," +
            z.currenttag.currenttime +
            "," +
            z.currenttag.currentalt;
          z.currenttag.points[z.currenttag.points.length] =
            O +
            "," +
            aw +
            "," +
            z.currenttag.currenttime +
            "," +
            z.currenttag.currentalt;
          z.currenttag.x = ar;
          z.currenttag.y = aq;
        }
        z.updateinfobottomdiv();
      } else {
        if (N == 1) {
          z.currenttag.points.pop();
          var V = z.currenttag.pointsxy.pop();
          if (z.currenttag.pointsxy.length > 0) {
            var ab = z.currenttag.pointsxy[z.currenttag.pointsxy.length - 1];
            var ai = ab.split(",");
            z.currenttag.x = parseInt(ai[0]);
            z.currenttag.y = parseInt(ai[1]);
            z.currenttag.currenttime = parseInt(ai[2]);
            z.currenttag.currentalt = parseInt(ai[3]);
          } else {
            z.currenttag = null;
          }
          z.updateinfobottomdiv();
        } else {
          if (N == 3) {
            z.currenttag.ready_for_dialog = 1;
          }
        }
      }
      var an = 0;
      if (z.currenttag) {
        if (z.currenttag.points.length > 1) {
          var T = z.currenttag.points[0];
          var aa = T.split(",");
          var ah = aa[0];
          var ad = aa[1];
          for (var ax = 1; ax < z.currenttag.points.length; ax++) {
            var T = z.currenttag.points[ax];
            var aa = T.split(",");
            var ak = aa[0];
            var ag = aa[1];
            d = calcdistance(ah, ad, ak, ag);
            an = an + d;
            ah = ak;
            ad = ag;
          }
          z.currenttag.totalup = 0;
          var X = 0;
          for (var ax = 0; ax < z.currenttag.points.length; ax++) {
            var S = z.currenttag.points[ax];
            var ai = S.split(",");
            var U = ai[3];
            var Q = U - X;
            if (Q > 0) {
              z.currenttag.totalup += Q;
            }
            X = U;
          }
        }
        z.currenttag.length = an;
      }
    } else {
      fromroute = 0;
      toroute = z.routes.length;
      if (ay == "segment") {
        if (z.currenttag) {
          if (!z.currenttag.tox && z.currenttag.type == "segment") {
            fromroute = z.currenttag.rnr;
            toroute = z.currenttag.rnr + 1;
          }
        }
      }
      var af = 1e99;
      var T = null;
      var Y = null;
      var ao = null;
      for (var ax = fromroute; ax < toroute; ax++) {
        if (z.routes[ax].show) {
          var R = z.routes[ax];
          var at = R.findclosestpoint(O, aw, "shownsegment2", z.playtime);
          var W = at.distance;
          if (W < af) {
            var am = z.map.toxy(at.P.lat, at.P.lng);
            af = W;
            T = am;
            ao = ax;
            Y = at;
          }
        }
      }
      if (T) {
        var al = T.x;
        var aj = T.y;
        var av = z.routes[ao].timearray[Y.index] - z.routes[ao].timearray[0];
        var au = Y.index;
        var Z = z.routes[ao].calc_length(0, au);
        if (!z.currenttag) {
          z.currenttag = new Object();
          z.currenttag.tox = null;
          z.currenttag.show = 1;
        }
        if (!z.currenttag.tox && z.currenttag.type == "segment") {
          if (au <= z.currenttag.ind) {
            alert("Error! Negative tag length - please try again!");
          } else {
            z.currenttag.toind = au;
            z.currenttag.tox = al;
            z.currenttag.toy = aj;
            z.currenttag.type = ay;
            z.currenttag.ready_for_dialog = 1;
            z.currenttag.totime = av;
            z.currenttag.tolength = Z;
          }
        } else {
          z.currenttag = new Object();
          z.currenttag.type = ay;
          z.currenttag.x = al;
          z.currenttag.y = aj;
          z.currenttag.ind = au;
          z.currenttag.time = av;
          z.currenttag.tox = null;
          z.currenttag.toy = null;
          z.currenttag.show = 1;
          z.currenttag.rnr = ao;
          z.currenttag.length = Z;
          z.currenttag.runnername = z.routes[ao].runnername;
          z.currenttag.md5 = z.routes[ao].md5;
          z.currenttag.currenttime = 0;
          z.currenttag.currentalt = 0;
          z.currenttag.totalup = 0;
          z.currenttag.offsettxt_x = 0;
          z.currenttag.offsettxt_y = 0;
          z.currenttag.offsettxt_basex = 0;
          z.currenttag.offsettxt_basey = 0;
          z.currenttag.group = this.settings.tagging_lastgroup;
          z.currenttag.opened_dialog = 0;
          if (ay == "point") {
            z.currenttag.ready_for_dialog = 1;
          } else {
            z.currenttag.ready_for_dialog = 0;
          }
        }
      }
    }
  };
  this.runningwild_findstart = function () {
    var N = null;
    var M = null;
    if (z.tags) {
      if (z.tags.length > 0) {
        tnr = 0;
        thistag = z.tags[tnr];
        if (thistag.type == "route") {
          var Q = thistag.points[0];
          var S = Q.split(",");
          N = parseFloat(S[0]);
          M = parseFloat(S[1]);
        }
      }
    }
    if (!N && !M) {
      if (z.coursecoords) {
        if (z.coursecoords.length > 0) {
          var O = z.coursecoords[0];
          var R = O.split(",");
          var Q = z.map.tolatlng(R[0], R[1]);
          N = Q.lat;
          M = Q.lng;
        }
      }
    }
    if (!N && !M) {
      if (z.routes.length > 0) {
        if (z.routes[0].splits) {
          if (z.routes[0].splits.length > 0) {
            ind = z.routes[0].splits[0].index;
            N = z.routes[0].latarray[ind];
            M = z.routes[0].lngarray[ind];
          }
        }
      }
      if (!N || !M) {
        if (z.routes.length > 0) {
          N = z.routes[0].latarray[0];
          M = z.routes[0].lngarray[0];
        }
      }
    }
    var Q = new Object();
    Q.startlat = N;
    Q.startlng = M;
    return Q;
  };
  this.map.onmapload = function () {
    z.onmapload();
  };
  this.onmapload = function () {
    z.canvas.context.scale(1 * z.canvas.zoomfactor, 1 * z.canvas.zoomfactor);
    if (z.routes[0] && z.map_start_x == 0) {
      var M = z.routes[0];
      P1 = z.map.toxy(M.latarray[0], M.lngarray[0]);
      z.map_start_x = P1.x;
      z.map_start_y = P1.y;
    }
    if (z.load_qnr == 0 && z.routes.length == 0) {
    } else {
      z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
    }
    if (z.load_qnr == 0) {
      z.request_redraw();
    }
    if (z.map.mapobject.width == 0) {
      alert("Sorry - could not load map!");
    }
    $(window).resize(function () {
      rtime = new Date();
      if (timeout === false) {
        timeout = true;
        setTimeout(resizeCanvas, delta);
      }
    });
    H();
    if (z.settings.loadmaptype == "loadcoursewithmap") {
      $("#setscalediv").show();
      $("#courseplanning_courselength").show();
      $("#" + z.infobottomdiv).show();
      if (z.coursecoords.length > 0) {
        z.settings.centerlegnum = 1;
        z.centerleg(0);
        z.showtags_control(1);
      }
      $("#selectmode").val("analyzecourse");
      $("#selectmode").change();
      z.request_redraw();
      z.update_routediv();
    }
  };
  this.recalc_coursegraphs = function () {
    var M = 0;
    for (var N = 0; N < z.routes.length; N++) {
      if (z.routes[N].lapdata.length) {
        M++;
      }
    }
    if (M == 0 || z.courseinfo.neednewsnap) {
      z.snaproutestocourse();
    }
    var M = 0;
    for (var N = 0; N < z.routes.length; N++) {
      if (z.routes[N].lapdata.length) {
        M++;
      }
    }
    if (M == 0) {
      alert("Sorry - no routes fitting this course");
    } else {
      if (
        z.settings.showInfoBelow != "CourseInfo" &&
        z.settings.showgraphs != 1
      ) {
        z.settings.showgraphs = 1;
        z.settings.showInfoBelow = "CourseInfo";
        z.redraw();
      }
      z.plotgraphs();
      z.request_redraw();
    }
  };
  this.toggle_graphs = function () {
    if (mapviewer.settings.showInfoBelow == "CourseInfo") {
      mapviewer.settings.showInfoBelow = "";
      mapviewer.request_redraw();
      mapviewer.settings.showcourse = 2;
    } else {
      mapviewer.settings.showInfoBelow = "CourseInfo";
      mapviewer.request_redraw();
      mapviewer.settings.showcourse = 2;
    }
  };
  this.doplotcoursegraph = function () {
    var N = 0;
    for (var O = 0; O < z.routes.length; O++) {
      if (z.routes[O].show) {
        N++;
      }
    }
    if (N == 0) {
      z.routes[0].show = 1;
      z.update_routediv();
    }
    var M = 0;
    for (var O = 0; O < z.settings.graphs.length; O++) {
      var Q = parseInt($("#selectgraph-" + (O + 1)).val());
      if (Q > 0) {
        M++;
      }
    }
    if (M == 0) {
      alert("No graphs to plot!");
      return;
    }
    if (!z.coursecoords.length || !z.courseinfo) {
      alert("No course defined!");
    } else {
      if (!mapviewer.settings.showInfoBelow == "CourseInfo") {
        mapviewer.settings.showInfoBelow = "CourseInfo";
        mapviewer.request_redraw();
        mapviewer.settings.showcourse = 2;
      }
      z.recalc_coursegraphs();
    }
  };
  this.plotgraphs = function () {
    z.settings.timegraphtype = parseInt($("#timegraphtype").val());
    z.settings.timegraphlimit = parseInt($("#timegraphlimit").val());
    z.settings.graph_compare_winner = parseInt(
      $("#graph_compare_winner").val()
    );
    var Q = 0;
    for (var R = 0; R < z.settings.graphs.length; R++) {
      var S = parseInt($("#selectgraph-" + (R + 1)).val());
      if (!z.settings.graphs[R]) {
        z.settings.graphs[R] = new Object();
      }
      z.settings.graphs[R].plottype = S;
      var M = $("#graph-" + (R + 1)).css("display") == "block";
      if (S != 0 && !M) {
        Q = 1;
      }
      if (S == 0 && M) {
        Q = 1;
      }
    }
    if (Q) {
      if (this.courseinfo.coursetype != "o") {
        if (!mapviewer.courseinfo.hillsegments) {
          z.findhills_eleprofile();
        }
      }
      z.redraw();
    } else {
      for (var R = 0; R < z.settings.graphs.length; R++) {
        if (z.settings.graphobjs[R]) {
          z.settings.graphobjs[R].destroy();
        }
        $("#graph-" + (R + 1)).html("");
        $("#graph-" + (R + 1)).empty();
        if (z.settings.graphs[R].plottype) {
          $("#graph-" + (R + 1)).html(
            '<center><img src="loading.gif"></center>'
          );
          var O = z.settings.graphs[R].plottype;
          var N = R + 1;
          z.settings.graphobjs[R] = z.plotgraph(
            "#graph-" + (R + 1),
            z.settings.graphs[R].plottype,
            R
          );
        } else {
          z.settings.graphobjs[R] = null;
        }
      }
    }
  };
  this.findhills_eleprofile = function () {
    if (!z.courseinfo) {
      z.courseinfo = new Object();
    }
    z.findhills_eleprofile_inner(1);
    var N = z.courseinfo.hillsegments;
    var M = 0;
    for (var O = 0; O < N.length; O++) {
      if (N[O].theelediff > 0) {
        M = M + N[O].theelediff;
      }
    }
    z.courseinfo.climb = M;
    var Q = z.courseinfo.min_antupdown_for_hill;
    z.findhills_eleprofile_inner(Q);
    $("#savexccourse_button").html("Save course (" + parseInt(M) + " m climb)");
  };
  this.findhills_eleprofile_inner = function (ah) {
    var ai = new Array();
    var W = z.coursecoords;
    if (W.length > 1) {
      var V = 0;
      var O;
      var aj = 0;
      var aa = 0;
      var T = 0;
      var ak = z.courseinfo.maxantflat;
      var ag = 1;
      var Z = 0;
      var ae = 0;
      var M = new Array();
      var ad = new Array();
      M[0] = 0;
      for (var af = 0; af < W.length; af++) {
        var ab = W[af].split(",");
        x1 = ab[0];
        y1 = ab[1];
        ele = ab[2];
        orgdist = parseFloat(ab[3]);
        var S = z.map.tolatlng(x1, y1);
        var R = S.lat;
        var al = S.lng;
        if (af == 0) {
          O = parseFloat(ele);
          prevele = O;
        }
        ele = parseFloat(ele) - O;
        ad[af] = ele;
        if (af > 0) {
          d = calcdistance(prevlat, prevlng, R, al);
          V = V + d;
          if (orgdist) {
            M[af] = orgdist;
          } else {
            M[af] = V;
          }
        }
        var Y = 0;
        if (af == W.length - 1) {
          Y = 1;
        }
        if (
          (ele - prevele > 0 || (ele == prevele && T <= ak)) &&
          aj == 1 &&
          !Y
        ) {
          if (ele == prevele) {
            T++;
          } else {
            T = 0;
          }
          aa++;
        } else {
          if (
            (ele - prevele < 0 || (ele == prevele && T <= ak)) &&
            aj == -1 &&
            !Y
          ) {
            if (ele == prevele) {
              T++;
            } else {
              T = 0;
            }
            aa++;
          } else {
            if (aa > ah || Y) {
              if (aa <= ah || Y) {
                Z = af;
              }
              if (aj > 0) {
                hilltype = "Uphill";
              } else {
                hilltype = "Downhill";
              }
              if (Z == 1 && ae == 0) {
              } else {
                if ((Z != ae && Z > 0) || Y) {
                  var N = new Object();
                  N.thetype = "Flat";
                  N.thetypeint = 0;
                  N.thelength = M[Z] - M[ae];
                  N.theelediff = ad[Z] - ad[ae];
                  N.endind = Z - 1;
                  N.startind = ae - 1;
                  if (N.startind < 0) {
                    N.startind = 0;
                  }
                  if (Y) {
                    N.endind = W.length - 1;
                  }
                  N.percent = 0;
                  var U = N.startind - 1;
                  if (U < 0) {
                    U = 0;
                  }
                  N.startdist = M[U];
                  N.startele = ad[U];
                  N.hillcolor = z.hillcolors[1];
                  if (N.thelength > 0) {
                    N.percent = parseInt(100 * (N.theelediff / N.thelength));
                  }
                  ai.push(N);
                }
              }
              if (aa > ah && !Y) {
                var N = new Object();
                var N = new Object();
                N.thetype = hilltype;
                N.thetypeint = aj;
                N.startind = Z - 1;
                if (N.startind < 0) {
                  N.startind = 0;
                }
                N.endind = af - T - 1;
                var U = N.startind;
                N.thelength = M[N.endind] - M[N.startind];
                N.theelediff = ad[N.endind] - ad[N.startind];
                N.startdist = M[N.startind];
                N.startele = ad[N.startind];
                N.hillcolor = z.hillcolors[aj + 1];
                N.percent = 0;
                if (N.thelength > 0) {
                  N.percent = parseInt(100 * (N.theelediff / N.thelength));
                }
                ai.push(N);
              }
              ae = af - T;
              T = 0;
            } else {
            }
            aa = 0;
            if (ele - prevele > 0) {
              aj = 1;
            } else {
              aj = -1;
            }
            Z = af;
          }
        }
        prevele = ele;
        prevlat = R;
        prevlng = al;
      }
      var ac = ai[ai.length - 1];
      if (ac) {
        if (ac.theelediff < -ah) {
          ac.thetype = "Downhill";
          ac.thetypeint = -1;
        } else {
          if (ac.theelediff > ah) {
            ac.thetype = "Uphill";
            ac.thetypeint = 1;
          }
        }
      }
      z.courseinfo.hillsegments = ai;
      z.courseinfo.distarray = M;
      var X = new Array();
      var W = z.coursecoords;
      var Q = 2;
      for (var af = 0; af < W.length - Q; af = af + Q) {
        var N = new Object();
        N.thelength = M[af + Q] - M[af];
        N.theelediff = ad[af + Q] - ad[af];
        N.endind = af + Q;
        if (N.theelediff == 0) {
          N.thetype = "Flat";
          N.thetypeint = 0;
        } else {
          if (N.theelediff >= 0) {
            N.thetype = "Uphill";
            N.thetypeint = 1;
          } else {
            N.thetype = "Downhill";
            N.thetypeint = -1;
          }
        }
        N.startind = af;
        N.percent = 0;
        var U = N.startind - 1;
        if (U < 0) {
          U = 0;
        }
        N.startdist = M[U];
        N.startele = ad[U];
        if (N.thelength > 0) {
          N.percent = parseInt(100 * (N.theelediff / N.thelength));
        }
        X.push(N);
      }
      z.courseinfo.shorthillsegments = X;
    }
  };
  this.findhills_eleprofile_inner_notfinished = function (ad) {
    if (z.coursecoords) {
      z = mapviewer;
      var ag = new Array();
      var W = z.coursecoords;
      if (W.length > 1) {
        var T = 0;
        var Q;
        var M = new Array();
        var ab = new Array();
        var ai = z.courseinfo.maxantflat;
        var U = z.courseinfo.min_eleopposite_allowed;
        var ah = 0;
        var al = new Array();
        var Z = new Array();
        var ak = new Array();
        var aa = new Array();
        var N = 0;
        var V = 0;
        M[0] = 0;
        for (var ac = 0; ac < W.length; ac++) {
          var Y = W[ac].split(",");
          x1 = Y[0];
          y1 = Y[1];
          ele = Y[2];
          orgdist = parseFloat(Y[3]);
          var S = z.map.tolatlng(x1, y1);
          var R = S.lat;
          var aj = S.lng;
          if (ac == 0) {
            Q = parseFloat(ele);
            prevele = 0;
            prevelemin = prevele;
            prevelemax = prevele;
          }
          ele = parseFloat(ele) - Q;
          ab[ac] = ele;
          if (ac == W.length - 1) {
            ele = prevele;
            antflat = ai + 1;
          }
          var X = Math.sign(ele - prevele);
          if (ac <= 1) {
            ah = X;
          } else {
            if (ah != X) {
              al.push(ac - 1);
              Z.push(prevele);
              ak.push(V);
              aa.push(ah);
              N = prevele;
              V = orgdist;
              ah = X;
            }
          }
          prevele = ele;
        }
      }
      var af = 0;
      var ae = 50;
      while (af) {
        for (var O = 1; O < ak.length; O++) {
          if (ak[O] - ak[O - 1] < ae) {
            ak.slice(O);
            Z.slice(O);
            aa.slice(O);
          }
          this_elediff = Z[O];
        }
      }
    }
  };
  this.findhills_eleprofile_inner_nearlyworked = function (aj) {
    if (z.coursecoords) {
      var ak = new Array();
      var X = z.coursecoords;
      if (X.length > 1) {
        var V = 0;
        var O;
        var am = 0;
        var aa = 0;
        var T = 0;
        var an = z.courseinfo.maxantflat;
        var W = z.courseinfo.min_eleopposite_allowed;
        var ai = 1;
        var Z = 0;
        var ag = 0;
        var M = new Array();
        var af = new Array();
        M[0] = 0;
        for (var ah = 0; ah < X.length; ah++) {
          var ab = X[ah].split(",");
          x1 = ab[0];
          y1 = ab[1];
          ele = ab[2];
          orgdist = parseFloat(ab[3]);
          var S = z.map.tolatlng(x1, y1);
          var R = S.lat;
          var ao = S.lng;
          if (ah == 0) {
            O = parseFloat(ele);
            prevele = O;
            prevelemin = prevele;
            prevelemax = prevele;
          }
          ele = parseFloat(ele) - O;
          var ad = 0;
          var al = 0;
          if ($.inArray(ah, z.courseinfo.lap_spacing) >= 0) {
            ad = 1;
          }
          if ($.inArray(ah - 1, z.courseinfo.lap_spacing) >= 0) {
            al = 1;
            prevele = ele;
            prevelemin = prevele;
            prevelemax = prevele;
          }
          af[ah] = ele;
          if (ah > 0) {
            d = calcdistance(prevlat, prevlng, R, ao);
            V = V + d;
            if (orgdist) {
              M[ah] = orgdist;
            } else {
              M[ah] = V;
            }
          }
          if (ah == X.length - 1) {
            ele = prevele;
            T = an + 1;
          }
          if (al) {
            var N = new Object();
            N.thetype = "Separator";
            N.thetypeint = 2;
            N.thelength = M[ah] - M[ah - 1];
            N.theelediff = 0;
            N.endind = ah;
            N.startind = ah - 1;
            N.percent = 0;
            N.startdist = M[ah - 1];
            N.startele = af[ah - 1];
            N.hillcolor = "0000aa";
            ak.push(N);
            aa = 0;
            Z = ah;
            ag = ah;
            T = 1;
          } else {
            if (
              (ele - prevele > 0 || (ele == prevele && T <= an)) &&
              am == 1 &&
              ad == 0
            ) {
              if (ele == prevele) {
                T++;
              } else {
                T = 0;
              }
              aa++;
              if (ele > prevelemax) {
                prevelemax = ele;
              }
            } else {
              if (
                (ele - prevele < 0 || (ele == prevele && T <= an)) &&
                am == -1 &&
                ad == 0
              ) {
                if (ele == prevele) {
                  T++;
                } else {
                  T = 0;
                }
                aa++;
                if (ele < prevelemin) {
                  prevelemin = ele;
                }
              } else {
                if (aa > aj || ah == X.length - 1 || ad) {
                  if (aa <= aj) {
                    Z = ah;
                  }
                  if (am > 0) {
                    hilltype = "Uphill";
                  } else {
                    hilltype = "Downhill";
                  }
                  var ac = 0;
                  if (Z != ag) {
                    var N = new Object();
                    N.thetype = "Flat";
                    N.thetypeint = 0;
                    N.thelength = M[Z] - M[ag];
                    N.theelediff = af[Z] - af[ag];
                    N.endind = Z;
                    N.startind = ag;
                    N.percent = 0;
                    var U = N.startind;
                    if (U < 0) {
                      U = 0;
                    }
                    N.startdist = M[U];
                    N.startele = af[U];
                    N.hillcolor = z.hillcolors[1];
                    prevelemin = prevele;
                    prevelemax = prevele;
                    if (N.thelength > 0) {
                      N.percent = parseInt(100 * (N.theelediff / N.thelength));
                    }
                    ak.push(N);
                  }
                  if (ah == X.length - 1 || ad) {
                    ac = 1;
                  }
                  if (ah == X.length - 1) {
                  }
                  if (aa > aj || ac) {
                    var ae = ah - T;
                    if (ac) {
                      ae = ah;
                    }
                    var N = new Object();
                    N.thetype = hilltype;
                    N.thetypeint = am;
                    N.thelength = M[ah - T] - M[Z];
                    N.theelediff = af[ah - T] - af[Z];
                    N.startind = Z;
                    N.endind = ae;
                    var U = N.startind;
                    if (U < 0) {
                      U = 0;
                    }
                    N.startdist = M[U];
                    N.startele = af[U];
                    N.hillcolor = z.hillcolors[am + 1];
                    N.percent = 0;
                    if (N.thelength > 0) {
                      N.percent = parseInt(100 * (N.theelediff / N.thelength));
                    }
                    ak.push(N);
                    prevelemin = prevele;
                    prevelemax = prevele;
                  }
                  ag = ah - T;
                  T = 0;
                } else {
                }
                aa = 0;
                if (ele - prevele > 0) {
                  am = 1;
                } else {
                  am = -1;
                }
                Z = ah;
              }
            }
          }
          prevele = ele;
          prevlat = R;
          prevlng = ao;
        }
        z.courseinfo.hillsegments = ak;
        z.courseinfo.distarray = M;
        var Y = new Array();
        var X = z.coursecoords;
        var Q = 2;
        for (var ah = 0; ah < X.length - Q; ah = ah + Q) {
          var N = new Object();
          N.thelength = M[ah + Q] - M[ah];
          N.theelediff = af[ah + Q] - af[ah];
          N.endind = ah + Q;
          if (N.theelediff == 0) {
            N.thetype = "Flat";
            N.thetypeint = 0;
          } else {
            if (N.theelediff >= 0) {
              N.thetype = "Uphill";
              N.thetypeint = 1;
            } else {
              N.thetype = "Downhill";
              N.thetypeint = -1;
            }
          }
          N.startind = ah;
          N.percent = 0;
          var U = N.startind - 1;
          if (U < 0) {
            U = 0;
          }
          N.startdist = M[U];
          N.startele = af[U];
          if (N.thelength > 0) {
            N.percent = parseInt(100 * (N.theelediff / N.thelength));
          }
          Y.push(N);
        }
        z.courseinfo.shorthillsegments = Y;
      }
    }
  };
  this.hillsegments_changetype = function (Q) {
    var M = z.courseinfo.hillsegments;
    for (var O = 0; O < M.length; O++) {
      if (Q >= M[O].startind && Q < M[O].endind) {
        if (M[O].thetypeint < 99) {
          var N = z.hilltypes;
          M[O].thetypeint++;
          if (M[O].thetypeint > 1) {
            M[O].thetypeint = -1;
          }
          M[O].thetype = N[M[O].thetypeint + 1];
        } else {
          alert("Can not change separator!");
        }
      }
    }
  };
  this.courseeditor_define = function () {
    var M = new Object();
    M.coursecoords = z.coursecoords;
    var N = jQuery.extend(true, {}, M);
    if (!z.courseeditor_data) {
      z.courseeditor_data = new Object();
      z.courseeditor_data.courseinfo = jQuery.extend(true, {}, z.courseinfo);
      z.courseeditor_data.coursecoords = N.coursecoords;
    } else {
      if (z.courseinfo.biathlonvariables) {
        z.courseeditor_data.courseinfo.biathlonvariables = jQuery.extend(
          true,
          {},
          z.courseinfo.biathlonvariables
        );
      }
    }
    var M = new Object();
    M.coursecoords = z.courseeditor_data.coursecoords;
    var N = jQuery.extend(true, {}, M);
    z.coursecoords = N.coursecoords;
    z.courseinfo = jQuery.extend(true, {}, z.courseeditor_data.courseinfo);
    z.courseinfo.numlaps = parseInt($("#AutoCourseLaps").val());
    z.hillsegments_combine_segments(z.courseinfo.numlaps);
    var O = z.snaproutestocourse();
    $("#coursefit_status").html(O);
  };
  this.hillsegments_combine_segments = function (ae) {
    if (ae > 1) {
      if (!z.courseinfo.lap_spacing) {
        z.courseinfo.lap_spacing = [];
      }
      z = mapviewer;
      z.courseinfo.climb = z.courseinfo.climb * ae;
      var T = new Array();
      var U = z.coursecoords;
      var aa = new Array();
      var O = 0;
      var S = 0;
      var ad = new Array();
      var R = new Array();
      var Z = z.settings.xc_betweenlap_separation_meters;
      var Q = 0;
      for (var N = 0; N < ae; N++) {
        for (var ac = 0; ac < z.courseinfo.hillsegments.length; ac++) {
          var V = z.courseinfo.hillsegments[ac];
          V = jQuery.extend(true, {}, V);
          V.startind = V.startind + Q;
          V.endind = V.endind + Q;
          ad.push(V);
        }
        for (var ac = 0; ac < z.courseinfo.splitpos.length; ac++) {
          R.push(z.courseinfo.splitpos[ac] + z.coursecoords.length * N);
        }
        if (N < ae - 1) {
          var M = new Object();
          M.thetype = "Separator";
          M.thetypeint = 2;
          M.thelength = Z;
          M.theelediff = 0;
          M.endind = ad[ad.length - 1].endind + 1;
          M.startind = ad[ad.length - 1].endind;
          M.percent = 0;
          M.startdist = 0;
          M.startele = 0;
          M.hillcolor = "0000aa";
          ad.push(M);
        }
        for (var ac = 0; ac < U.length; ac++) {
          var X = U[ac].split(",");
          x1 = X[0];
          y1 = X[1];
          ele = parseFloat(X[2]);
          orgdist = parseFloat(X[3]);
          var O = orgdist - S + O;
          aa.push(O);
          S = orgdist;
          X[3] = O;
          T.push(X.join(","));
        }
        S = -Z;
        Q = T.length;
        if (N < ae - 1) {
          z.courseinfo.lap_spacing.push(Q - 1);
        }
      }
      z.courseinfo.distarray = aa;
      z.coursecoords = T;
      z.courseinfo.hillsegments = ad;
      z.fix_hillsegments_ele_dist();
      z.courseinfo.neednewsnap = 1;
      z.courseinfo.splitpos = R;
    }
    z.courseinfo.segmenttypes = new Array();
    var W = new Array();
    for (var ab = 0; ab < z.courseinfo.hillsegments.length; ab++) {
      if (!W[z.courseinfo.hillsegments[ab].thetype]) {
        W[z.courseinfo.hillsegments[ab].thetype] = 1;
        z.courseinfo.segmenttypes.push(z.courseinfo.hillsegments[ab].thetype);
      }
    }
    var Y = z.courseinfo.segmenttypes.slice();
    Y.push("Complete");
    z.courseinfo.segmentstats = new Array();
    for (var ac = 0; ac < Y.length; ac++) {
      searchtype = Y[ac];
      var af = new Array();
      for (var ab = 0; ab < z.courseinfo.hillsegments.length; ab++) {
        thisseg = z.courseinfo.hillsegments[ab];
        if (thisseg.thetype == searchtype || searchtype == "Complete") {
          af.push(ab);
        }
      }
      z.courseinfo.segmentstats[searchtype] = af.splice(0);
    }
  };
  this.hillsegments_change_separator = function (R) {
    z = mapviewer;
    var M = null;
    var O = "";
    var N = z.courseinfo.hillsegments;
    for (var Q = 0; Q < N.length; Q++) {
      if (R == N[Q].startind) {
        M = Q;
        O = "merge";
      } else {
        if (R > N[Q].startind && R < N[Q].endind) {
          M = Q;
          O = "split";
        }
      }
    }
    if (M != null) {
      if (O == "merge") {
        z.hillsegments_remove_separator(M, R);
      } else {
        z.hillsegments_insert_separator(M, R);
      }
      z.fix_hillsegments_ele_dist();
    }
  };
  this.hillsegments_remove_separator = function (M, Q) {
    var N = z.courseinfo.hillsegments;
    if (M != null && M > 0) {
      var O = N.splice(M, 1);
      N[M - 1].endind = O[0].endind;
    }
  };
  this.hillsegments_insert_separator = function (M, Q) {
    var N = z.courseinfo.hillsegments;
    if (M != null) {
      var O = N[M];
      O = jQuery.extend(true, {}, O);
      N.splice(M + 1, 0, O);
      N[M].endind = Q;
      N[M + 1].startind = Q;
    }
  };
  this.fix_hillsegments_ele_dist = function () {
    z = mapviewer;
    var O = z.courseinfo.hillsegments;
    var V = z.coursecoords;
    var T = new Array();
    var X = new Array();
    for (var R = 0; R < V.length; R++) {
      var W = V[R].split(",");
      x1 = W[0];
      y1 = W[1];
      ele = parseFloat(W[2]);
      orgdist = parseFloat(W[3]);
      X.push(ele);
      T.push(orgdist);
    }
    for (var N = 0; N < O.length; N++) {
      var M = O[N].startind;
      var S = O[N].endind;
      var U = O[N].thetype;
      var Q = O[N];
      Q.startele = X[M];
      Q.startdist = T[M];
      Q.theelediff = X[S] - X[M];
      if (Q.thetype != "Separator") {
        Q.thelength = T[S] - T[M];
      }
      if (Q.thelength > 0) {
        Q.percent = parseInt(100 * (Q.theelediff / Q.thelength));
      } else {
        Q.percent = 0;
      }
      if (Q.thetype == "Separator") {
        Q.percent = 0;
      }
    }
  };
  this.fix_hillsegments_ele_dist_courseeditor = function () {
    z = mapviewer;
    var O = z.courseeditor_data.courseinfo.hillsegments;
    var V = z.coursecoords;
    var T = new Array();
    var X = new Array();
    for (var R = 0; R < V.length; R++) {
      var W = V[R].split(",");
      x1 = W[0];
      y1 = W[1];
      ele = parseFloat(W[2]);
      orgdist = parseFloat(W[3]);
      X.push(ele);
      T.push(orgdist);
    }
    for (var N = 0; N < O.length; N++) {
      var M = O[N].startind;
      var S = O[N].endind;
      var U = O[N].thetype;
      var Q = O[N];
      Q.startele = X[M];
      Q.startdist = T[M];
      Q.theelediff = X[S] - X[M];
      if (Q.thetype != "Separator") {
        Q.thelength = T[S] - T[M];
      }
      if (Q.thelength > 0) {
        Q.percent = parseInt(100 * (Q.theelediff / Q.thelength));
      } else {
        Q.percent = 0;
      }
      if (Q.thetype == "Separator") {
        Q.percent = 0;
      }
    }
  };
  this.makelapanimation = function (O) {
    var N = null;
    O = O.substr(1);
    $("#" + O).html(
      '<div style="margin-bottom:5px;height:100%;overflow-y:scroll;" id="runnercanvas"></div>'
    );
    for (var M = 0; M < z.routes.length; M++) {
      if (z.routes[M].show) {
        z.routes[M].lapanimation_add();
      } else {
        z.routes[M].lapanim = 0;
      }
    }
    z.lapanimation_reset();
    z.lapanim_loop();
    return N;
  };
  this.lapanim_loop = function () {
    requestAnimFrame(mapviewer.lapanim_loop);
    var M = new Date().getTime();
    if (!z.lapanim_prevshowinfo) {
      z.lapanim_prevshowinfo = M;
    }
    var N = 0;
    if ((M - z.lapanim_prevshowinfo) / 1000 > 1) {
      N = 1;
      z.lapanim_prevshowinfo = M;
    }
    z.lapanimation_runnerstocurrentpos(N);
  };
  this.lapanimation_reset = function () {
    var M = new Date().getTime();
    this.lapanimation_starttime_ms = M;
  };
  this.lapanimation_runnertopos = function (M, Q) {
    var N = z.coursecoords.length;
    var O = (Q / N) * 100;
    if (O > 100) {
      O = 100;
    }
    $("#runner-" + M).css("left", O + "%");
  };
  this.lapanimation_linetopos = function (O) {
    var M = z.coursecoords.length;
    var N = (O / M) * 100;
    if (N > 100) {
      N = 100;
    }
    $("#runnerline").css("left", N + "%");
  };
  this.lapanimation_findoffsets = function (Q) {
    var O = 1e99;
    var M = new Object();
    for (var R = 0; R < z.routes.length; R++) {
      if (z.routes[R].lapanim) {
        for (var N = 0; N < z.routes[R].lapdata.length; N++) {
          if (z.routes[R].lapdata[N].lapanim) {
            var S = z.routes[R].gettime_lap(N, Q);
            if (S < O) {
              O = S;
              M.time = O;
              M.rnr = R;
              M.lapnr = N;
            }
          }
        }
      }
    }
    return M;
  };
  this.lapanimation_runnerstocurrentpos = function (N) {
    var O = -1e99;
    var M = null;
    $("#runnercanvas")
      .find("div")
      .each(function () {
        var X = $(this)[0].id;
        var U = X.match(/canvas-(\d+)-(\d+)/);
        if (U) {
          var R = U[1] + "-" + U[2];
          var V = z.lapanimation_runnertocurrentpos(R);
          if (N) {
            var T = V.thispos;
            if (T > O) {
              O = T;
              M = R;
            }
            var W = V.thistime;
            var Q = z.lapanimation_findoffsets(T);
            var S = Math.floor(W - Q.time);
            if (S < 0) {
              S = 0;
            }
            if (S > 0) {
              S = "+" + S;
            } else {
            }
            $("#info-" + R).html(S);
          }
        }
      });
  };
  this.lapanimation_runnertocurrentpos = function (M) {
    var S = M.split("-");
    var N = S[0] - 1;
    var Q = S[1];
    var O = new Date().getTime();
    var U =
      (z.settings.lapanim.speed * (O - z.lapanimation_starttime_ms)) / 1000;
    var R = mapviewer.routes[N].getpos_lap(Q, U);
    z.lapanimation_runnertopos(M, R);
    var T = new Object();
    T.thispos = R;
    T.thistime = U;
    return T;
  };
  z.ploteleprofile = function (ar) {
    if (!z.settings.eleplotoptions) {
      var af = Object();
      af.printspecial = 0;
      af.minheight = 50;
      af.scaled_eleplot = 0;
      af.eleplot_scalefactor = 1;
      af.alwaysshowgrade = 0;
      af.ydivpermeter = 5;
      af.scaletxt = 1;
      af.px_extra_y = 50;
      af.pxpermeter_y = 4;
      af.px_extra_x = 45;
      af.pxpermeter_x = 0.25;
      af.labelsperpixelbeforeoffset = 80;
      z.settings.eleplotoptions = af;
    } else {
      af = z.settings.eleplotoptions;
    }
    var Q = null;
    ar = ar.substr(1);
    var Y;
    var ak;
    Y = z.courseinfo;
    ak = z.coursecoords;
    var ah = Y.hillsegments;
    if (Y.usegradedelevation && Y.shorthillsegments) {
      ah = Y.shorthillsegments;
    }
    var O = new Array();
    var az = new Array();
    az.push(0);
    var aK = -1e99;
    var aB = 1e99;
    var ad = Y.coursecolortype;
    var ao = Y.eachdistmark;
    var T;
    if (ad == 0) {
      T = 1;
    } else {
      T = 0;
    }
    var aj = 0;
    var ax = new Array();
    var ay = new Array();
    var S = new Array();
    if (ak) {
      var ap = ak;
      if (ap.length > 1) {
        var aL = 0;
        var aJ = 0;
        var am;
        var ac = 0;
        var aa = 0;
        var at = ao;
        var al = 0;
        for (var aE = 0; aE < ap.length; aE++) {
          var R = ap[aE].split(",");
          x1 = R[0];
          y1 = R[1];
          ele = parseFloat(R[2]);
          orgdist = parseFloat(R[3]);
          if (!ele) {
            ele = 0;
          }
          if (aE == 0) {
            am = parseFloat(ele);
          }
          ele = parseFloat(ele) - am;
          var V = z.map.tolatlng(x1, y1);
          var aw = V.lat;
          var an = V.lng;
          if (aE > 0) {
            make_division = 0;
            d = calcdistance(prevlat, prevlng, aw, an);
            aL = aL + d;
            if (orgdist) {
              aL = orgdist;
            }
            if (aL >= at) {
              var aD = parseInt(at / 100) / 10 + " km";
              az.push(at / 1000);
              at = at + ao;
              if (!T && ad == 1) {
                make_division = 1;
                aC = z.segcolors[aJ];
              }
            }
            if (ad == 2 && ah) {
              if (ah[aj]) {
                if (
                  (!Y.usegradedelevation && aE >= ah[aj].endind + 1) ||
                  aE == ap.length - 1 ||
                  (Y.usegradedelevation && aE >= ah[aj].endind + 1)
                ) {
                  aC = z.findhillcolor(ah[aj].percent);
                  if (!Y.usegradedelevation) {
                    aC = "#" + z.hillcolors[ah[aj].thetypeint + 1];
                    if (ah[aj].thetypeint != 0) {
                      if (
                        Math.abs(Y.hillsegments[aj].percent) >= 3 &&
                        Y.hillsegments[aj].thelength >= 65
                      ) {
                        if (af.printspecial) {
                          thistxt =
                            " " +
                            Y.hillsegments[aj].percent +
                            " % \n " +
                            parseInt(Y.hillsegments[aj].thelength / 10) * 10 +
                            " m\n" +
                            parseInt(Y.hillsegments[aj].theelediff) +
                            " m";
                        } else {
                          thistxt =
                            " " +
                            Y.hillsegments[aj].percent +
                            " % \n " +
                            parseInt(Y.hillsegments[aj].thelength / 10) * 10 +
                            " m\n" +
                            parseInt(Y.hillsegments[aj].theelediff) +
                            " m";
                        }
                        S.push([(aL + ac) / 2 / 1000, 0, thistxt]);
                      }
                    }
                  } else {
                    if (0) {
                      var ai = (ah[aj].startind + ah[aj].endind) / 2;
                      if (al < Y.hillsegments.length) {
                        var N =
                          (Y.hillsegments[al].startind +
                            Y.hillsegments[al].endind) /
                          2;
                        if (ai >= N) {
                          if (Y.hillsegments[al].thetypeint != 0) {
                            thistxt =
                              " " +
                              Y.hillsegments[al].percent +
                              " % \n " +
                              parseInt(Y.hillsegments[al].thelength / 10) * 10 +
                              " m\n" +
                              parseInt(Y.hillsegments[al].theelediff) +
                              " m";
                            S.push([(aL + ac) / 2 / 1000, 0, thistxt]);
                          }
                          al++;
                        }
                      }
                    }
                  }
                  aj++;
                  make_division = 1;
                }
              }
            }
            if (make_division) {
              var ae = O[O.length - 1];
              ax.push(O);
              ay.push({ color: aC, fill: true });
              O = new Array();
              O.push(ae);
              aJ++;
              ac = aL;
              aa = ele;
            }
          }
          prevlat = aw;
          prevlng = an;
          O.push([aL / 1000, ele]);
          if (ele < aB) {
            aB = ele;
          }
          if (ele > aK) {
            aK = ele;
          }
        }
      }
      az.push(aL / 1000);
    }
    var Z;
    var aF;
    var aA;
    var aq;
    var au = af.pxpermeter_y;
    var av = af.pxpermeter_x;
    var ag = af.scaletxt;
    if (af.eleplot_scalefactor != 1) {
      au = af.pxpermeter_y * af.eleplot_scalefactor;
      av = af.pxpermeter_x * af.eleplot_scalefactor;
      ag = af.scaletxtx * af.eleplot_scalefactor;
    }
    var aG = new Array();
    if (O.length > 0 || ax.length > 0) {
      if (!af.printspecial) {
        Z = Math.ceil(aK / af.ydivpermeter) * af.ydivpermeter;
        aF = Math.floor(aB / af.ydivpermeter) * af.ydivpermeter;
        aA = parseInt(aK + (aK - aB) / 2);
        aq = parseInt(aB - (aK - aB) / 2);
      } else {
        Z = Math.ceil(aK / af.ydivpermeter) * af.ydivpermeter;
        aF = Math.floor(aB / af.ydivpermeter) * af.ydivpermeter;
        if (Z - aF < af.minheight) {
          Z = aF + af.minheight;
        }
        aA = parseInt(Z + (aK - aB) / 2);
        aq = parseInt(aF - (aK - aB) / 2);
        if (af.scaled_eleplot & af.printspecial) {
          var W = parseInt(af.px_extra_y + au * (Z - aF));
          $("#" + ar).height(W);
          var M = parseInt(af.px_extra_x + av * aL);
          $("#" + ar).width(M);
        }
      }
      for (var aI = aF; aI <= Z; aI = aI + af.ydivpermeter) {
        aG.push(aI);
      }
      if (O.length > 0) {
        ax.push(O);
        if (T) {
          ay.push({ color: "#777", fill: true });
        } else {
          if (ay.length) {
            aC = ay[ay.length - 1].color;
          } else {
            aC = z.segcolors[aJ];
          }
          ay.push({ color: aC, fill: true });
        }
      }
      if (ad == 2 && ah && Y.usegradedelevation) {
        var ah = Y.hillsegments;
        for (var aH = 0; aH < ah.length; aH++) {
          var U = ah[aH];
          if (
            Math.abs(Y.hillsegments[aH].percent) >= 4 &&
            Y.hillsegments[aH].thelength >= 65
          ) {
            var ab = [
              [U.startdist / 1000, aF + 2],
              [U.startdist / 1000 + U.thelength / 1000, aF + 2],
            ];
            var aC = z.hillcolors[ah[aH].thetypeint + 1];
            ax.push(ab);
            ay.push({
              color: "#" + aC,
              fill: false,
              markerOptions: { size: 6 },
            });
            thistxt =
              " " +
              Y.hillsegments[aH].percent +
              "% \n " +
              parseInt(Y.hillsegments[aH].thelength / 10) * 10 +
              " m\n" +
              parseInt(Y.hillsegments[aH].theelediff) +
              " m";
            S.push([
              U.startdist / 1000 + U.thelength / 1000 / 2,
              aF + 2,
              thistxt,
            ]);
          }
        }
      }
      if (
        S.length > 0 &&
        z.printgraph == 0 &&
        (z.settings.courseprofileshowgrade || af.alwaysshowgrade)
      ) {
        ax.push(S);
        ay.push({
          showLine: false,
          fill: false,
          showMarker: false,
          pointLabels: {
            show: true,
            location: "c",
            xpadding: 0,
            ypadding: -10,
            color: "#ffffff",
          },
        });
      }
      for (var aI = 0; aI < z.courseinfo.splitpos.length; aI++) {
        var X = Y.distarray[z.courseinfo.splitpos[aI]] / 1000;
        ax.push([
          [X, aq],
          [X, aA],
        ]);
        ay.push({ color: "#008800" });
      }
      for (var aI = 1; aI < az.length - 1; aI++) {
        ax.push([
          [az[aI], aq],
          [az[aI], aA],
        ]);
      }
      if (Y.shorthillsegments && Y.usegradedelevation) {
        $("#" + ar).html("");
        Q = $.jqplot(ar, ax, {
          seriesDefaults: { color: "#" + Y.distmarkercol },
          title: "Elevation",
          axes: {
            yaxis: { min: aF, max: Z, tickOptions: { formatString: "%d m" } },
            xaxis: {
              min: 0,
              max: aL,
              ticks: az,
              tickOptions: { formatString: "%.1f km" },
            },
          },
          series: ay,
          highlighter: {
            show: true,
            sizeAdjust: 7.5,
            bringSeriesToFront: false,
            tooltipContentEditor: function (aQ, aN, aS, aP) {
              var aT = mapviewer.courseinfo.shorthillsegments[aN];
              var aQ;
              if (aT) {
                var aS = aT.startind;
                var aO = z.coursecoords[aS];
                var aU = aO.split(",");
                var aM = aU[0];
                var aR = aU[1];
                z.visualize_point = new Object();
                z.visualize_point.x = aM;
                z.visualize_point.y = aR;
                z.move_mapxy_to_center(aM, aR);
                z.request_redraw();
                setTimeout("mapviewer.visualize_point=null;", 1000);
                aQ =
                  '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>' +
                  parseInt(aT.startdist / 100) / 10 +
                  " km</td></tr> <tr><td>Grade:</td><td>" +
                  aT.percent +
                  " %</td></tr></table>";
              } else {
                aQ = "-";
              }
              return aQ;
            },
          },
          canvasOverlay: {
            show: true,
            objects: [
              {
                verticalLine: {
                  name: "posline",
                  x: 0.3,
                  lineWidth: 6,
                  color: "#000000",
                  shadow: true,
                  show: false,
                },
              },
            ],
          },
        });
      } else {
        $("#" + ar).html("");
        if (af.printspecial) {
          thetitle = "";
        } else {
          thetitle = "Elevation";
        }
        Q = $.jqplot(ar, ax, {
          seriesDefaults: { color: "#" + Y.distmarkercol, lineWidth: 1 },
          title: thetitle,
          axes: {
            yaxis: {
              min: aF,
              max: Z,
              ticks: aG,
              tickOptions: { formatString: "%d m" },
            },
            xaxis: {
              min: 0,
              max: aL,
              ticks: az,
              tickOptions: { formatString: "%.1f km" },
            },
          },
          series: ay,
          highlighter: {
            show: true,
            sizeAdjust: 7.5,
            bringSeriesToFront: false,
            tooltipContentEditor: function (aR, aO, aT, aQ) {
              var aV = mapviewer.courseinfo.hillsegments[aO];
              if (aV) {
                var aM = z.coursecoords[0];
                var aU = aM.split(",");
                am = parseFloat(aU[2]);
                var aT = aV.startind + aT;
                z.showgraphpos(aT);
                var aP = z.coursecoords[aT];
                var aW = aP.split(",");
                var aN = aW[0];
                var aS = aW[1];
                ele = parseFloat(aW[2]) - am;
                z.visualize_point = new Object();
                z.visualize_point.x = aN;
                z.visualize_point.y = aS;
                z.move_mapxy_to_center(aN, aS);
                z.request_redraw();
                setTimeout("mapviewer.visualize_point=null;", 1000);
                aR =
                  '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>' +
                  aR +
                  "</td></tr> <tr><td>Grade:</td><td>" +
                  aV.percent +
                  " %</td></tr><tr><td>Point:</td><td>" +
                  aT +
                  "/" +
                  ele +
                  "</td></tr></table>";
              } else {
                aR = "-";
              }
              return aR;
            },
          },
          canvasOverlay: {
            show: true,
            objects: [
              {
                verticalLine: {
                  name: "posline",
                  x: 0.3,
                  lineWidth: 6,
                  color: "#000000",
                  shadow: true,
                  show: false,
                },
              },
            ],
          },
        });
        $("#" + ar).unbind("jqplotDataClick");
        $("#" + ar).bind("jqplotDataClick", function (aT, aO, aU, aP) {
          tmptmp4 = aT;
          if (aT.target.id == "plotdialog") {
            var aM = z.courseinfo.numlaps;
            var aQ = new Object();
            aQ.coursecoords = z.courseeditor_data.coursecoords;
            var aN = jQuery.extend(true, {}, aQ);
            z.coursecoords = aN.coursecoords;
            z.courseinfo = jQuery.extend(
              true,
              {},
              z.courseeditor_data.courseinfo
            );
            z.courseinfo.numlaps = aM;
            var aR;
            if ($("#eleprofileClickSelector")) {
              if ($("#eleprofileClickSelector").val()) {
                aR = $("#eleprofileClickSelector").val();
              }
            }
            if (!aR) {
              aR = "segmentborder";
            }
            var aV = mapviewer.courseinfo.hillsegments[aO];
            if (aV) {
              aU = aV.startind + aU;
              if (aR == "segmenttype") {
                z.hillsegments_changetype(aU);
              } else {
                if (aR == "segmentborder") {
                  z.hillsegments_change_separator(aU);
                } else {
                  if (aR == "splittimes") {
                    var aW = 0;
                    for (var aS = 0; aS < z.courseinfo.splitpos.length; aS++) {
                      if (aU == z.courseinfo.splitpos[aS]) {
                        aW = 1;
                        z.courseinfo.splitpos.splice(aS, 1);
                      }
                    }
                    if (!aW) {
                      z.courseinfo.splitpos.push(aU);
                    }
                    z.courseinfo.splitpos.sort(function (aY, aX) {
                      return aY > aX;
                    });
                  }
                }
              }
              var aQ = new Object();
              aQ.coursecoords = z.coursecoords;
              var aN = jQuery.extend(true, {}, aQ);
              z.courseeditor_data = new Object();
              z.courseeditor_data.courseinfo = jQuery.extend(
                true,
                {},
                z.courseinfo
              );
              z.courseeditor_data.coursecoords = aN.coursecoords;
              var aQ = z.ploteleprofile("#" + aT.target.id);
              z.hillsegments_combine_segments(z.courseinfo.numlaps);
            } else {
            }
          }
        });
      }
      if (af.printspecial) {
        $("#" + ar + " .jqplot-point-label").css("color", "#000000");
        $("#" + ar + " .jqplot-point-label").css(
          "font-size",
          Math.floor(12 * ag) + "px"
        );
        $("#" + ar + " .jqplot-point-label").css(
          "width",
          Math.floor(35 * ag) + "px"
        );
        $("#" + ar + " .jqplot-point-label").css("font-weight", "bold");
        $("#" + ar + " .jqplot-point-label").css("line-height", "1.1");
        $("#" + ar + " .jqplot-point-label").css("border", "1px solid #666");
        $("#" + ar + " .jqplot-point-label").css("background", "#ffffff");
        $("#" + ar + " .jqplot-point-label").css("opacity", 0.6);
        $("#" + ar + " .jqplot-point-label").css("padding-left", "2px");
        $("#" + ar + " .jqplot-point-label").css("padding-right", "2px");
      } else {
        $("#" + ar + " .jqplot-point-label").css("color", "#000000");
        $("#" + ar + " .jqplot-point-label").css("font-size", "12px");
        $("#" + ar + " .jqplot-point-label").css("width", "35px");
        $("#" + ar + " .jqplot-point-label").css("font-weight", "bold");
        $("#" + ar + " .jqplot-point-label").css("line-height", "1.2");
        $("#" + ar + " .jqplot-point-label").css("border", "1px solid black");
        $("#" + ar + " .jqplot-point-label").css("background", "#cccccc");
        $("#" + ar + " .jqplot-point-label").css("opacity", 0.5);
        $("#" + ar + " .jqplot-point-label").css("padding-left", "2px");
        $("#" + ar + " .jqplot-point-label").css("padding-right", "2px");
      }
      $("#" + ar).unbind("jqplotClick");
      $("#" + ar).unbind("jqplotMouseDown");
      $("#" + ar).bind("jqplotMouseDown", function (aO, aN, aR, aQ, aP) {
        var aM = aR.xaxis;
        var aS = aR.yaxis;
      });
    } else {
      $("#" + ar).html(
        "<center><font size=1 color=#999>No data to plot</font></center>"
      );
    }
    return Q;
  };
  this.ploteleprofile_old_worked = function (an) {
    var O = null;
    an = an.substr(1);
    var W;
    var ag;
    W = z.courseinfo;
    ag = z.coursecoords;
    var ad = W.hillsegments;
    if (W.usegradedelevation && W.shorthillsegments) {
      ad = W.shorthillsegments;
    }
    var N = new Array();
    var at = new Array();
    at.push(0);
    var aD = -1e99;
    var av = 1e99;
    var ab = W.coursecolortype;
    var ak = W.eachdistmark;
    var S;
    if (ab == 0) {
      S = 1;
    } else {
      S = 0;
    }
    var af = 0;
    var aq = new Array();
    var ar = new Array();
    var R = new Array();
    if (ag) {
      var al = ag;
      if (al.length > 1) {
        var aE = 0;
        var aC = 0;
        var ai;
        var aa = 0;
        var Y = 0;
        var ao = ak;
        var ah = 0;
        for (var ay = 0; ay < al.length; ay++) {
          var Q = al[ay].split(",");
          x1 = Q[0];
          y1 = Q[1];
          ele = parseFloat(Q[2]);
          orgdist = parseFloat(Q[3]);
          if (!ele) {
            ele = 0;
          }
          if (ay == 0) {
            ai = parseFloat(ele);
          }
          ele = parseFloat(ele) - ai;
          var U = z.map.tolatlng(x1, y1);
          var ap = U.lat;
          var aj = U.lng;
          if (ay > 0) {
            make_division = 0;
            d = calcdistance(prevlat, prevlng, ap, aj);
            aE = aE + d;
            if (orgdist) {
              aE = orgdist;
            }
            if (aE >= ao) {
              var ax = parseInt(ao / 100) / 10 + " km";
              at.push(ao / 1000);
              ao = ao + ak;
              if (!S && ab == 1) {
                make_division = 1;
                aw = z.segcolors[aC];
              }
            }
            if (ab == 2 && ad) {
              if (ad[af]) {
                if (
                  (!W.usegradedelevation && ay >= ad[af].endind + 1) ||
                  ay == al.length - 1 ||
                  (W.usegradedelevation && ay >= ad[af].endind + 1)
                ) {
                  aw = z.findhillcolor(ad[af].percent);
                  if (!W.usegradedelevation) {
                    aw = "#" + z.hillcolors[ad[af].thetypeint + 1];
                    if (ad[af].thetypeint != 0) {
                      if (
                        Math.abs(W.hillsegments[af].percent) >= 3 &&
                        W.hillsegments[af].thelength >= 65
                      ) {
                        thistxt =
                          " " +
                          W.hillsegments[af].percent +
                          " % \n " +
                          parseInt(W.hillsegments[af].thelength / 10) * 10 +
                          " m\n" +
                          parseInt(W.hillsegments[af].theelediff) +
                          " m";
                        R.push([(aE + aa) / 2 / 1000, 0, thistxt]);
                      }
                    }
                  } else {
                    if (0) {
                      var ae = (ad[af].startind + ad[af].endind) / 2;
                      if (ah < W.hillsegments.length) {
                        var M =
                          (W.hillsegments[ah].startind +
                            W.hillsegments[ah].endind) /
                          2;
                        if (ae >= M) {
                          if (W.hillsegments[ah].thetypeint != 0) {
                            thistxt =
                              " " +
                              W.hillsegments[ah].percent +
                              " % \n " +
                              parseInt(W.hillsegments[ah].thelength / 10) * 10 +
                              " m\n" +
                              parseInt(W.hillsegments[ah].theelediff) +
                              " m";
                            R.push([(aE + aa) / 2 / 1000, 0, thistxt]);
                          }
                          ah++;
                        }
                      }
                    }
                  }
                  af++;
                  make_division = 1;
                }
              }
            }
            if (make_division) {
              var ac = N[N.length - 1];
              aq.push(N);
              ar.push({ color: aw, fill: true });
              N = new Array();
              N.push(ac);
              aC++;
              aa = aE;
              Y = ele;
            }
          }
          prevlat = ap;
          prevlng = aj;
          N.push([aE / 1000, ele]);
          if (ele < av) {
            av = ele;
          }
          if (ele > aD) {
            aD = ele;
          }
        }
      }
      at.push(aE / 1000);
    }
    if (N.length > 0 || aq.length > 0) {
      var X = parseInt(aD + (aD - av) / 10);
      var az = parseInt(av - (aD - av) / 10);
      var au = parseInt(aD + (aD - av) / 2);
      var am = parseInt(av - (aD - av) / 2);
      if (N.length > 0) {
        aq.push(N);
        if (S) {
          ar.push({ color: "#777", fill: true });
        } else {
          if (ar.length) {
            aw = ar[ar.length - 1].color;
          } else {
            aw = z.segcolors[aC];
          }
          ar.push({ color: aw, fill: true });
        }
      }
      if (ab == 2 && ad && W.usegradedelevation) {
        var ad = W.hillsegments;
        for (var aB = 0; aB < ad.length; aB++) {
          var T = ad[aB];
          if (
            Math.abs(W.hillsegments[aB].percent) >= 4 &&
            W.hillsegments[aB].thelength >= 65
          ) {
            var Z = [
              [T.startdist / 1000, az + 2],
              [T.startdist / 1000 + T.thelength / 1000, az + 2],
            ];
            var aw = z.hillcolors[ad[aB].thetypeint + 1];
            aq.push(Z);
            ar.push({
              color: "#" + aw,
              fill: false,
              markerOptions: { size: 6 },
            });
            thistxt =
              " " +
              W.hillsegments[aB].percent +
              " % \n " +
              parseInt(W.hillsegments[aB].thelength / 10) * 10 +
              " m\n" +
              parseInt(W.hillsegments[aB].theelediff) +
              " m";
            R.push([
              T.startdist / 1000 + T.thelength / 1000 / 2,
              az + 2,
              thistxt,
            ]);
          }
        }
      }
      if (
        R.length > 0 &&
        z.printgraph == 0 &&
        z.settings.courseprofileshowgrade
      ) {
        aq.push(R);
        ar.push({
          showLine: false,
          fill: false,
          showMarker: false,
          pointLabels: {
            show: true,
            location: "c",
            xpadding: 0,
            ypadding: -10,
            color: "#ffffff",
          },
        });
      }
      for (var aA = 0; aA < z.courseinfo.splitpos.length; aA++) {
        var V = W.distarray[z.courseinfo.splitpos[aA]] / 1000;
        aq.push([
          [V, am],
          [V, au],
        ]);
        ar.push({ color: "#008800" });
      }
      for (var aA = 1; aA < at.length - 1; aA++) {
        aq.push([
          [at[aA], am],
          [at[aA], au],
        ]);
      }
      if (W.shorthillsegments && W.usegradedelevation) {
        $("#" + an).html("");
        O = $.jqplot(an, aq, {
          seriesDefaults: { color: "#" + W.distmarkercol },
          title: "Elevation",
          axes: {
            yaxis: { min: az, max: X, tickOptions: { formatString: "%d m" } },
            xaxis: {
              min: 0,
              max: aE,
              ticks: at,
              tickOptions: { formatString: "%.1f km" },
            },
          },
          series: ar,
          highlighter: {
            show: true,
            sizeAdjust: 7.5,
            bringSeriesToFront: false,
            tooltipContentEditor: function (aJ, aG, aL, aI) {
              var aM = mapviewer.courseinfo.shorthillsegments[aG];
              var aJ;
              if (aM) {
                var aL = aM.startind;
                var aH = z.coursecoords[aL];
                var aN = aH.split(",");
                var aF = aN[0];
                var aK = aN[1];
                z.visualize_point = new Object();
                z.visualize_point.x = aF;
                z.visualize_point.y = aK;
                z.move_mapxy_to_center(aF, aK);
                z.request_redraw();
                setTimeout("mapviewer.visualize_point=null;", 1000);
                aJ =
                  '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>' +
                  parseInt(aM.startdist / 100) / 10 +
                  " km</td></tr> <tr><td>Grade:</td><td>" +
                  aM.percent +
                  " %</td></tr></table>";
              } else {
                aJ = "-";
              }
              return aJ;
            },
          },
          canvasOverlay: {
            show: true,
            objects: [
              {
                verticalLine: {
                  name: "posline",
                  x: 0.3,
                  lineWidth: 6,
                  color: "#000000",
                  shadow: true,
                  show: false,
                },
              },
            ],
          },
        });
      } else {
        $("#" + an).html("");
        O = $.jqplot(an, aq, {
          seriesDefaults: { color: "#" + W.distmarkercol },
          title: "Elevation",
          axes: {
            yaxis: { min: az, max: X, tickOptions: { formatString: "%d m" } },
            xaxis: {
              min: 0,
              max: aE,
              ticks: at,
              tickOptions: { formatString: "%.1f km" },
            },
          },
          series: ar,
          highlighter: {
            show: true,
            sizeAdjust: 7.5,
            bringSeriesToFront: false,
            tooltipContentEditor: function (aK, aH, aM, aJ) {
              var aO = mapviewer.courseinfo.hillsegments[aH];
              if (aO) {
                var aF = z.coursecoords[0];
                var aN = aF.split(",");
                ai = parseFloat(aN[2]);
                var aM = aO.startind + aM;
                z.showgraphpos(aM);
                var aI = z.coursecoords[aM];
                var aP = aI.split(",");
                var aG = aP[0];
                var aL = aP[1];
                ele = parseFloat(aP[2]) - ai;
                z.visualize_point = new Object();
                z.visualize_point.x = aG;
                z.visualize_point.y = aL;
                z.move_mapxy_to_center(aG, aL);
                z.request_redraw();
                setTimeout("mapviewer.visualize_point=null;", 1000);
                aK =
                  '<table class="jqplot-highlighter"> <tr><td>Pos:</td><td>' +
                  aK +
                  "</td></tr> <tr><td>Grade:</td><td>" +
                  aO.percent +
                  " %</td></tr><tr><td>Point:</td><td>" +
                  aM +
                  "/" +
                  ele +
                  "</td></tr></table>";
              } else {
                aK = "-";
              }
              return aK;
            },
          },
          canvasOverlay: {
            show: true,
            objects: [
              {
                verticalLine: {
                  name: "posline",
                  x: 0.3,
                  lineWidth: 6,
                  color: "#000000",
                  shadow: true,
                  show: false,
                },
              },
            ],
          },
        });
        $("#" + an).unbind("jqplotDataClick");
        $("#" + an).bind("jqplotDataClick", function (aM, aH, aN, aI) {
          tmptmp4 = aM;
          if (aM.target.id == "plotdialog") {
            var aF = z.courseinfo.numlaps;
            var aJ = new Object();
            aJ.coursecoords = z.courseeditor_data.coursecoords;
            var aG = jQuery.extend(true, {}, aJ);
            z.coursecoords = aG.coursecoords;
            z.courseinfo = jQuery.extend(
              true,
              {},
              z.courseeditor_data.courseinfo
            );
            z.courseinfo.numlaps = aF;
            var aK;
            if ($("#eleprofileClickSelector")) {
              if ($("#eleprofileClickSelector").val()) {
                aK = $("#eleprofileClickSelector").val();
              }
            }
            if (!aK) {
              aK = "segmentborder";
            }
            var aO = mapviewer.courseinfo.hillsegments[aH];
            if (aO) {
              aN = aO.startind + aN;
              if (aK == "segmenttype") {
                z.hillsegments_changetype(aN);
              } else {
                if (aK == "segmentborder") {
                  z.hillsegments_change_separator(aN);
                } else {
                  if (aK == "splittimes") {
                    var aP = 0;
                    for (var aL = 0; aL < z.courseinfo.splitpos.length; aL++) {
                      if (aN == z.courseinfo.splitpos[aL]) {
                        aP = 1;
                        z.courseinfo.splitpos.splice(aL, 1);
                      }
                    }
                    if (!aP) {
                      z.courseinfo.splitpos.push(aN);
                    }
                    z.courseinfo.splitpos.sort(function (aR, aQ) {
                      return aR > aQ;
                    });
                  }
                }
              }
              var aJ = new Object();
              aJ.coursecoords = z.coursecoords;
              var aG = jQuery.extend(true, {}, aJ);
              z.courseeditor_data = new Object();
              z.courseeditor_data.courseinfo = jQuery.extend(
                true,
                {},
                z.courseinfo
              );
              z.courseeditor_data.coursecoords = aG.coursecoords;
              var aJ = z.ploteleprofile("#" + aM.target.id);
              z.hillsegments_combine_segments(z.courseinfo.numlaps);
            } else {
            }
          }
        });
      }
      $("#" + an + " .jqplot-point-label").css("color", "#000000");
      $("#" + an + " .jqplot-point-label").css("font-size", "12px");
      $("#" + an + " .jqplot-point-label").css("width", "35px");
      $("#" + an + " .jqplot-point-label").css("font-weight", "bold");
      $("#" + an + " .jqplot-point-label").css("line-height", "1.2");
      $("#" + an + " .jqplot-point-label").css("border", "1px solid black");
      $("#" + an + " .jqplot-point-label").css("background", "#cccccc");
      $("#" + an + " .jqplot-point-label").css("opacity", 0.5);
      $("#" + an + " .jqplot-point-label").css("padding-left", "2px");
      $("#" + an + " .jqplot-point-label").css("padding-right", "2px");
      $("#" + an).unbind("jqplotClick");
      $("#" + an).unbind("jqplotMouseDown");
      $("#" + an).bind("jqplotMouseDown", function (aH, aG, aK, aJ, aI) {
        var aF = aK.xaxis;
        var aL = aK.yaxis;
      });
    } else {
      $("#" + an).html(
        "<center><font size=1 color=#999>No data to plot</font></center>"
      );
    }
    return O;
  };
  this.findhillcolor = function (R, O) {
    var N = 5;
    var Q = parseInt(Math.abs(R) / N) + 1;
    var M;
    if (Q > 5) {
      Q = 5;
    }
    if (R == 0) {
      Q = 0;
    }
    if (R > 0) {
      M = z.gradedhillcolorsup[Q];
    } else {
      M = z.gradedhillcolorsdown[Q];
    }
    return M;
  };
  this.seteleprofile = function (T, U, Q, V) {
    if (!V) {
      V = 9999;
    }
    if (!Q) {
      Q = 0;
    }
    if (U == "end") {
      U = z.coursecoords.length - 1;
    }
    var N = z.coursecoords[0];
    var W = N.split(",");
    ele0 = parseFloat(W[2]);
    if (V == 9999) {
      var N = z.coursecoords[T];
      var W = N.split(",");
      V = parseFloat(W[2]) - ele0;
    }
    for (var M = T; M <= U; M++) {
      var N = z.coursecoords[M];
      var W = N.split(",");
      var O = z.map.tolatlng(parseFloat(W[0]), parseFloat(W[1]));
      var R = O.lat;
      var S = O.lng;
      if (M > T && Q != 0) {
        d = calcdistance(prevlat, prevlng, R, S);
        diff = (Q / 100) * d;
        V = V + diff;
      }
      prevlat = R;
      prevlng = S;
      W[2] = V + ele0;
      z.coursecoords[M] = W.join(",");
    }
    mapviewer.findhills_eleprofile();
  };
  this.drawcourse = function () {
    var aA = z.segcolors[0];
    if (this.coursecoords) {
      if (z.settings.showcourse >= 2) {
        coursewidth = z.settings.routewidth * z.courseinfo.routewidthfactor;
        var al = this.coursecoords;
        var O = 0;
        var aP = z.courseinfo.arrowspacing;
        var Z = z.courseinfo.coursecolortype;
        var ak = z.courseinfo.eachdistmark;
        var O = 0;
        if (Z == 0) {
          O = 1;
        }
        if (al.length > 1) {
          var af = z.courseinfo.hillsegments;
          if (
            this.courseinfo.usegradedelevation &&
            z.courseinfo.shorthillsegments
          ) {
            af = z.courseinfo.shorthillsegments;
          }
          if (O) {
            z.canvas.setLineStyle(
              "0000ff",
              z.settings.routeopacity,
              coursewidth
            );
            z.canvas.drawPoly(al.join(" "));
          }
          var aL = 0;
          var ar = ak;
          if (aP > 0) {
            nextarrow = aP;
          } else {
            nextarrow = 1e99;
          }
          var Q = "";
          var ah = 0;
          var ai = 0;
          var S = new Array();
          for (var aH = 0; aH < al.length; aH++) {
            var N = al[aH].split(",");
            V = N[0];
            aO = N[1];
            Q = Q + V + "," + aO + " ";
            if (z.courseinfo.showdistmarkers) {
              var R = z.map.tolatlng(V, aO);
              var au = R.lat;
              var aj = R.lng;
              if (aH > 0) {
                var ag = 0;
                d = calcdistance(prevlat, prevlng, au, aj);
                aL = aL + d;
                if (aL >= ar) {
                  var aG = parseInt(ar / 100) / 10 + " km";
                  S.push(V + "," + aO + "," + aG);
                  ar = ar + ak;
                  if (!O && Z == 1) {
                    ag = 1;
                    aA = z.segcolors[ah];
                  }
                }
                if (Z == 2 && z.courseinfo.hillsegments) {
                  if (af[ai]) {
                    if (aH >= af[ai].endind) {
                      aA = z.findhillcolor(af[ai].percent);
                      if (!this.courseinfo.usegradedelevation) {
                        aA = z.hillcolors[af[ai].thetypeint + 1];
                      }
                      ai++;
                      ag = 1;
                    }
                  }
                }
                if (ag) {
                  z.canvas.setLineStyle(
                    aA,
                    z.settings.routeopacity,
                    coursewidth
                  );
                  z.canvas.drawPoly(Q);
                  Q = V + "," + aO + " ";
                  ah++;
                }
                if (z.settings.coursedefinition_mode) {
                } else {
                  if (aL >= nextarrow) {
                    nextarrow = nextarrow + aP;
                    var aq = al[aH - 1].split(",");
                    var ay = aq[0];
                    var ax = aq[1];
                    var ad = (Math.atan2(V - ay, aO - ax) * 180) / 3.1415926;
                    z.canvas.setLineStyle(
                      "000000",
                      z.settings.routeopacity,
                      coursewidth / 2
                    );
                    z.canvas.drawArrow(
                      V,
                      aO,
                      coursewidth * 3.5 * z.settings.arrowmult,
                      ad
                    );
                  }
                }
              }
              prevlat = au;
              prevlng = aj;
            }
            if (
              z.settings.coursedefinition_mode >= 1 &&
              z.settings.coursedefinition_mode <= 2
            ) {
              courseradius = coursewidth * 2;
              z.canvas.setLineStyle(
                "ff0000",
                z.settings.routeopacity,
                coursewidth
              );
              z.canvas.drawCircle(V, aO, courseradius);
            }
          }
          if (!O && Q.length > 1) {
            z.canvas.setLineStyle(aA, z.settings.routeopacity, coursewidth);
            z.canvas.drawPoly(Q);
          }
          courseradius = coursewidth * 2;
          for (var aH = 0; aH < S.length; aH++) {
            var aF = S[aH].split(",");
            var V = aF[0];
            var aO = aF[1];
            var aG = aF[2];
            z.canvas.setLineStyle(
              z.courseinfo.distmarkercol,
              z.settings.routeopacity,
              coursewidth
            );
            z.canvas.drawCircle(V, aO, courseradius / 2);
            if (z.canvas.zoomfactor > 0.2) {
              z.canvas.writeTextOutlined(
                parseFloat(V) + parseFloat(coursewidth) / z.canvas.zoomfactor,
                parseFloat(aO) -
                  parseFloat(coursewidth) / 2 / z.canvas.zoomfactor,
                "000000",
                aG
              );
            }
          }
        }
        if (z.courseinfo) {
          if (z.courseinfo.biathlonvariables) {
            var az = 12;
            z.canvas.setLineStyle(
              "000000",
              z.settings.routeopacity,
              coursewidth
            );
            var aD = z.courseinfo.biathlonvariables.intorange;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
            var aD = z.courseinfo.biathlonvariables.outofrange;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
            var aD = z.courseinfo.biathlonvariables.afterpenalty;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
            var aD = z.courseinfo.biathlonvariables.inpenalty;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
            var aD = z.courseinfo.biathlonvariables.beforerange;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
            var aD = z.courseinfo.biathlonvariables.oncourse;
            if (aD) {
              var aq = z.map.toxy(aD.lat, aD.lng);
              z.canvas.drawCircle(aq.x, aq.y, az);
            }
          }
        }
      } else {
        coursewidth = z.settings.routewidth * z.courseinfo.routewidthfactor * 2;
        var an = 0;
        var al = z.coursecoords;
        if (z.settings.analyzecourse) {
          if (z.settings.centerlegnum) {
            al = new Array();
            al.push(z.coursecoords[parseInt(z.settings.centerlegnum) - 1]);
            al.push(z.coursecoords[parseInt(z.settings.centerlegnum)]);
            an = 1;
          }
        }
        z.settings.drawsingleleg = 1;
        if (z.settings.drawsingleleg && !an) {
          var at = new Array();
          var ap = new Array();
          var ao = new Array();
          ap[0] = z.settings.lastclick_x;
          ao[0] = z.settings.lastclick_y;
          ap[1] = z.settings.thisclick_x;
          ao[1] = z.settings.thisclick_y;
          var aJ = 0;
          var M = 50;
          for (var aK = 0; aK < z.coursecoords.length; aK++) {
            var aq = al[aK].split(",");
            var aN = aq[0];
            var aM = aq[1];
            var am =
              (aN - ap[aJ]) * (aN - ap[aJ]) + (aM - ao[aJ]) * (aM - ao[aJ]);
            if (am < M) {
              at.push(al[aK]);
              aJ++;
              if (aJ == 2 && prevfound == aK - 1) {
                aK = z.coursecoords.length + 1;
              } else {
                if (aJ == 2) {
                  aJ = 1;
                  at = new Array();
                  at.push(al[aK]);
                }
              }
              prevfound = aK;
            }
          }
          if (aJ == 2) {
            al = at;
            an = 1;
          }
        }
        var aC = this.settings.controlRadius;
        var ae = this.settings.controlRadius * 0.7;
        if (z.settings.corridoranalysis) {
          var ac = z.map.tolatlng(0, 0);
          var ab = z.map.tolatlng(0, z.settings.corridorwidth);
          dist = calcdistance(ac.lat, ac.lng, ab.lat, ab.lng);
          aC =
            (z.settings.corridorwidth / 2) * (z.settings.corridorwidth / dist);
          ae = aC * 0.7;
        }
        if (!z.settings.courseopacity) {
          z.settings.courseopacity = 0.8;
        }
        z.canvas.setLineStyle(
          z.settings.coursecolor,
          z.settings.courseopacity,
          4 * mapviewer.canvas.zoomfactor * mapviewer.settings.coursewidthmult
        );
        var ad = 0;
        if (al.length > 0) {
          if (!al[0]) {
            console.log("No control 0");
            return;
          }
          var aq = al[0].split(",");
          var aN = aq[0];
          var aM = aq[1];
          if (al.length > 1) {
            if (al[1]) {
              var aq = al[1].split(",");
              var X = aq[0];
              var W = aq[1];
              ad = (Math.atan2(X - aN, W - aM) * 180) / 3.1415926;
            }
          } else {
            ad = 0;
          }
          if (!an) {
            z.canvas.drawTriangle(aN, aM, aC, ad);
          } else {
            z.canvas.drawCircle(aN, aM, aC);
          }
        }
        if (al.length > 1) {
          var ay = aN;
          var ax = aM;
          for (var aH = 1; aH < al.length; aH++) {
            var aq = al[aH].split(",");
            aN = aq[0];
            aM = aq[1];
            if (z.settings.coursewhitebackground) {
              z.canvas.setLineStyle(
                "ffffff",
                0.3,
                4 *
                  mapviewer.canvas.zoomfactor *
                  mapviewer.settings.coursewidthmult
              );
              z.canvas.drawCircle(aN, aM, aC * 1.05);
              z.canvas.setLineStyle(
                z.settings.coursecolor,
                z.settings.courseopacity,
                4 *
                  mapviewer.canvas.zoomfactor *
                  mapviewer.settings.coursewidthmult
              );
            }
            z.canvas.drawCircle(aN, aM, aC);
            lineoffset = aC * 1.3;
            linelength = Math.sqrt(
              (aN - ay) * (aN - ay) + (aM - ax) * (aM - ax)
            );
            dx = (aN - ay) / linelength;
            dy = (aM - ax) / linelength;
            if (z.settings.showcoursecontrolnumbers) {
              if (aH < al.length - 1) {
                var aa;
                var Y;
                if (z.coursecontrolcoords[aH]) {
                  var aE = z.coursecontrolcoords[aH].split(",");
                  aa = aE[0];
                  Y = aE[1];
                } else {
                  var U = aN - ay;
                  var T = aM - ax;
                  var aB = Math.atan2(T, U);
                  var aq = al[aH + 1].split(",");
                  var X = aq[0];
                  var W = aq[1];
                  var aw = X - aN;
                  var av = W - aM;
                  var aI = Math.atan2(-av, -aw);
                  aa = parseFloat(aN) + (aC + aC) * Math.cos((aB + aI) / 2);
                  Y = parseFloat(aM) + (aC + aC) * Math.sin((aB + aI) / 2);
                  z.coursecontrolcoords[aH] = aa + "," + Y;
                }
                z.canvas.writeTextOutlined(
                  aa,
                  Y,
                  z.settings.coursecolor,
                  aH,
                  z.settings.controlnumberfontsize *
                    mapviewer.canvas.zoomfactor,
                  null,
                  null,
                  "ffffff",
                  "center",
                  0.8
                );
                z.canvas.setLineStyle(
                  z.settings.coursecolor,
                  z.settings.courseopacity,
                  4 *
                    mapviewer.canvas.zoomfactor *
                    mapviewer.settings.coursewidthmult
                );
              }
            }
            if (linelength > 2 * lineoffset) {
              V = ay * 1 + dx * lineoffset;
              aO = ax * 1 + dy * lineoffset;
              x2 = aN * 1 - dx * lineoffset;
              y2 = aM * 1 - dy * lineoffset;
              z.canvas.drawLine(V, aO, x2, y2);
            }
            ay = aN;
            ax = aM;
          }
          if (!an) {
            z.canvas.drawCircle(aN, aM, ae);
          }
        }
      }
    }
  };
  this.expose = function (N, Q) {
    if (!Q) {
      Q = "#rightmenu";
    }
    if (Q == "#rightmenu") {
      $("#rightmenu").css("z-index", 0);
    }
    $("#infobox").find("div.ui-resizable-s").hide();
    var O = $(N);
    if (O) {
      var M = $(Q);
      M.scrollTop(0);
      t = M.offset().top;
      M.scrollTop(O.offset().top - t);
    }
    mapviewer.showexpose = 0;
    $(N).expose({ padding: 20 });
    setTimeout("mapviewer.showexpose=1;", 300);
  };
  this.expose_tooltip = function (O, S) {
    if (!S) {
      S = "#rightmenu";
    }
    var Q = $(O);
    if (Q) {
      var T = Q.offset();
      if (T) {
        if (T.top == 0 && T.left == 0) {
          alert(
            "Check that you are in the correct analysis mode. I can not find the button/menu I wanted to show you"
          );
          return;
        }
      } else {
        alert(
          "Check that you are in the correct analysis mode. I can not find the button/menu I wanted to show you"
        );
        return;
      }
      var M = $(S);
      M.scrollTop(0);
      t = M.offset().top;
      M.scrollTop(Q.offset().top - t);
    }
    if (z.tooltipbinder) {
      if ($(mapviewer.tooltipbinder_last).tooltipster != null) {
        try {
          $(mapviewer.tooltipbinder_last).tooltipster("hide");
        } catch (R) {}
      }
      $(mapviewer.tooltipbinder).attr(
        "title",
        mapviewer.tooltipbinder_lasttitle
      );
      $(window).unbind("click", mapviewer.tooltipbinder);
      mapviewer.tooltipbinder = null;
    }
    var U = Q.attr("title");
    z.tooltipbinder_last = O;
    z.tooltipbinder_lasttitle = U;
    var N = 0;
    if (Q.hasClass("tooltip")) {
      if ($(Q).tooltipster != null) {
        try {
          $(Q).tooltipster("show");
          N = 1;
          z.tooltipbinder = function () {
            if (mapviewer.showexpose) {
              mapviewer.showexpose = 0;
              if ($(mapviewer.tooltipbinder_last).tooltipster != null) {
                $(mapviewer.tooltipbinder_last).tooltipster("hide");
              }
              $(window).unbind("click", mapviewer.tooltipbinder);
              mapviewer.tooltipbinder = null;
            }
          };
          setTimeout("mapviewer.showexpose=1;", 300);
          $(window).bind("click", z.tooltipbinder);
        } catch (R) {}
      }
    }
    z.showexpose = 0;
    if (!N) {
      Q.tooltipster({
        autoClose: true,
        position: "left",
        content: $("<span><strong>Click here to try!</strong></span>"),
      }).tooltipster("show");
      z.tooltipbinder = function () {
        if (mapviewer.showexpose) {
          mapviewer.showexpose = 0;
          if ($(mapviewer.tooltipbinder_last).tooltipster != null) {
            try {
              $(mapviewer.tooltipbinder_last).tooltipster("destroy");
            } catch (V) {}
          }
          $(mapviewer.tooltipbinder_last).attr(
            "title",
            mapviewer.tooltipbinder_lasttitle
          );
          $(window).unbind("click", mapviewer.tooltipbinder);
          mapviewer.tooltipbinder = null;
        }
      };
      setTimeout("mapviewer.showexpose=1;", 300);
      $(window).bind("click", z.tooltipbinder);
    }
  };
  this.wizard_load = function (M) {
    if (!M) {
      M = "intro";
    }
    z.wizard.data_raw = "loading";
    $.ajax({
      url: "wizard.xml?v=" + Math.random(1),
      dataType: "xml",
      success: function (N) {
        z.wizard.data_raw = N;
        z.wizard.bread = new Array();
        $xml = $(N);
        z.wizard.data = new Array();
        z.wizard.buttons = new Array();
        $($xml)
          .find("menu")
          .each(function () {
            var S = $(this).find("id").text();
            var Q = $(this).find("title").text();
            var O = $(this).find("stitle").text();
            var R = new Object();
            R.xml = $(this);
            R.title = Q;
            R.stitle = O;
            z.wizard.data[S] = R;
          });
        $($xml)
          .find("actionbutton")
          .each(function () {
            var T = $(this).find("id").text();
            var S = $(this).find("title").text();
            var Q = $(this).find("stitle").text();
            var R = $(this).find("cmd").text();
            var O = new Object();
            O.xml = $(this);
            O.title = S;
            O.cmd = R;
            O.stitle = Q;
            z.wizard.buttons[T] = O;
          });
        $("#infobox").resizable({
          handles: "s",
          stop: function (T, U) {
            var S = 70;
            $(this).css("width", "");
            var V = 10;
            var O = $("#infobox").height() - $("#topinfo").height() - V;
            if (O < S) {
              O = S;
              var R = 215;
              var Q = $("#topinfo").height() + V + R;
              $("#infobox").height(Q);
              var O = $("#infobox").height() - $("#topinfo").height() - V;
              $("#wizard").css("height", O);
              $("#wizard").show();
              $("#infobox").find("div.ui-resizable-s").hide();
              mapviewer.wizard_start();
            } else {
              $("#wizard").css("height", O);
              $("#wizard").show();
            }
          },
          start: function (O, Q) {
            $("#wizard").hide();
          },
        });
        $("#infobox")
          .find("div.ui-resizable-s")
          .css(
            "background",
            "transparent url(css/resizable-s.gif) repeat scroll center top"
          );
        $("#infobox").find("div.ui-resizable-s").css("z-index", 999);
        $(window).resize(function () {
          if ($(".expose-overlay")) {
            $("#infobox").find("div.ui-resizable-s").show();
            $(".expose-overlay").remove();
          }
        });
        $(window).click(function () {
          if ($(".expose-overlay") && mapviewer.showexpose) {
            $("#infobox").find("div.ui-resizable-s").show();
            $(".expose-overlay").remove();
          }
        });
        $(window).bind("expose:overlay:removed", function (O) {
          if (mapviewer.showexpose) {
            $("#rightmenu").css("z-index", 10);
          }
          mapviewer.showexpose = 0;
        });
        z.wizard_showmenu(M);
      },
      error: function (N) {
        z.wizard.data_raw = "failed";
        alert("Sorry, could not load Guide!");
      },
    });
  };
  this.wizard_paginate = function (Q, T, S) {
    var O = 1;
    var R = $(Q).find("li");
    var M = R.length;
    var N = S;
    R.slice(O).hide();
    $(N).html("Part 1 of " + M);
    $(T).pagination({
      items: M,
      displayedPages: 16,
      itemsOnPage: O,
      cssTheme: "light-theme",
      onPageClick: function (V) {
        var W = O * (V - 1);
        var U = W + O;
        $(N).html("Part " + V + " of " + M);
        R.hide().slice(W, U).show();
      },
    });
  };
  this.wizard_showmenu = function (M) {
    if (!z.wizard.data_raw) {
      if (z.wizard.data_raw == "loading") {
      } else {
        if (z.wizard.data_raw == "failed") {
          alert("Sorry, could not load Guide!");
        } else {
          z.wizard_load(M);
          return;
        }
      }
    }
    if (M == "back") {
      if (z.wizard.bread.length > 0) {
        M = z.wizard.bread.pop();
      }
    } else {
      if (M >= 0 && M <= 100) {
        var S = parseInt(M);
        var M = z.wizard.bread[S];
        if (S < z.wizard.bread.length) {
          z.wizard.bread.splice(S + 1);
        }
      } else {
        z.wizard.bread.push(M);
      }
    }
    if (z.wizard.data[M]) {
      var X = z.wizard.data[M].xml;
      var U = $(X).find("title").text();
      var V = $(X).find("description").text();
      var O = $(X).find("help").text();
      for (var N in z.wizard.buttons) {
        if (z.wizard.buttons.hasOwnProperty(N)) {
          var R = z.wizard.buttons[N];
          var W = z.wizard_showactionbutton(R.title, N, R.cmd, O);
          var T = new RegExp("##" + N + "##", "ig");
          V = V.replace(T, W);
          var T = new RegExp("\\$\\$(.*?)\\$\\$", "ig");
          V = V.replace(
            T,
            '<span class="morebutton" title="$1" href="javascript:void(0)">[more >>]</span>'
          );
          var T = new RegExp("\\|\\|(.*?)//(.*?)//(.*?)\\|\\|", "ig");
          V = V.replace(
            T,
            '<a class="helptext" title="Click to show where" href="javascript:void(0)" onclick="mapviewer.expose_tooltip(\'$2\');$3">$1</a> '
          );
        }
      }
      var Q = "";
      Q += '<div id="wizard-paginate"></div>';
      Q +=
        '<h2 id="wizard-title">' + U + '<span id="wizard-pagenum"></span></h2>';
      Q += '<div id="wizard-intro">' + V + "</div>";
      Q += '<div id="wizard-buttons" class="wbuttons"><ul>';
      $($(X).find("buttons"))
        .find("button")
        .each(function () {
          var Y = $(this).find("btitle").text();
          var Z = $(this).find("bid").text();
          var aa = $(this).find("bhelp").text();
          var ab = $(this).find("bcmd").text();
          Q += z.wizard_showbutton(Y, Z, ab, aa);
        });
      Q += '</ul><div style="clear:both"></div></div>';
    } else {
      Q = "<h2>Guide: " + M + "</h2>";
      Q += "Sorry, this wizard is not finished yet.";
    }
    Q = z.wizard_printbread() + Q;
    $("#wizard").html(Q);
    if (V) {
      if (V.search("<ul>") >= 0) {
        z.wizard_paginate(
          "#wizard-intro",
          "#wizard-paginate",
          "#wizard-pagenum"
        );
      }
    }
    $(".wbutton").tooltipster({
      animation: "fade",
      delay: 100,
      maxWidth: 300,
      position: "bottom",
      trigger: "hover",
    });
    $(".wabutton").tooltipster({
      animation: "fade",
      delay: 100,
      maxWidth: 300,
      position: "bottom",
      trigger: "hover",
    });
    $(".morebutton").tooltipster({
      animation: "fade",
      delay: 100,
      maxWidth: 300,
      position: "bottom",
      trigger: "hover",
    });
    z.wizard_buttonhelp();
  };
  this.wizard_printbread = function () {
    var O = '<div id="wizard-bread"><ul id="crumbs">';
    var M = z.wizard.bread;
    for (var Q = 0; Q < M.length; Q++) {
      var N = M[Q];
      var S = N;
      var R = "";
      if (z.wizard.data[N]) {
        S = z.wizard.data[N].stitle;
      }
      if (Q == M.length - 1) {
        O += "<li>" + S + "</li>";
      } else {
        O +=
          "<li><a href='javascript:void(0);' onclick='mapviewer.wizard_showmenu(\"" +
          Q +
          "\");' " +
          R +
          ">" +
          S +
          "</a></li>";
      }
    }
    O += '</ul></div><div style="clear:both"></div>';
    return O;
  };
  this.wizard_buttonhelp = function () {
    $(".wbutton").hover(
      function () {
        $("#wizard-buttons-help").html($(this).attr("help"));
      },
      function () {
        $("#wizard-buttons-help").html("&nbsp;");
      }
    );
  };
  this.wizard_showbutton = function (M, S, R, N) {
    var O = "";
    var Q = "";
    if (N) {
      Q = " title='" + N + "'";
    }
    O =
      "<li><a href='javascript:void(0);' class=\"wbutton\" onclick='" +
      R +
      "' style='cursor:help' " +
      Q +
      " id='" +
      S +
      "'>" +
      M +
      "</a></li>";
    return O;
  };
  this.wizard_showactionbutton = function (M, S, R, N) {
    var O = "";
    var Q = "";
    if (N) {
      Q = " title='" + N + "'";
    }
    O =
      "<a href='javascript:void(0);'" +
      Q +
      ' class="wabutton" onclick=\'' +
      R +
      "' id='" +
      S +
      "'>" +
      M +
      "</a>";
    return O;
  };
  this.wizard_start = function () {
    if (z.settings.wizardmode == 0) {
      z.settings.wizardmode = 1;
      $("#wizardmodebutt").html("Pause Guide mode");
      $("#" + z.infodiv).height("215px");
      var Q = 10;
      var M = $("#infobox").height() - $("#topinfo").height() - Q;
      $("#" + z.infodiv).append(
        '<div id="wizard" style="position:relative;height:' +
          M +
          'px;margin-top:2px;background:white;border:1px solid black;color:#222222;padding:4px;"></div>'
      );
      this.wizard_showmenu("intro");
    } else {
      if (z.settings.wizardmode == 1) {
        z.settings.wizardmode = 2;
        $("#wizardmodebutt").html("Reopen Guide mode");
        $("#infobox").find("div.ui-resizable-s").hide();
        $("#" + z.infodiv).height("16px");
        $("#wizard").hide();
      } else {
        if (z.settings.wizardmode == 2) {
          z.settings.wizardmode = 1;
          $("#wizardmodebutt").html("Pause Guide mode");
          var O = 215;
          var Q = 10;
          var N = $("#topinfo").height() + Q + $("#wizard").height();
          $("#infobox").height(N);
          $("#infobox").find("div.ui-resizable-s").show();
          $("#wizard").show();
        }
      }
    }
    z.request_redraw();
  };
  this.set_preset = function (M) {
    if (M == "manyroutessplit") {
      z.settings.mapopacity = 0.7;
      z.settings.legendtype = 4;
      z.canvas.outlinetxtsize = 14;
      z.settings.legendinfo = 5;
      z.settings.routewidth = 6;
      z.center_map_on_runner = 1;
      z.settings.autrotanglemode = 4;
      z.request_redraw();
    } else {
      if (M == "highlightroute") {
        z.settings.mapopacity = 0.5;
        z.settings.legendtype = 4;
        z.canvas.outlinetxtsize = 18;
        z.settings.legendinfo = 5;
        z.settings.routewidth = 7;
        z.center_map_on_runner = 0;
        z.settings.autrotanglemode = 4;
        z.request_redraw();
      } else {
        alert("Sorry! This preset setting is not defined");
      }
    }
  };
  this.draw_selected_routeparts = function () {
    var O = z.settings.routeparts;
    for (var R = 0; R < z.settings.routeparts.length; R++) {
      var Q = z.settings.routeparts[R];
      var N = z.routes[Q.rnr];
      var U = Q.start;
      var M = Q.end;
      var T = "";
      this.canvas.setLineStyle(
        N.color,
        this.settings.routeopacity,
        this.settings.routewidth
      );
      for (var S = U; S <= M; S++) {
        lat = N.latarray[S];
        lng = N.lngarray[S];
        P = z.map.toxy(lat, lng);
        thisx = P.x;
        thisy = P.y;
        T += thisx + "," + thisy + " ";
      }
      m.drawPoly(T);
      z.writeOutlineTextLatLngDiff(
        N.latarray[U],
        N.lngarray[U],
        N.latarray[M],
        N.lngarray[M],
        Q.txt,
        N.color
      );
    }
  };
  this.updateclusters = function (V) {
    var ab = mapviewer;
    var N = ab.settings.cluster_spacing;
    if (V) {
      W = new Array();
      var Z = [];
      for (var M = 0; M < ab.routes.length; M++) {
        var T = ab.routes[M];
        var O = parseInt(T.findTimeIndex(ab.playtime + T.offset));
        if (O >= 0 && O < T.latarray.length - 1) {
          var S = new Object();
          S.lat = T.latarray[O];
          S.lng = T.lngarray[O];
          S.index = M;
          Z.push(S);
        }
      }
      for (var R = 0; R < Z.length; R++) {
        var X = -1;
        for (var M = 0; M < W.length; M++) {
          var U = calcdistance(Z[R].lat, Z[R].lng, W[M].lat, W[M].lng);
          if (U <= N) {
            X = M;
            M = W.length + 1;
          }
        }
        if (X == -1) {
          var Y = new Object();
          Y.members = [];
          Y.lats = [];
          Y.lngs = [];
          if (W.length > 0) {
            X = W.length;
          } else {
            X = 0;
          }
          W[X] = Y;
        }
        W[X].members.push(Z[R].index);
        W[X].lats.push(Z[R].lat);
        W[X].lngs.push(Z[R].lng);
        W[X].lat = W[X].lats.sum() / W[X].lats.length;
        W[X].lng = W[X].lngs.sum() / W[X].lngs.length;
      }
      ab.clusters = W;
    } else {
      var W = ab.clusters;
      for (var R = 0; R < W.length; R++) {
        var Y = W[R];
        var Q = Y.members;
        Y.lats = [];
        Y.lngs = [];
        for (var aa = 0; aa < Q.length; aa++) {
          M = Q[aa];
          if (this.routes[M].show) {
            var T = ab.routes[M];
            var O = parseInt(T.findTimeIndex(ab.playtime + T.offset));
            if (O >= 0 && O < T.latarray.length - 1) {
              var S = new Object();
              Y.lats.push(T.latarray[O]);
              Y.lngs.push(T.lngarray[O]);
            }
          }
        }
        Y.lat = Y.lats.sum() / Y.lats.length;
        Y.lng = Y.lngs.sum() / Y.lngs.length;
      }
    }
  };
  this.drawgrouping = function () {
    var N = parseInt(new Date().getTime());
    if (
      !z.clusters ||
      !z.settings.lastupdate_clusters ||
      N - z.settings.lastupdate_clusters >
        z.settings.update_cluster_frequency * 1000
    ) {
      z.updateclusters(true);
      z.settings.lastupdate_clusters = N;
      z.settings.show_cluster_legend++;
    } else {
      z.updateclusters(false);
    }
    var U = new Array();
    var X = z.clusters;
    if (
      z.settings.show_cluster_legend > X.length - 1 ||
      z.settings.show_cluster_legend < 0
    ) {
      z.settings.show_cluster_legend = 0;
    }
    for (var T = 0; T < X.length; T++) {
      var ab = X[T];
      var Q = ab.members;
      var R = ab.lats[0];
      var S = ab.lngs[0];
      var aa = 0;
      var O = null;
      for (var ac = 0; ac < Q.length; ac++) {
        M = Q[ac];
        if (this.routes[M].show) {
          if (!O) {
            O = this.routes[M].color;
          }
          this.canvas.setLineStyle(
            O,
            this.settings.routeopacity,
            parseInt(this.settings.routewidth / 2)
          );
          context.fillStyle = context.strokeStyle;
          var V = this.routes[M].drawRoute(
            this.map,
            this.canvas,
            this.playtime,
            this.settings.taillength,
            0
          );
          this.DrawnLines[M] = V;
          if (!aa) {
            thetext = this.routes[M].runnername;
            if (ab.members.length > 1) {
              thetext = "Group " + thetext + " (" + ab.members.length + ")";
            }
            var Y = V.endx + 10;
            var W = V.endy + 0;
            var Z = new Object();
            Z.thetext = thetext;
            Z.x = Y;
            Z.y = W;
            Z.color = O;
            U.push(Z);
            aa = 1;
          }
        }
      }
      if (T == z.settings.show_cluster_legend) {
        if (Q.length > 1) {
        } else {
          z.settings.show_cluster_legend++;
          if (T >= X.length - 1) {
            z.settings.show_cluster_legend = 0;
          }
        }
      }
    }
    for (var M = U.length - 1; M >= 0; M--) {
      this.canvas.writeTextOutlined(
        U[M].x,
        U[M].y,
        U[M].color,
        U[M].thetext,
        null,
        null,
        0
      );
    }
    z.showgroupmembers(z.clusters[z.settings.show_cluster_legend]);
  };
  this.showgroupmembers = function (Y) {
    if (Y) {
      var T = Y.members;
      var U = [];
      var S = null;
      thetitle = null;
      for (var Z = 0; Z < T.length; Z++) {
        N = T[Z];
        if (this.routes[N].show) {
          if (!thetitle) {
            thetitle = this.routes[N].runnername;
            if (Y.members.length > 1) {
              thetitle = "Group " + thetitle + " (" + Y.members.length + ")";
            }
            S = this.routes[N].color;
          }
          U.push(this.routes[N].runnername);
        }
      }
      var Q = 10;
      var W = Q;
      var V;
      var X = z.canvas.height - 10;
      z.canvas.use_translated_coordinates = 0;
      var M = 0;
      var R = z.canvas.context.measureText(thetitle);
      var O = R.width;
      while ((U.length + 2) * z.canvas.outlinetxtsize > z.canvas.height) {
        U.shift();
      }
      if (U.length > 0) {
        z.canvas.drawWhiteBackgroundBox(
          0,
          z.canvas.height - 10 - 10 - (U.length + 1) * z.canvas.outlinetxtsize,
          10 + O + 25,
          (U.length + 2) * z.canvas.outlinetxtsize,
          0.5
        );
        for (var N = U.length - 1; N >= 0; N--) {
          var aa = U[N];
          V = X + -M * this.canvas.outlinetxtsize;
          thiswidth = this.canvas.writeTextOutlined(W + 10, V, "000000", aa);
          thiswidth = thiswidth + 10;
          M++;
        }
        V = X + -M * this.canvas.outlinetxtsize;
        thiswidth = this.canvas.writeTextOutlined(W + 10, V, S, thetitle);
      }
      z.canvas.use_translated_coordinates = 1;
    }
  };
  this.drawroutes = function () {
    mapviewer.canvas.context.textAlign = "left";
    this.DrawnLines = new Array();
    if (
      z.settings.showgrouping &&
      z.settings.mode == z.settings.modes.ReplayMode
    ) {
      z.drawgrouping();
    } else {
      if (this.routes.length > 0) {
        if (
          z.settings.replayleg &&
          this.settings.mode == this.settings.modes.ReplayMode
        ) {
          z.replayleg_setcurrentpos();
        }
        var an = 0;
        var ab = new Array();
        for (var aL = this.routes.length - 1; aL >= 0; aL--) {
          ab.push(aL);
        }
        if (
          mapviewer.settings.mode == mapviewer.settings.modes.ReplayMode &&
          mapviewer.settings.analyzecourse == 1 &&
          z.routes[0].splits.length > 0
        ) {
          var ah = new Array();
          for (var aL = 0; aL < z.routes.length; aL++) {
            var aq = new Array();
            var aG = z.routes[aL];
            var O = aG.currenttime(z.playtime);
            for (var aD = 0; aD < aG.splits.length; aD++) {
              aq[aD] = Math.abs(O - aG.splits[aD].index);
            }
            sortWithIndeces(aq);
            ah.push(aq.min());
          }
          sortWithIndeces(ah);
          ab = new Array();
          for (var aL = ah.length - 1; aL >= 0; aL--) {
            ab.push(ah.sortIndices[aL]);
          }
        }
        for (var aL = this.routes.length - 1; aL >= 0; aL--) {
          if (z.routes[aL].show) {
            if (
              z.settings.mode == z.settings.modes.AnalysisMode &&
              (z.settings.legendtype == z.settings.modes.MultiLegend ||
                z.settings.legendtype == z.settings.modes.CornerLegend ||
                z.settings.legendtype == z.settings.modes.CornerLegend2)
            ) {
              if (
                z.routes[aL].segmentlength > 0 &&
                z.routes[aL].segmenttime > 0
              ) {
                an++;
              }
            } else {
              an++;
            }
          }
        }
        var S = 0;
        var ae = null;
        var M = null;
        var aB = -1;
        for (var aJ = 0; aJ < ab.length; aJ++) {
          aL = ab[aJ];
          if (this.routes[aL].show) {
            if (this.routes[aL].highlight) {
              aB = aL;
            } else {
              this.canvas.setLineStyle(
                this.routes[aL].color,
                this.settings.routeopacity,
                this.settings.routewidth
              );
              var Z = this.routes[aL].drawRoute(
                this.map,
                this.canvas,
                this.playtime,
                this.settings.taillength,
                0
              );
              this.DrawnLines[aL] = Z;
              if (this.settings.mapreadingmode) {
                if (this.routes[aL].mapreading) {
                  this.canvas.setLineStyle(
                    this.routes[aL].color,
                    this.settings.routeopacitymapreading,
                    this.settings.routewidthmapreading
                  );
                  this.routes[aL].drawMapreading(
                    this.map,
                    this.canvas,
                    this.playtime,
                    this.settings.taillength
                  );
                }
              }
              if (
                mapviewer.settings.compassanalysis == 1 &&
                mapviewer.settings.otechanalysis == 1 &&
                mapviewer.settings.compassanalysis_showsplits
              ) {
                var ap = this.routes[aL].splits;
                for (var ac = 0; ac < ap.length; ac++) {
                  this_passing = ap[ac].index;
                  var W = z.map.toxy(
                    this.routes[aL].latarray[this_passing],
                    this.routes[aL].lngarray[this_passing]
                  );
                  z.canvas.drawCircle(W.x, W.y, 5);
                }
              }
            }
          }
        }
        if (z.playing && z.courseinfo.coursetype == "xc") {
          var ar = 0;
          var aF = parseInt(
            z.playtime - z.routes[ar].zerotime + z.routes[ar].offset
          );
          var aA;
          if (mapviewer.routes[ar].timetolappos) {
            aA = mapviewer.routes[ar].timetolappos[aF];
            if (aA) {
              z.showgraphpos(parseInt(aA));
            }
          }
        }
        if (this.settings.showdrawdots) {
          this.drawdots_twofirst();
        }
        var at = 0;
        takentxtypos = new Array();
        var T = this.canvas.outlinetxtsize / m.zoomfactor;
        if (
          (z.settings.legendtype == z.settings.modes.CornerLegend ||
            z.settings.legendtype == z.settings.modes.CornerLegend2) &&
          z.settings.lastlegendmaxwidth > 0
        ) {
          z.canvas.use_translated_coordinates = 0;
          if (z.settings.legendtype == z.settings.modes.CornerLegend) {
            z.canvas.drawWhiteBackgroundBox(
              0,
              z.canvas.height - 10 - 10 - an * z.canvas.outlinetxtsize,
              10 + z.settings.lastlegendmaxwidth + 10,
              (an + 1) * z.canvas.outlinetxtsize,
              0.5
            );
          } else {
            z.canvas.drawWhiteBackgroundBox(
              0,
              0,
              10 + z.settings.lastlegendmaxwidth + 10,
              10 + 10 + an * z.canvas.outlinetxtsize,
              0.5
            );
          }
          z.canvas.use_translated_coordinates = 1;
        }
        var R = 0;
        for (var aL = 0; aL < z.routes.length; aL++) {
          if (
            z.routes[aL].segmenttime > 0 &&
            z.routes[aL].segmentlength > 0 &&
            z.routes[aL].show
          ) {
            R = aL;
            aL = z.routes.length + 1;
          }
        }
        var ao = 0;
        var aI = 1e99;
        for (var aL = 0; aL < z.routes.length; aL++) {
          var aM = z.routes[aL].tottime;
          if (aM < aI && aM > 0) {
            aI = aM;
            ao = aL;
          }
        }
        for (var aJ = 0; aJ < ab.length; aJ++) {
          aL = ab[aJ];
          if (this.routes[aL].show) {
            if (!this.routes[aL].highlight) {
              var Z = this.DrawnLines[aL];
              var aw, au;
              if (
                (this.settings.replayleg &&
                  z.settings.legendtype == z.settings.modes.SingleLegend) ||
                ((this.settings.mode == this.settings.modes.ReplayMode ||
                  this.settings.mode == this.settings.modes.LiveMode) &&
                  !this.settings.replayleg)
              ) {
                aw = Z.endx;
                au = Z.endy;
                if (z.settings.legendtype != z.settings.modes.NoLegend) {
                  var ay = "";
                  if (
                    (this.realtime || this.IsLive) &&
                    this.routes[aL].offset != 0
                  ) {
                    ay = " (" + tominsec(this.routes[aL].offset) + ")";
                  }
                  if (this.IsLive && Z.nodata) {
                    ay = " (no data)" + ay;
                  }
                  z.settings.showpulse_map = 1;
                  if (z.settings.showpulse_map && z.routes[aL].pulse) {
                    var aF = parseInt(
                      z.playtime - z.routes[aL].zerotime + z.routes[aL].offset
                    );
                    if (z.routes[aL].pulse[aF]) {
                      var aP = z.routes[aL].maxpulse;
                      if (aP) {
                        ay =
                          " " +
                          parseInt((100 * z.routes[aL].pulse[aF]) / aP) +
                          "%";
                      } else {
                        ay = " " + z.routes[aL].pulse[aF];
                        if (z.routes[aL].pulse.max()) {
                          z.routes[aL].maxpulse = z.routes[aL].pulse.max();
                        }
                      }
                    }
                  }
                  if (Z.showxtxt) {
                    ay = ay + " " + Z.showxtxt;
                  }
                  var aH = this.routes[aL].runnername_short;
                  if (
                    z.settings.legendtype == z.settings.modes.MultiLegend ||
                    z.settings.legendtype == z.settings.modes.CornerLegend ||
                    z.settings.legendtype == z.settings.modes.CornerLegend2
                  ) {
                    aH = this.routes[aL].runnername;
                  }
                  X = this.canvas.writeTextOutlined(
                    aw,
                    au,
                    this.routes[aL].color,
                    aH + ay
                  );
                }
              } else {
                var aj = "";
                if (z.routes[aL].taillength > 0) {
                  aj = tominsec(z.routes[aL].taillength);
                }
                if (
                  mapviewer.settings.colormode ==
                  mapviewer.settings.modes.colorbylength
                ) {
                  if (
                    z.routes[aL].segmentlength > 0 &&
                    z.routes[aL].segmenttime > 0
                  ) {
                    if (z.settings.legendinfo != 5) {
                      aj = parseInt(z.routes[aL].segmentlength) + " m / " + aj;
                    } else {
                      if (aL == 0) {
                        theval = z.routes[0].segmentlength;
                        aj = parseInt(theval) + " m / " + aj;
                      } else {
                        if (
                          z.routes[aL].segmenttime > 0 &&
                          z.routes[aL].segmentlength > 0
                        ) {
                          theval =
                            z.routes[aL].segmentlength -
                            z.routes[0].segmentlength;
                          aj = "+" + parseInt(theval) + " m / " + aj;
                        }
                      }
                    }
                  }
                } else {
                  if (z.settings.legendinfo == 5) {
                    if (aL == R) {
                      aj = tominsec(z.routes[aL].taillength);
                    } else {
                      if (
                        z.routes[aL].segmenttime > 0 &&
                        z.routes[aL].segmentlength > 0
                      ) {
                        aj =
                          "+" +
                          tominsec(
                            z.routes[aL].taillength - z.routes[R].taillength
                          );
                      }
                    }
                  }
                }
                var aE = "";
                if (z.settings.legendinfo == 2) {
                  aE = aj + " " + this.routes[aL].runnername_short;
                } else {
                  aE = aj + " " + this.routes[aL].runnername;
                }
                if (
                  z.routes[aL].segmenttime > 0 &&
                  z.routes[aL].segmentlength > 0
                ) {
                  if (
                    (z.settings.legendinfo == 0 ||
                      z.settings.legendinfo == 3 ||
                      z.settings.legendinfo == 6) &&
                    mapviewer.settings.colormode !=
                      mapviewer.settings.modes.colorbylength
                  ) {
                    aE = aE + " " + parseInt(z.routes[aL].segmentlength) + " m";
                  }
                  if (
                    z.settings.legendinfo == 0 ||
                    z.settings.legendinfo == 4 ||
                    z.settings.legendinfo == 6
                  ) {
                    var af = tominsec(
                      Math.round(
                        (z.routes[aL].segmenttime /
                          z.routes[aL].segmentlength) *
                          1000
                      )
                    );
                    aE = aE + ", " + af + " min/km";
                  }
                  if (z.settings.legendinfo == 8) {
                    aE = tominsec(z.routes[aL].taillength);
                    if (
                      z.routes[aL].segmenttime > 0 &&
                      z.routes[aL].segmentlength > 0
                    ) {
                      var aO = "";
                      aO =
                        ", +" +
                        parseInt(
                          ((z.routes[aL].taillength - z.routes[R].taillength) /
                            z.routes[R].taillength) *
                            100
                        ) +
                        "%";
                      var aM = z.routes[aL].tottime;
                      if (aM == 1e99) {
                        aM = 0;
                      }
                      aM = parseInt(aM);
                      if (aM) {
                        var N = parseInt(
                          ((z.routes[aL].tottime - z.routes[ao].tottime) /
                            z.routes[ao].tottime) *
                            100
                        );
                        if (N >= 0) {
                          N = "+" + N;
                        }
                        aO =
                          aO +
                          ", Overall: " +
                          N +
                          "% / " +
                          tominsec(z.routes[aL].tottime) +
                          "";
                      }
                      aE = aE + aO;
                    }
                    aE =
                      aE + ", " + parseInt(z.routes[aL].segmentlength) + " m";
                    var af = tominsec(
                      Math.round(
                        (z.routes[aL].segmenttime /
                          z.routes[aL].segmentlength) *
                          1000
                      )
                    );
                    aE = aE + ", " + af + " min/km";
                    aE = aE + ", " + this.routes[aL].runnername;
                  }
                  if (
                    mapviewer.settings.corridoranalysis == 1 &&
                    mapviewer.settings.otechanalysis == 1
                  ) {
                    aE = aj + " " + this.routes[aL].runnername;
                    if (this.routes[aL].results) {
                      if (this.routes[aL].results.corridor_overall) {
                        aE +=
                          " " +
                          Math.round(this.routes[aL].results.corridor_overall) +
                          "% (" +
                          Math.round(this.routes[aL].results.corridor_time) +
                          "% time score, " +
                          Math.round(this.routes[aL].results.corridor_length) +
                          "% length score)";
                      }
                    }
                  }
                  if (
                    z.settings.coursedefinition_mode == 3 ||
                    z.settings.definecourse == 1
                  ) {
                    var ad =
                      z.routes[aL].currenttime(z.playtime) -
                      z.routes[aL].taillength;
                    var aN = z.routes[aL].currenttime(z.playtime);
                    aE = tominsec(ad) + " - " + tominsec(aN);
                    aE = aE + " (" + tominsec(z.routes[aL].taillength) + ")";
                    aE =
                      aE + ", " + parseInt(z.routes[aL].segmentlength) + " m";
                    aE = aE + ", " + af + " min/km";
                    aE = aE + ", " + this.routes[aL].runnername;
                    z.coursedef_drawing = new Object();
                    z.coursedef_drawing.currentrnr = aL;
                    z.coursedef_drawing.currentpnr = aN;
                  }
                  if (
                    mapviewer.settings.compassanalysis == 1 &&
                    mapviewer.settings.otechanalysis == 1
                  ) {
                    aE = aj + " " + this.routes[aL].runnername;
                    if (this.routes[aL].results) {
                      if (this.routes[aL].results.compass_overall) {
                        aE +=
                          " " +
                          Math.round(this.routes[aL].results.compass_overall) +
                          "% compass";
                      }
                    }
                  }
                }
                if (z.settings.calc_inout_times) {
                  if (
                    z.routes[aL].segmenttime > 0 &&
                    z.routes[aL].segmentlength > 0
                  ) {
                    if (
                      z.routes[aL].segmenttime_out > 0 ||
                      z.routes[aL].segmenttime_in > 0
                    ) {
                      aE = aE + "  ";
                      if (z.routes[aL].segmenttime_out > 0) {
                        aE = aE + tominsec(z.routes[aL].segmenttime_out);
                      } else {
                        aE = aE + "-";
                      }
                      aE = aE + " / ";
                      if (z.routes[aL].segmenttime_in > 0) {
                        aE = aE + tominsec(z.routes[aL].segmenttime_in);
                      } else {
                        aE = aE + "-";
                      }
                    }
                  }
                }
                if (
                  z.settings.legendtype == z.settings.modes.SingleLegend ||
                  z.settings.legendtype == z.settings.modes.SingleLegend2 ||
                  z.settings.legendtype == z.settings.modes.SingleLegend3
                ) {
                  var aw = Z.middlex;
                  var au = Z.middley;
                  var al = aw;
                  var ak = au;
                  var ax = 1;
                  var U = 1;
                  while (
                    takentxtypos[
                      Math.floor(
                        (au * Math.cos(z.canvas.rotate_angle) +
                          aw * Math.sin(z.canvas.rotate_angle)) /
                          T
                      )
                    ] &&
                    ax < this.canvas.outlinetxtsize
                  ) {
                    au = au + U * ax * T * 1.1;
                    if (U == -1) {
                      ax++;
                    }
                    U = -U;
                  }
                  takentxtypos[
                    Math.floor(
                      (au * Math.cos(z.canvas.rotate_angle) +
                        aw * Math.sin(z.canvas.rotate_angle)) /
                        T
                    )
                  ] = 1;
                  z.routes[aL].legendpos_x = aw + z.routes[aL].legendoffset_x;
                  z.routes[aL].legendpos_y = au + z.routes[aL].legendoffset_y;
                  var am = z.routes[aL].angle;
                  if (z.settings.legendtype == z.settings.modes.SingleLegend2) {
                    colorboxwidth =
                      (this.canvas.outlinetxtsize * 1.3) / z.canvas.zoomfactor;
                    colorboxheight =
                      (this.canvas.outlinetxtsize * 0.8) / z.canvas.zoomfactor;
                    z.canvas.drawColorBox(
                      z.routes[aL].legendpos_x,
                      z.routes[aL].legendpos_y - colorboxheight,
                      colorboxwidth,
                      colorboxheight,
                      z.routes[aL].color,
                      1
                    );
                    z.canvas.drawLine(
                      al,
                      ak,
                      z.routes[aL].legendpos_x,
                      z.routes[aL].legendpos_y
                    );
                    this.canvas.writeTextOutlined(
                      z.routes[aL].legendpos_x + colorboxwidth * 1.5,
                      z.routes[aL].legendpos_y,
                      "000000",
                      aE,
                      null,
                      null,
                      am
                    );
                  } else {
                    if (
                      z.settings.legendtype == z.settings.modes.SingleLegend3
                    ) {
                      this.canvas.setLineStyle(
                        "000000",
                        1,
                        2,
                        z.routes[aL].color,
                        1
                      );
                      z.canvas.drawLine(
                        al,
                        ak,
                        z.routes[aL].legendpos_x,
                        z.routes[aL].legendpos_y
                      );
                      this.canvas.writeTextOutlined(
                        z.routes[aL].legendpos_x,
                        z.routes[aL].legendpos_y,
                        z.routes[aL].color,
                        aE,
                        null,
                        null,
                        am
                      );
                    } else {
                      this.canvas.writeTextOutlined(
                        z.routes[aL].legendpos_x,
                        z.routes[aL].legendpos_y,
                        z.routes[aL].color,
                        aE,
                        null,
                        null,
                        am
                      );
                    }
                  }
                } else {
                  if (z.settings.legendtype == z.settings.modes.MultiLegend) {
                    if (
                      z.routes[aL].segmenttime > 0 &&
                      z.routes[aL].segmentlength > 0
                    ) {
                      if (ae == null) {
                        ae = Z.middlex;
                        M = Z.middley;
                      }
                      var aw =
                        ae +
                        z.settings.legendoffset_x +
                        (((an / 2 - S) * this.canvas.outlinetxtsize) /
                          this.canvas.zoomfactor) *
                          Math.sin(z.canvas.rotate_angle);
                      var au =
                        M +
                        z.settings.legendoffset_y +
                        (((an / 2 - S) * this.canvas.outlinetxtsize) /
                          this.canvas.zoomfactor) *
                          Math.cos(z.canvas.rotate_angle);
                      S++;
                      this.canvas.writeTextOutlined(
                        aw,
                        au,
                        z.routes[aL].color,
                        aE
                      );
                    }
                  } else {
                    if (
                      z.settings.legendtype == z.settings.modes.CornerLegend ||
                      z.settings.legendtype == z.settings.modes.CornerLegend2
                    ) {
                      ae = 10;
                      var aw = ae;
                      var au;
                      if (
                        z.settings.legendtype == z.settings.modes.CornerLegend
                      ) {
                        M = z.canvas.height - 10;
                        au = M + -S * this.canvas.outlinetxtsize;
                      } else {
                        M = 10;
                        au = M + (an - S) * this.canvas.outlinetxtsize;
                      }
                      if (
                        (z.routes[aL].segmentlength > 0 &&
                          z.routes[aL].segmenttime > 0) ||
                        z.settings.forcecornerlegend
                      ) {
                        S++;
                        z.canvas.use_translated_coordinates = 0;
                        var X;
                        colorboxwidth = this.canvas.outlinetxtsize * 1.3;
                        colorboxheight = this.canvas.outlinetxtsize * 0.8;
                        X = this.canvas.writeTextOutlined(
                          aw + colorboxwidth * 1.5,
                          au,
                          "000000",
                          aE
                        );
                        this.canvas.drawColorBox(
                          aw,
                          au -
                            this.canvas.outlinetxtsize +
                            this.canvas.outlinetxtsize * 0.2,
                          colorboxwidth,
                          colorboxheight,
                          z.routes[aL].color
                        );
                        X = X + colorboxwidth * 1.5;
                        if (X > at) {
                          at = X;
                        }
                        z.canvas.use_translated_coordinates = 1;
                      }
                    } else {
                    }
                  }
                }
              }
            }
          }
        }
        z.settings.lastlegendmaxwidth = at;
        if (aB != -1) {
          if (z.settings.analyzecourse) {
            this.canvas.setLineStyle(
              this.settings.highlightcolor,
              this.settings.highlightopacity,
              this.settings.highlightwidth2
            );
            var ai = z.routes[aB].latarray.length - 1;
            var V = parseInt(
              z.routes[aB].zerotime +
                z.routes[aB].latarray.length -
                1 -
                z.routes[aB].offset
            );
            var Z = this.routes[aB].drawRoute(this.map, this.canvas, V, ai, 1);
            var ap = this.routes[aB].splits;
            var ag = this.settings.controlRadius * 0.5;
            var av = null;
            if (this.control_onmousedown) {
              av = this.control_onmousedown.controlnu;
            }
            if (av == null) {
              this.canvas.setLineStyle(
                this.settings.highlightcolor2,
                this.settings.highlightopacity,
                this.settings.highlightwidth2
              );
            }
            for (var aL = 0; aL < ap.length; aL++) {
              this_passing = ap[aL].index;
              var W = z.map.toxy(
                this.routes[aB].latarray[this_passing],
                this.routes[aB].lngarray[this_passing]
              );
              if (av == aL) {
                this.canvas.setLineStyle(
                  this.settings.highlightcolor2,
                  this.settings.highlightopacity,
                  this.settings.highlightwidth2
                );
              }
              z.canvas.drawCircle(W.x, W.y, ag);
              if (av == aL) {
                var Y = av;
                if (Y == 0) {
                  Y = "Start";
                }
                Y = Y + " " + this.routes[aB].runnername;
                z.canvas.writeTextOutlined(
                  W.x + ag * 2,
                  W.y,
                  this.settings.highlightcolor2,
                  Y
                );
                this.canvas.setLineStyle(
                  this.settings.highlightcolor,
                  this.settings.highlightopacity,
                  this.settings.highlightwidth2
                );
              }
            }
          } else {
            this.canvas.setLineStyle(
              this.settings.highlightcolor,
              this.settings.highlightopacity,
              this.settings.highlightwidth
            );
            var Z = this.routes[aB].drawRoute(
              this.map,
              this.canvas,
              this.playtime,
              this.settings.taillength,
              0
            );
            var aw = Z.middlex;
            var au = Z.middley;
            if (z.realtime || z.IsLive) {
              this.canvas.writeTextOutlined(
                aw,
                au,
                this.settings.highlightcolor,
                "Offset " +
                  tominsec(z.routes[z.marker_onmousedown.markernu].offset) +
                  " " +
                  this.routes[aB].runnername
              );
            } else {
              this.canvas.writeTextOutlined(
                aw,
                au,
                this.settings.highlightcolor,
                tominsec(z.routes[z.marker_onmousedown.markernu].taillength) +
                  " " +
                  this.routes[aB].runnername
              );
            }
          }
        }
      }
    }
    if (
      mapviewer.settings.mode == mapviewer.settings.modes.ReplayMode &&
      mapviewer.settings.analyzecourse == 1 &&
      z.routes[0].splits.length > 0
    ) {
      var aK = new Array();
      for (var aL = 0; aL < z.routes.length; aL++) {
        var aG = z.routes[aL];
        var aa = 0;
        var O = aG.currenttime(z.playtime);
        var az = -1;
        for (var aD = 0; aD < aG.splits.length; aD++) {
          var aC = aG.splits[aD].index;
          if (aC > 0) {
            if (O >= aG.splits[aD].index) {
              aa = aC;
              az = aD;
            } else {
              thiscoursepos = az + (O - aa) / (aC - aa);
              break;
            }
          }
        }
        aK.push(thiscoursepos);
      }
      console.log("Preliminary results:");
      sortWithIndeces(aK);
      for (var aL = aK.length - 1; aL >= 0; aL--) {
        var Q = z.routes[aK.sortIndices[aL]];
        console.log(aK[aL] + " " + Q.runnername);
      }
    }
  };
  this.drawdots_twofirst = function () {
    var M = new Array();
    for (var N = 0; N < z.routes.length; N++) {
      if (z.routes[N].show) {
        M.push(N);
      }
    }
    if (M.length > 1) {
      z.drawdots(M[0], M[1]);
    }
  };
  this.coursefittoggle = function (T) {
    if (z.settings.coursedefinition_mode == 3) {
      $("#course-slider").show();
      $("#definecoursebutton").hide();
      $("#AutoCourseSep").hide();
      $("#coursefitdata").hide();
      $("#definecoursebutton").hide();
      $("#routeedit_select").show();
      $("#routeedit_execute").show();
    } else {
      if (z.settings.coursedefinition_mode) {
        $("#course-slider").hide();
        $("#course-slider").hide();
        $("#definecoursebutton").hide();
        $("#AutoCourseSep").hide();
        $("#definecoursebutton").hide();
        $("#coursefitdata").show();
        $("#routeedit_select").hide();
        $("#routeedit_execute").hide();
        var R;
        if (z.settings.coursedefinition_mode == 1) {
          R = "lapdata";
        } else {
          R = "lapdata_failed";
        }
        if (!T) {
          z.settings.coursefit_rnr = -1;
          z.settings.coursefit_lnr = 0;
        }
        var N = z.settings.coursefit_rnr;
        var Q = z.settings.coursefit_lnr;
        var S = 0;
        var O = 0;
        while (!S && O < 4) {
          Q++;
          count++;
          if (z.routes[N]) {
            if (z.routes[N][R]) {
              if (z.routes[N][R][Q]) {
                S = 1;
              } else {
                N++;
                Q = -1;
                if (!z.routes[N]) {
                  N = 0;
                  O++;
                }
              }
            } else {
              N++;
              Q = -1;
              if (!z.routes[N]) {
                N = 0;
                O++;
              }
            }
          } else {
            N = 0;
            Q = -1;
            O++;
          }
        }
        if (Q >= 0) {
          var M = "";
          if (z.routes[N][R].length > 1) {
            M = " lap " + (Q + 1);
          }
          $("#coursefitinfo").html(z.routes[N].runnername_middle + M);
        } else {
          $("#coursefitinfo").html("No route/lap found");
        }
        z.settings.coursefit_rnr = N;
        z.settings.coursefit_lnr = Q;
        z.request_redraw();
      } else {
        $("#course-slider").show();
        $("#definecoursebutton").show();
        $("#AutoCourseSep").show();
        $("#definecoursebutton").show();
        $("#coursefitdata").hide();
        $("#routeedit_select").hide();
        $("#routeedit_execute").hide();
      }
    }
  };
  this.showfitlap = function (N, O, M) {
    z.settings.coursedefinition_mode = M;
    z.settings.coursefit_rnr = N;
    z.settings.coursefit_lnr = O;
    z.request_redraw();
  };
  this.drawdots = function (Q, N) {
    route1 = this.routes[Q];
    route2 = this.routes[N];
    if (z.DrawnLines) {
      L1 = z.DrawnLines[Q];
      L2 = z.DrawnLines[N];
      if (L1 && L2) {
        if (z.settings.showdrawdots == 2) {
          length1 = L1.end - L1.start;
          length2 = L2.end - L2.start;
          length = length2;
          if (length2 > length1) {
            length = length1;
          }
          var O = "ff0000";
          for (var M = 0; M < length; M = M + this.settings.dotstep) {
            if (O == "ff0000") {
              O = "0000ff";
            } else {
              O = "ff0000";
            }
            var X = Math.round(z.settings.routewidth / 4);
            z.canvas.setLineStyle(O, 0.5, X);
            P1 = z.map.toxy(
              route1.latarray[M + L1.start],
              route1.lngarray[M + L1.start]
            );
            P2 = z.map.toxy(
              route2.latarray[M + L2.start],
              route2.lngarray[M + L2.start]
            );
            z.canvas.drawLine(P1.x, P1.y, P2.x, P2.y);
          }
        } else {
          if (z.settings.showdrawdots == 1) {
            length1 = L1.end - L1.start;
            length2 = L2.end - L2.start;
            length = length2;
            if (length2 < length1) {
              length = length1;
            }
            var V = 2;
            var S = V;
            var U = 10;
            var Z = U;
            var T = 0;
            for (var M = 0; M < length; M = M + this.settings.dotstep) {
              var R = 0;
              var Y = 0;
              S++;
              if (S >= V) {
                S = 0;
                R = 1;
              }
              Z++;
              if (Z >= U) {
                Z = 0;
                Y = 1;
              }
              if (R) {
                z.canvas.setLineStyle("0000ff", 0.5, X);
              } else {
                z.canvas.setLineStyle("ff0000", 0.5, X);
              }
              var X = Math.round(z.settings.routewidth / 4);
              P1 = z.map.toxy(
                route1.latarray[M + L1.start],
                route1.lngarray[M + L1.start]
              );
              P2 = z.map.toxy(
                route2.latarray[M + L2.start],
                route2.lngarray[M + L2.start]
              );
              var W = 1.5 / z.canvas.zoomfactor;
              if ((M >= length1 || M >= length2) && !T) {
                Z = 0;
                Y = 1;
                T = 1;
              }
              if (M < length1 && M < length2) {
                z.canvas.drawLine(P1.x, P1.y, P2.x, P2.y);
                z.canvas.setLineStyle("000000", 0.6, 0.5, "ffff00", 0.6);
              } else {
                tcol = "FFFF00";
                ttransp = 1;
                W = 2 / z.canvas.zoomfactor;
                if (Y) {
                  W = 4 / z.canvas.zoomfactor;
                  tcol = "000000";
                  if (M >= length2) {
                    tcol = this.routes[N].color;
                    ttransp = 1;
                    tcol = "FFFF00";
                  } else {
                    tcol = this.routes[Q].color;
                    ttransp = 1;
                    tcol = "FFFF00";
                  }
                }
                z.canvas.setLineStyle("000000", 1, 1, tcol, ttransp);
              }
              if (M < length1) {
                z.canvas.drawCircle(P1.x, P1.y, W, 1);
              }
              if (M < length2) {
                z.canvas.drawCircle(P2.x, P2.y, W, 1);
              }
            }
          }
        }
      }
    }
  };
  this.initializeInfobox = function () {
    if (isnarrowscreen) {
      $("#" + this.infodiv).html(" ");
      $("#" + this.infodiv).append("<span id='toptitle'></span>");
      this.addbutton(this.infodiv, "zoomintop", "+");
      $("#zoomintop").bind("click", function (M, N) {
        z.canvas.zoom(2, "key");
      });
      this.addbutton(this.infodiv, "zoomouttop", "-");
      $("#zoomouttop").bind("click", function (M, N) {
        z.canvas.zoom(-2, "key");
      });
      this.addbutton(this.infodiv, "backtop", "<");
      $("#backtop").bind("click", function (M, N) {
        z.playtime -= 60;
        z.reset_replaystarttime();
        z.request_redraw();
      });
      this.addbutton(this.infodiv, "playtop", "P");
      $("#playtop").bind("click", function (M, N) {
        z.toggleplay();
      });
      this.addbutton(this.infodiv, "forwtop", ">");
      $("#forwtop").bind("click", function (M, N) {
        z.playtime += 60;
        z.reset_replaystarttime();
        z.request_redraw();
      });
      $("#" + this.infodiv).append(
        '<select id="playspeedtop"><option value="1">1x</option><option value="5">5x</option><option selected value="10">10x</option><option value="20">20x</option><option value="50">50x</option></select>'
      );
      $("#playspeedtop").change(function () {
        z.play_speed = parseInt($("#playspeedtop").val());
        if (isNaN(z.play_speed)) {
          z.play_speed = 10;
        }
        z.reset_replaystarttime();
      });
      this.addbutton(this.infodiv, "playmenutoggle", "M");
      $("#playmenutoggle").bind("click", function (M, N) {
        if (z.settings.menu_isvisible) {
          $("#" + z.menudiv).css("z-index", -1);
          $("#" + z.menudiv).css("width", 1);
          z.settings.menu_isvisible = 0;
        } else {
          $("#" + z.menudiv).css("z-index", 10);
          $("#" + z.menudiv).css("width", 200);
          z.settings.menu_isvisible = 1;
        }
      });
      $("#" + z.menudiv).css("z-index", -1);
      $("#" + z.menudiv).css("width", 1);
      z.settings.menu_isvisible = 0;
    } else {
      if (xc) {
        if (isinternetexplorer) {
          $("#" + this.infodiv).html(
            "<b>XCViewer: Note! Please use Google Chrome or Firefox - XCViewer does not work too well in Internet Explorer!</b>"
          );
        } else {
          $("#" + this.infodiv).html(
            '<b>XCViewer by WorldofXC.com </b> &nbsp; <a class="topbutton" href="javascript:void(0);" onclick="mapviewer.togglerightmenu(\'togglerightmenu\');" id="togglerightmenu">Hide menu</a>'
          );
        }
        $("#" + z.infodiv).css("background", "#00a");
      } else {
        if (isinternetexplorer) {
          $("#" + this.infodiv).html(
            "<b>2DRerun by WorldofO.com: Note! Please use Google Chrome or Firefox - 2DRerun does not work too well in Internet Explorer!</b>"
          );
        } else {
          if (courseplanning) {
            $("#" + this.infodiv).html(
              '<div id="topinfo" style="height:16px"><span id="toptitle"><b>2DRerun CoursePlanning Module by WorldofO.com </b></span> <span style="position:absolute;right:0;width:200px;text-align:left"><a class="topbutton" href="javascript:void(0);" onclick="mapviewer.togglerightmenu(\'togglerightmenu\');" id="togglerightmenu">Hide menu</a></span></div>'
            );
          } else {
            $("#" + this.infodiv).html(
              '<div id="topinfo" style="height:16px"><span id="toptitle"><b>2DRerun by WorldofO.com </b></span><span style="position:relative;left:50px;"><a href="javascript:void(0);" onclick="mapviewer.wizard_start();" class="topbutton" id="wizardmodebutt">Help</a> &nbsp; - &nbsp; <a href="offline.php" target=_blank class="topbutton">Offline version</a></span> <span style="position:absolute;right:0;width:200px;text-align:left"><a class="topbutton" href="javascript:void(0);" onclick="mapviewer.togglerightmenu(\'togglerightmenu\');" id="togglerightmenu">Hide menu</a></span></div>'
            );
          }
        }
        $("#wizardmodebutt")
          .tooltipster({
            autoClose: true,
            maxWidth: 300,
            position: "bottom",
            content: $(
              "<span><strong>Click here to start different step-by-step guides for both Beginners and Advanced users. The best way to learn both basic and advanced features in 2DRerun.</strong></span>"
            ),
          })
          .tooltipster("show");
        z.wizardmodebutthandler = function () {
          $("#wizardmodebutt").tooltipster("destroy");
          $("#wizardmodebutt").attr("title", "");
          $(window).unbind("click", mapviewer.wizardmodebutthandler);
        };
        $(window).bind("click", z.wizardmodebutthandler);
      }
    }
    if (1) {
      z.add_dragdrop();
    }
    if (!getURLParameter("t") && !getURLParameter("a")) {
      z.add_dragdrop_xml();
    }
  };
  this.calculate_autosplits = function () {
    for (var M = 0; M < z.routes.length; M++) {
      var U = z.routes[M];
      if (!U.manualsplits) {
        U.splits = new Array();
        var X = z.coursecoords;
        var S = -1;
        for (var T = 0; T < X.length; T++) {
          var Z = X[T].split(",");
          var O = Z[0];
          var N = Z[1];
          var R = z.map.tolatlng(O, N);
          thislat = R.lat;
          thislng = R.lng;
          var Q = U.findclosestpoint(thislat, thislng, "completeroute", -1);
          var W = new Object();
          if (T == 0) {
            if (Q.splits) {
              if (Q.splits[0]) {
                W.index = Q.splits[0].index;
              } else {
                W.index = Q.index;
              }
            } else {
              W.index = Q.index;
            }
          } else {
            if (Q.splits) {
              var V = 0;
              for (var Y = 0; Y < Q.splits.length && V == 0; Y++) {
                if (Q.splits[Y].index > S) {
                  W.index = Q.splits[Y].index;
                  V = 1;
                }
              }
              if (!V) {
                W.index = -1;
              }
            } else {
              W.index = Q.index;
            }
          }
          if (W.index > -1) {
            S = W.index;
          }
          U.splits[T] = W;
        }
      }
    }
    z.settings.autosplits_calculated = 1;
  };
  this.togglerightmenu = function (M) {
    if (z.settings.menu_isvisible) {
      $("#" + this.menudiv).css("z-index", -1);
      $("#" + z.menudiv).css("width", 1);
      $("#" + M).html("Show menu");
      z.settings.menu_isvisible = 0;
    } else {
      $("#" + this.menudiv).css("z-index", 10);
      $("#" + z.menudiv).css("width", 200);
      $("#" + M).html("Hide menu");
      z.settings.menu_isvisible = 1;
    }
  };
  this.replayleg = function (O, N) {
    var M = mapviewer;
    if (!O) {
      O = M.savestate();
    }
    if (N) {
      if (N.dots) {
        M.settings.showdrawdots = 1;
      } else {
        M.settings.showdrawdots = 0;
      }
      if (N.play_speed) {
        M.settings.play_speed = N.play_speed;
        if (isNaN(M.play_speed)) {
          M.play_speed = 10;
        }
      }
      if (N.legendtype) {
        M.settings.legendtype = N.legendtype;
      }
      if (N.samezoom) {
        M.canvas.cx = O.cx;
        M.canvas.cy = O.cy;
        M.canvas.zoomfactor = O.zoomfactor;
      }
    }
    if (M.playing) {
      M.toggleplay();
    }
    M.settings.replayleg = 1;
    M.replayleg_state = O;
    M.playtime = M.replayleg_state.playtime;
    M.replayleg_starttime = M.playtime;
    if (N.noplay) {
      M.playtime = M.playtime + 1000000;
      M.replayleg_setcurrentpos();
      M.redraw();
      M.settings.replayleg = 0;
      M.settings.mode = M.settings.modes.AnalysisMode;
    } else {
      M.replayleg_setcurrentpos();
      if (!M.playing) {
        M.toggleplay();
      }
    }
  };
  this.replayleg_setcurrentpos = function () {
    z = mapviewer;
    var M = 1;
    var R = z.replayleg_state;
    var O = z.playtime - z.replayleg_starttime;
    if (O < 1) {
      O = 1;
    }
    for (var N = 0; N < z.routes.length; N++) {
      z.routes[N].show = 0;
    }
    for (var U = 0; U < R.routes.length; U++) {
      var S = R.routes[U];
      for (var N = 0; N < z.routes.length; N++) {
        if (z.routes[N].indexnumber == S.indexnumber) {
          thisroute = z.routes[N];
          thisroute.show = 1;
          var V = S.from + O;
          var Q = S.to - S.from + O;
          if (V <= S.to) {
            thisroute.offset = S.offset - (S.to - S.from + 1);
            thisroute.taillength = O;
            M = 0;
          } else {
            thisroute.offset = S.offset - (S.to - S.from + 1) - (V - S.to);
            thisroute.taillength = S.to - S.from;
          }
        }
      }
    }
    z.request_redraw();
    z = mapviewer;
    var R = z.replayleg_state;
    var O = z.playtime - z.replayleg_starttime;
    if (O < 1) {
      O = 1;
    }
    for (var U = 0; U < R.routes.length; U++) {
      var S = R.routes[U];
      for (var N = 0; N < z.routes.length; N++) {
        if (z.routes[N].show && z.routes[N].indexnumber == S.indexnumber) {
          thisroute = z.routes[N];
          var V = S.from + O;
          var Q = S.to - S.from + O;
          if (V <= S.to) {
            thisroute.offset = S.offset - (S.to - S.from + 1);
            thisroute.taillength = O;
          } else {
            thisroute.offset = S.offset - (S.to - S.from + 1) - (V - S.to);
            thisroute.taillength = S.to - S.from;
          }
        }
      }
    }
    z.request_redraw();
    z.update_segmenttime_from_taillength();
    if (M) {
      if (z.playing) {
        z.toggleplay();
      }
      if (z.is_save_animation) {
        var T = 12;
        z.is_save_animation++;
        if (z.is_save_animation > T) {
          z.stop_save_animation();
        }
      }
    }
    return R;
  };
  this.savestate = function () {
    var N = mapviewer;
    var O = new Object();
    O.routes = new Array();
    O.members = new Array();
    O.playtime = N.playtime;
    O.name = "New state";
    for (var Q = 0; Q < N.routes.length; Q++) {
      if (N.routes[Q].show) {
        thisroute = N.routes[Q];
        var M = new Object();
        M.runnername = thisroute.runnername;
        M.indexnumber = thisroute.indexnumber;
        M.segmentlength = thisroute.segmentlength;
        M.taillength = thisroute.taillength;
        M.segmenttime = thisroute.segmenttime;
        M.segmentpace = thisroute.segmentpace;
        M.color = thisroute.color;
        M.offset = thisroute.offset;
        M.zerotime = thisroute.zerotime;
        M.to = N.playtime - thisroute.zerotime + thisroute.offset;
        M.from = M.to - M.segmenttime;
        O.routes.push(M);
        O.members.push(thisroute.runnername);
      }
    }
    O.memberstring = O.members.join(", ");
    O.cx = N.canvas.cx;
    O.cy = N.canvas.cy;
    O.zoomfactor = N.canvas.zoomfactor;
    return O;
  };
  this.toggleplay = function () {
    if (this.playing) {
      if (z.IsLive) {
        $("#selectmode").val("replay");
        $("#playspeedr").show();
        $("#realtime").show();
        $("#playcontrol").show();
        z.IsLive = 0;
      }
      z.playing = 0;
      z.play_speed = parseInt($("#playspeedr").val());
      if (isNaN(z.play_speed)) {
        z.play_speed = 10;
      }
    } else {
      if (z.settings.mode != z.settings.modes.ReplayMode) {
        z.settings.mode = z.settings.modes.ReplayMode;
        $("#selectmode").val("replay");
        $("#playspeedr").show();
        $("#realtime").show();
        $("#playcontrol").show();
        z.play_speed = parseInt($("#playspeedr").val());
        if (isNaN(z.play_speed)) {
          z.play_speed = 10;
        }
        if (z.settings.showdrawdots) {
          $("#replaydots").prop("checked", true);
        } else {
          $("#replaydots").prop("checked", false);
        }
      }
      if (z.settings.replayleg == 0) {
        z.settings.colormode = z.settings.modes.colorbyorg;
      }
      this.reset_taillengths();
      this.playing = 1;
      z.reset_replaystarttime();
      if (z.settings.replayleg == 0) {
        this.recolorbyorg();
      }
    }
  };
  this.loadmap = function (W, T, O, R, V, M, N) {
    if (simplified_version) {
      if (T == null && O == null) {
        T = 1600;
        O = 1600;
      }
      this.canvas.initialize(T, O, T, O);
    } else {
      bindEvent(document.body, "touchmove", function (X) {}, false);
      var U = getBrowserWidth() - 1;
      var Q = getBrowserHeight() - 1;
      var S;
      if ($("#" + o).is(":visible")) {
        S =
          Q -
          ($("#" + o).outerHeight() +
            $("#" + this.menudiv).outerHeight() -
            $("#" + this.menudiv).height());
      } else {
        S =
          Q -
          ($("#" + this.menudiv).outerHeight() -
            $("#" + this.menudiv).height());
      }
      if (T == null && O == null) {
        this.canvas.initialize(U, S, 1600, 1600);
      } else {
        this.canvas.initialize(U, S, T, O);
      }
      $("#" + this.menudiv).height(S);
      if (z.settings.menu_isvisible) {
        m.viewportw = m.viewportw - $("#" + this.menudiv).width();
      }
    }
    this.map.loadmap(W, T, O, R, V, M, N);
    this.initializeInfobox();
  };
  this.showcoursebutt_check = function () {
    if (z.settings.showcourse == 1) {
      $("#id_showcourse").prop("checked", true);
    } else {
      $("#id_showcourse").prop("checked", false);
    }
  };
  this.replayleg_update_taillengths = function () {
    for (var M = 0; M < z.routes.length; M++) {
      this.routes[M].taillength = this.settings.taillength;
      this.routes[M].segmentlength = 0;
      this.routes[M].segmenttime = 0;
      this.routes[M].segmentpace = 0;
    }
  };
  this.reset_taillengths = function () {
    if (
      !(
        z.settings.replayleg &&
        this.settings.mode == this.settings.modes.ReplayMode
      )
    ) {
      for (var M = 0; M < z.routes.length; M++) {
        this.routes[M].taillength = this.settings.taillength;
        this.routes[M].segmentlength = 0;
        this.routes[M].segmenttime = 0;
        this.routes[M].segmentpace = 0;
      }
    }
  };
  this.getnextcolor = function () {
    var M = z.linecolors[z.colorcounter % z.linecolors.length];
    z.colorcounter++;
    return M;
  };
  this.prepareoffline = function () {
    if (typeof courseplanning != "undefined") {
    } else {
      courseplanning = 0;
    }
    this.offline = 1;
    if (!courseplanning || getURLParameter("printscreen")) {
      z.settings.enableprintscreen = 1;
    }
    if (xc) {
      $("#" + z.routemenudiv).html(
        '<b><font color="#00c">Drag GPX-files or course-files onto the area start.</font></b>'
      );
    } else {
      if (0) {
        derror();
        return;
      } else {
      }
      $("#" + z.routemenudiv).html(
        '<b><font color="#00c">Drag GPX-files or map onto the canvas to start.</font></b>'
      );
      z.add_dragdrop();
      $("#selectmode").val("addroutes");
      $("#selectmode").change();
    }
    z.addlocalroutesfromurl();
    if (!(typeof uid == "undefined")) {
      localStorage_setItem("uid", uid);
      localStorage_setItem("uname", uname);
    }
    mapviewer.redraw();
  };
  this.load3DRerun = function (M, N, O) {
    this.load_ids = M;
    this.load3DRerun_maps = N;
    this.load3DRerun_routes = O;
    this.load_qnr_route = 0;
    this.load_qnr_map = 0;
    this.load_qnr = 0;
    this.load3DRerun_next_in_queue();
  };
  this.nomap = function () {
    $("#" + z.routemenudiv).html("No map loaded!");
  };
  this.load3DRerun_next_in_queue = function () {
    this.redraw();
    if (this.load_ids) {
      if (this.load_ids.length) {
        this.load_qnr = this.load_qnr_route;
        if (this.load_qnr_route != this.load_qnr_map) {
        } else {
          if (this.load_qnr < this.load_ids.length) {
            var Q = this.load_ids[this.load_qnr];
            this.load_3drerun_fromid(Q);
          } else {
            this.load_ids = new Array();
            this.load_qnr_route = 0;
            this.load_qnr_map = 0;
            this.load_qnr = 0;
            z.updateinfobottomdiv();
            if (z.settings.calibrationmode) {
              z.apply_initial_calibration();
            } else {
              if (z.loadStatedata == null) {
                if (z.map.width == null && z.routes.length == 0) {
                } else {
                  if (z.map.width == null) {
                    z.load_blank_map();
                  }
                }
                if (loadcourse) {
                  setTimeout("mapviewer.loadCourse(loadcourse);", 10000);
                }
                if (getURLParameter("coursefile") && loadcourse == 0) {
                  loadcourse = -1;
                  z.loadcoursefromURLParameter();
                }
                if (z.routes.length > 0) {
                  for (var O = 0; O < z.routes.length; O++) {
                    var M = z.routes[O];
                    if (M.zerotime < z.zerotime) {
                      z.zerotime = M.zerotime;
                    }
                    if (M.zerotime + M.latarray.length > z.maxtime) {
                      z.maxtime = M.zerotime + M.latarray.length;
                    }
                  }
                  var M = z.routes[0];
                  P1 = z.map.toxy(M.latarray[0], M.lngarray[0]);
                  z.map_start_x = P1.x;
                  z.map_start_y = P1.y;
                  z.canvas.context.scale(2, 2);
                  z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
                  z.AllRoutestoStart();
                  z.playtime = z.zerotime;
                  z.reset_replaystarttime();
                  z.update_routediv(false);
                } else {
                  if (z.IsLive) {
                    $("#" + this.routemenudiv).html(
                      "Trying to load live data."
                    );
                    $("#selectmode").append(
                      '<option value="live" selected>Live mode</option>'
                    );
                    $("#playspeedr").hide();
                    $("#realtime").hide();
                    $("#playcontrol").hide();
                    $("#autobutton").hide();
                    $("#autoanalysis_adjust").hide();
                    $("#detailedanalysis_settings").hide();
                    z.initLive(0);
                  } else {
                    $("#" + this.routemenudiv).html(
                      "Note! Found no routes to load! Showing map only."
                    );
                  }
                }
                if (getURLParameter("softid")) {
                  var N = getURLParameter("softid");
                  z.load_softsessiongroup(N);
                }
                if (z.map.width == null) {
                  alert(
                    "Problems loading background map. Are you sure you chose a map? It might also be that the map is private. If you do not have a background map for your current route(s), please use the 3D version - 3DRerun - which can do the analysis on satelite picture."
                  );
                }
                z.request_redraw();
              } else {
                if (z.map.width == null) {
                  z.load_blank_map();
                }
                z.applyloadState();
              }
            }
          }
        }
      }
    }
  };
  this.apply_calibration = function () {
    $("#calstrfield").val(
      this.map.width + "|" + this.map.height + "|" + this.map.calstring
    );
    $("#calform").submit();
  };
  this.load_blank_map = function () {
    var ac = 1600;
    var ai = 1600;
    var aj = 1e99;
    var Y = -1e99;
    var ae = 1e99;
    var O = -1e99;
    var M = 0;
    var X = 0;
    var Q = 0;
    var ab = 0;
    thisroute = this.routes[0];
    if (!thisroute) {
      thisroute = new Route(
        "0;0;1;1;0",
        "0;1;1;0;0",
        "0;1;2;3;4",
        "No data",
        "",
        "#ff0000",
        1,
        z.routes.length + 1,
        null,
        null,
        null
      );
      z.routes[0] = thisroute;
    }
    for (j = 0; j < thisroute.latarray.length; j++) {
      if (thisroute.latarray[j] < aj) {
        aj = thisroute.latarray[j];
        M = j;
      }
      if (thisroute.latarray[j] > Y) {
        Y = thisroute.latarray[j];
        X = j;
      }
      if (thisroute.lngarray[j] < ae) {
        ae = thisroute.lngarray[j];
        Q = j;
      }
      if (thisroute.lngarray[j] > O) {
        O = thisroute.lngarray[j];
        ab = j;
      }
    }
    var ah =
      "" +
      (thisroute.latarray[0] + 0.5) +
      ";" +
      (thisroute.latarray[0] - 0.5) +
      ";" +
      (thisroute.lngarray[0] + 0.5) +
      ";" +
      (thisroute.lngarray[0] - 0.5) +
      ";0";
    var S = calcdistance(Y, O, aj, O);
    var T = calcdistance(Y, O, Y, ae);
    var ag = "" + Y + ";" + aj + ";" + O + ";" + ae + ";0";
    var Z = S / (Y - aj);
    var aa = T / (O - ae);
    var af;
    af = 1;
    var N = (ae + O) / 2;
    var R = N - (((af * S) / T) * (O - ae)) / 2;
    var U = N + (((af * S) / T) * (O - ae)) / 2;
    var V = (aj + Y) / 2;
    var W = V - (af * (Y - aj)) / 2;
    var ad = V + (af * (Y - aj)) / 2;
    var S = calcdistance(ad, N, W, N);
    var T = calcdistance(V, U, V, R);
    var ag = "" + ad + ";" + W + ";" + U + ";" + R + ";0";
    calstring = ag;
    if (z.offline) {
      z.loadmap("dep/blank1600.gif", ac, ai, calstring, "qr");
    } else {
      z.loadmap("/images/blank1600.gif", ac, ai, calstring, "qr");
    }
  };
  this.calibratemap = function (M) {
    this.settings.calibrationmode = 1;
    this.apply_calinfo = M;
    $("#" + this.menudiv).html(
      "<b>Calibrate map</b><br>Drag the three red points in order to adjust the route to the map. You may replace any of the red points by clicking anywhere on the course - that will move the closest red point to this position.<p>When you are finished, click below to finish calibration and add the map to 2DRerun/3DRerun.<p><form id='calform' action='../upload.php' method='GET'><input type=hidden name='t' value='mapwithrouteadjust' > <input type=hidden name='uploadpcfile' value='" +
        M.uploadpcfile +
        "'> <input type=hidden name='uploadwebfile' value='" +
        M.uploadwebfile +
        "'> <input type=hidden name='md5' value='" +
        M.md5 +
        "'> <input type=hidden name='privatemaps' value='" +
        M.privatemaps +
        "'> <input type=hidden name='localurl' value='" +
        M.localurl +
        "'> <input type=hidden name='imagelink' value='" +
        M.imagelink +
        "'> <input type=hidden name='compname' value='" +
        M.compname +
        "'> <input type=hidden name='date' value='" +
        M.date +
        "'> <input type=hidden id='calstrfield' name='calstr' value=''> <input type=hidden name='a' value='dochange'> </form><button onclick='mapviewer.apply_calibration()'>Finish calibration</button>"
    );
    this.load_ids = M.ids;
    this.load3DRerun_maps = null;
    this.load3DRerun_routes = null;
    this.load_qnr_route = 0;
    this.load_qnr_map = 0;
    this.load_qnr = 0;
    this.load3DRerun_next_in_queue();
  };
  this.recalibratemap = function (M) {
    this.settings.calibrationmode = 2;
    M.maploaded = 0;
    this.apply_calinfo = M;
    tmapid = M.ids[0];
    trouteid = M.ids[1];
    $("#" + this.menudiv).html(
      "<b>Recalibrate map (experimental)</b><br>Drag the three red points in order to adjust the route to the map. You may replace any of the red points by clicking anywhere on the course - that will move the closest red point to this position.<p>When you are finished, click below to finish calibration and add the recalibrated map to 2DRerun/3DRerun (the old map will not be deleted).<p><form id='calform' action='../upload.php' method='GET'><input type=hidden name='t' value='mapwithrouteadjust' > <input type=hidden name='recalibrate' value='1'><input type=hidden name='id' value='dummy'><input type=hidden name='mapid' value='" +
        tmapid +
        "'><input type=hidden name='routeid' value='" +
        trouteid +
        "'><input type=hidden id='calstrfield' name='calstr' value=''> <input type=hidden name='a' value='dochange'> </form><button onclick='mapviewer.apply_calibration()'>Recalibrate map</button>"
    );
    this.load_ids = M.ids;
    this.load3DRerun_maps = null;
    this.load3DRerun_routes = null;
    this.load_qnr_route = 0;
    this.load_qnr_map = 0;
    this.load_qnr = 0;
    this.load3DRerun_next_in_queue();
  };
  this.setup_start_recalibration = function () {
    if (this.routes.length > 0) {
      w = this.map.width;
      h = this.map.height;
      var Q = 1e99;
      var O = -1e99;
      var U = 1e99;
      var S = -1e99;
      var N = 0;
      var M = 0;
      var T = 0;
      var R = 0;
      for (j = 0; j < this.routes[0].latarray.length; j++) {
        if (this.routes[0].latarray[j] < Q) {
          Q = this.routes[0].latarray[j];
          N = j;
        }
        if (this.routes[0].latarray[j] > O) {
          O = this.routes[0].latarray[j];
          M = j;
        }
        if (this.routes[0].lngarray[j] < U) {
          U = this.routes[0].lngarray[j];
          T = j;
        }
        if (this.routes[0].lngarray[j] > S) {
          S = this.routes[0].lngarray[j];
          R = j;
        }
      }
      lat1 = this.routes[0].latarray[T];
      lng1 = this.routes[0].lngarray[T];
      lat2 = this.routes[0].latarray[R];
      lng2 = this.routes[0].lngarray[R];
      lat3 = this.routes[0].latarray[N];
      lng3 = this.routes[0].lngarray[N];
      P1 = z.map.toxy(lat1, lng1);
      P2 = z.map.toxy(lat2, lng2);
      P3 = z.map.toxy(lat3, lng3);
      x1 = P1.x;
      y1 = P1.y;
      x2 = P2.x;
      y2 = P2.y;
      x3 = P3.x;
      y3 = P3.y;
      calstring =
        lng1 +
        "|" +
        lat1 +
        "|" +
        x1 +
        "|" +
        y1 +
        "|" +
        lng2 +
        "|" +
        lat2 +
        "|" +
        x2 +
        "|" +
        y2 +
        "|" +
        lng3 +
        "|" +
        lat3 +
        "|" +
        x3 +
        "|" +
        y3;
      this.map.calstring = calstring;
      this.map.calstring_points = calstring;
      this.settings.calibrationmode = 1;
      z.Draw_all_full_routes(0);
      z.request_redraw();
    }
  };
  this.apply_initial_calibration = function () {
    if (z.settings.calibrationmode == 1) {
      var O = this.apply_calinfo;
      mapurl = O.imagelink;
      w = O.width;
      h = O.height;
      var M = 1e99;
      var Q = -1e99;
      var N = 1e99;
      var R = -1e99;
      var T = 0;
      var S = 0;
      var V = 0;
      var U = 0;
      for (j = 0; j < this.routes[0].latarray.length; j++) {
        if (this.routes[0].latarray[j] < M) {
          M = this.routes[0].latarray[j];
          T = j;
        }
        if (this.routes[0].latarray[j] > Q) {
          Q = this.routes[0].latarray[j];
          S = j;
        }
        if (this.routes[0].lngarray[j] < N) {
          N = this.routes[0].lngarray[j];
          V = j;
        }
        if (this.routes[0].lngarray[j] > R) {
          R = this.routes[0].lngarray[j];
          U = j;
        }
      }
      lat1 = this.routes[0].latarray[V];
      lng1 = this.routes[0].lngarray[V];
      lat2 = this.routes[0].latarray[U];
      lng2 = this.routes[0].lngarray[U];
      lat3 = this.routes[0].latarray[T];
      lng3 = this.routes[0].lngarray[T];
      minx = w / 5;
      miny = (4 * h) / 5;
      maxx = (4 * w) / 5;
      maxy = h / 5;
      dx = maxx - minx;
      dy = maxy - miny;
      dlat = Q - M;
      dlng = R - N;
      x1 = minx + ((lng1 - N) * dx) / dlng;
      x2 = minx + ((lng2 - N) * dx) / dlng;
      x3 = minx + ((lng3 - N) * dx) / dlng;
      y1 = miny + ((lat1 - M) * dy) / dlat;
      y2 = miny + ((lat2 - M) * dy) / dlat;
      y3 = miny + ((lat3 - M) * dy) / dlat;
      calstring =
        lng1 +
        "|" +
        lat1 +
        "|" +
        x1 +
        "|" +
        y1 +
        "|" +
        lng2 +
        "|" +
        lat2 +
        "|" +
        x2 +
        "|" +
        y2 +
        "|" +
        lng3 +
        "|" +
        lat3 +
        "|" +
        x3 +
        "|" +
        y3;
      caltype = "3point";
      z.loadmap(mapurl, O.width, O.height, calstring, caltype, null);
    } else {
      var M = 1e99;
      var Q = -1e99;
      var N = 1e99;
      var R = -1e99;
      var T = 0;
      var S = 0;
      var V = 0;
      var U = 0;
      for (j = 0; j < this.routes[0].latarray.length; j++) {
        if (this.routes[0].latarray[j] < M) {
          M = this.routes[0].latarray[j];
          T = j;
        }
        if (this.routes[0].latarray[j] > Q) {
          Q = this.routes[0].latarray[j];
          S = j;
        }
        if (this.routes[0].lngarray[j] < N) {
          N = this.routes[0].lngarray[j];
          V = j;
        }
        if (this.routes[0].lngarray[j] > R) {
          R = this.routes[0].lngarray[j];
          U = j;
        }
      }
      lat1 = this.routes[0].latarray[V];
      lng1 = this.routes[0].lngarray[V];
      lat2 = this.routes[0].latarray[U];
      lng2 = this.routes[0].lngarray[U];
      lat3 = this.routes[0].latarray[T];
      lng3 = this.routes[0].lngarray[T];
      Ptmp = z.map.toxy(lat1, lng1);
      x1 = Ptmp.x;
      y1 = Ptmp.y;
      Ptmp = z.map.toxy(lat2, lng2);
      x2 = Ptmp.x;
      y2 = Ptmp.y;
      Ptmp = z.map.toxy(lat3, lng3);
      x3 = Ptmp.x;
      y3 = Ptmp.y;
      z.map.calstring =
        lng1 +
        "|" +
        lat1 +
        "|" +
        x1 +
        "|" +
        y1 +
        "|" +
        lng2 +
        "|" +
        lat2 +
        "|" +
        x2 +
        "|" +
        y2 +
        "|" +
        lng3 +
        "|" +
        lat3 +
        "|" +
        x3 +
        "|" +
        y3;
    }
    z.Draw_all_full_routes(0);
    z.request_redraw();
  };
  this.find_initial_calstring = function () {
    var U = z.map.mapobject.width;
    var R = z.map.mapobject.height;
    var M = 1e99;
    var O = -1e99;
    var N = 1e99;
    var Q = -1e99;
    var T = 0;
    var S = 0;
    var W = 0;
    var V = 0;
    for (j = 0; j < this.routes[0].latarray.length; j++) {
      if (this.routes[0].latarray[j] < M) {
        M = this.routes[0].latarray[j];
        T = j;
      }
      if (this.routes[0].latarray[j] > O) {
        O = this.routes[0].latarray[j];
        S = j;
      }
      if (this.routes[0].lngarray[j] < N) {
        N = this.routes[0].lngarray[j];
        W = j;
      }
      if (this.routes[0].lngarray[j] > Q) {
        Q = this.routes[0].lngarray[j];
        V = j;
      }
    }
    if (V == W) {
      V = parseInt(V / 2);
      Q = this.routes[0].lngarray[V];
    }
    if (V == T) {
      V = parseInt(V / 2);
      Q = this.routes[0].lngarray[V];
    }
    lat1 = this.routes[0].latarray[W];
    lng1 = this.routes[0].lngarray[W];
    lat2 = this.routes[0].latarray[V];
    lng2 = this.routes[0].lngarray[V];
    lat3 = this.routes[0].latarray[T];
    lng3 = this.routes[0].lngarray[T];
    minx = U / 5;
    miny = (4 * R) / 5;
    maxx = (4 * U) / 5;
    maxy = R / 5;
    dx = maxx - minx;
    dy = maxy - miny;
    dlat = O - M;
    dlng = Q - N;
    x1 = minx + ((lng1 - N) * dx) / dlng;
    x2 = minx + ((lng2 - N) * dx) / dlng;
    x3 = minx + ((lng3 - N) * dx) / dlng;
    y1 = miny + ((lat1 - M) * dy) / dlat;
    y2 = miny + ((lat2 - M) * dy) / dlat;
    y3 = miny + ((lat3 - M) * dy) / dlat;
    calstring =
      lng1 +
      "|" +
      lat1 +
      "|" +
      x1 +
      "|" +
      y1 +
      "|" +
      lng2 +
      "|" +
      lat2 +
      "|" +
      x2 +
      "|" +
      y2 +
      "|" +
      lng3 +
      "|" +
      lat3 +
      "|" +
      x3 +
      "|" +
      y3;
    return calstring;
  };
  this.showcalibrationpoints = function () {
    var U = this.map.calstring;
    var R = U.split("|");
    var aa = parseFloat(R[0]);
    var T = parseFloat(R[1]);
    var Y = parseFloat(R[4]);
    var S = parseFloat(R[5]);
    var W = parseFloat(R[8]);
    var Q = parseFloat(R[9]);
    var O = parseFloat(R[2]);
    var Z = parseFloat(R[3]);
    var N = parseFloat(R[6]);
    var X = parseFloat(R[7]);
    var M = parseFloat(R[10]);
    var V = parseFloat(R[11]);
    z.canvas.setLineStyle("ff0000", 1, 6);
    z.canvas.drawCircle(O, Z, 8);
    z.canvas.drawCircle(N, X, 8);
    z.canvas.drawCircle(M, V, 8);
  };
  this.loadwinsplits_clickbutton = function (Q) {
    if (Q == "dates") {
      $("#winsplitsdiv-date").html(
        '<b>Date:</b> <select onChange="mapviewer.loadwinsplits_clickbutton(\'events\');" id="winsplitdate"></select>'
      );
      var T = '<option value="0">------------------</option>';
      var M = new Array();
      for (var R = 0; R < z.routes.length; R++) {
        var N = new Date(mapviewer.routes[0].zerotime * 1000)
          .toString()
          .substr(0, 10);
        if (!M[N]) {
          M[N] = 1;
          T += '<option value="' + N + '">' + N + "</option>";
        }
      }
      $("#winsplitdate").html(T);
    } else {
      if (Q == "events") {
        var N = $("#winsplitdate").val();
        if (N != 0) {
          $("#winsplitsdiv-event").html(
            'Loading from Winsplits...<br><img src="loading.gif">'
          );
          data = z.loadwinsplits(N, null, null, "events");
        } else {
          $("#winsplitsdiv-event").html("");
          $("#winsplitsdiv-class").html("");
          $("#winsplitsdiv-info").html("");
        }
      } else {
        if (Q == "classes") {
          var S = $("#winsplitevent").val();
          if (S != 0) {
            $("#winsplitsdiv-class").html(
              'Loading from Winsplits...<br><img src="loading.gif">'
            );
            data = z.loadwinsplits(null, S, null, "classes");
          } else {
            $("#winsplitsdiv-class").html("");
            $("#winsplitsdiv-info").html("");
          }
        } else {
          if (Q == "eventdata") {
            $("#winsplitsdiv-info").html(
              'Loading from Winsplits...<br><img src="loading.gif">'
            );
            var S = $("#winsplitevent").val();
            var O = $("#winsplitclass").val();
            if (S != 0 && O != 0) {
              data = z.loadwinsplits(null, S, O, "eventdata");
            } else {
              $("#winsplitsdiv-class").html("");
            }
          } else {
          }
        }
      }
    }
  };
  this.loadwinsplits_process = function (M, N) {
    tmptmp = N;
    if (M == "events") {
      if (N) {
        eventstr =
          '<b>Event:</b> <select onChange="mapviewer.loadwinsplits_clickbutton(\'classes\');" id="winsplitevent">';
        eventstr += '<option value="0">------------------</option>';
        $(parseXml(N))
          .find("Event")
          .each(function () {
            var R = $(this).attr("modifyTime");
            var S = parseInt($(this).find("Id").first().text());
            var Q = $(this).find("Name").text();
            if (Q.length > 20) {
              Q = Q.substr(0, 18) + " ..";
            }
            var O = $(this).find("StartTime").find("Date").text();
            eventstr += "<option value=" + S + ">" + Q + "</option>";
          });
        eventstr += "</select>";
        $("#winsplitsdiv-event").html(eventstr);
      } else {
        $("#winsplitsdiv-event").html("Found no data for this date!");
      }
    } else {
      if (M == "classes") {
        if (N) {
          eventstr =
            '<b>Class:</b> <select onChange="mapviewer.loadwinsplits_clickbutton(\'eventdata\');" id="winsplitclass">';
          eventstr += '<option value="0">------------------</option>';
          $(parseXml(N))
            .find("Class")
            .each(function () {
              var Q = parseInt($(this).find("Id").text());
              var O = $(this).find("ShortName").text();
              eventstr += "<option value=" + Q + ">" + O + "</option>";
            });
          eventstr += "</select>";
          $("#winsplitsdiv-class").html(eventstr);
        } else {
          $("#winsplitsdiv-class").html("Found no data for this event?!");
        }
      } else {
        if (M == "eventdata") {
          if (N) {
            $("#winsplitsdiv-info").html(
              "Splits loaded from Winsplits. Now processing!"
            );
            z.parse_xmlsplits_fromtxt(N);
          } else {
            $("#winsplitsdiv-info").html("Found no data for this event?!");
          }
        }
      }
    }
  };
  this.loadwinsplits = function (M, S, N, Q) {
    var R;
    var O = null;
    if (M) {
      R = "loadwinsplits.php?date=" + M;
    } else {
      if (S && N) {
        R = "loadwinsplits.php?id=" + S + "&classid=" + N;
      } else {
        if (S) {
          R = "loadwinsplits.php?id=" + S;
        }
      }
    }
    if (R) {
      isasync = true;
      $.ajax({
        type: "GET",
        url: R,
        dataType: "xml",
        async: isasync,
        error: function (U, V, T) {
          alert("Unexpected error: Could not read splits info!");
          z.loadwinsplits_process(Q, null);
          return;
        },
        success: function (T) {
          O = T;
          if (Q) {
            z.loadwinsplits_process(Q, O);
          }
        },
      });
      return O;
    }
  };
  this.loadseu = function (O, N) {
    var M = "getseu_json.php?baseurl=" + O + "&idstr=" + N;
    if (getURLParameter("clear")) {
      M = M + "&clear=1";
    }
    $.ajax({
      type: "GET",
      url: M,
      dataType: "json",
      error: function (R, S, Q) {
        alert("Unexpected error: Could not read map info!");
        return;
      },
      success: function (U) {
        if (U != undefined) {
          var ab = U.status;
          if (ab != "OK") {
            alert("Error: " + ab);
          } else {
            mapurl = U.map.imagelink;
            mapwidth = U.map.width;
            mapheight = U.map.height;
            calstring = U.map.calstring;
            caltype = "3point";
            if (mapurl) {
              z.loadmap(
                mapurl,
                mapwidth,
                mapheight,
                calstring,
                caltype,
                null,
                N
              );
              z.redraw();
            } else {
              var T = getURLParameter("osm");
              if (T) {
                z.loadmap(
                  mapurl,
                  mapwidth,
                  mapheight,
                  calstring,
                  "3point",
                  null,
                  "OSM"
                );
              } else {
                var Z = getURLParameter("mapid");
                z.load3DRerun([Z], null, null);
                z.redraw();
              }
            }
            if (!z.IsLive) {
              for (var R = 0; R < U.routes.length; R++) {
                var aa = U.routes[R].unit;
                var X = U.routes[R].lats;
                var ac = U.routes[R].lngs;
                var Q = U.routes[R].times;
                var Y = U.routes[R].runnername;
                Y = Y.replace(/^\d+ /, "");
                var S = z.getnextcolor();
                Y = Y.replace(/-/, "");
                var V = new Route(
                  X,
                  ac,
                  Q,
                  Y,
                  aa,
                  S,
                  1,
                  z.routes.length + 1,
                  null,
                  null,
                  null
                );
                z.routes[R] = V;
                if (V.zerotime < z.zerotime) {
                  z.zerotime = V.zerotime;
                }
                if (V.zerotime + V.latarray.length > z.maxtime) {
                  z.maxtime = V.zerotime + V.latarray.length;
                }
              }
              z.playtime = z.zerotime;
              z.reset_replaystarttime();
              z.update_routediv(false);
              var V = z.routes[0];
              P1 = z.map.toxy(V.latarray[0], V.lngarray[0]);
              for (var W = 0; W < mapviewer.routes.length; W++) {
                for (var R = 0; R < mapviewer.routes[W].latarray.length; R++) {
                  if (isNaN(mapviewer.routes[W].latarray[R])) {
                    mapviewer.routes[W].latarray[R] =
                      mapviewer.routes[W].latarray[R - 1];
                  }
                }
              }
              for (var W = 0; W < mapviewer.routes.length; W++) {
                for (var R = 0; R < mapviewer.routes[W].latarray.length; R++) {
                  if (isNaN(mapviewer.routes[W].lngarray[R])) {
                    mapviewer.routes[W].lngarray[R] =
                      mapviewer.routes[W].lngarray[R - 1];
                  }
                }
              }
              z.map_start_x = P1.x;
              z.map_start_y = P1.y;
              z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
              z.AllRoutestoStart();
            } else {
              $("#" + z.routemenudiv).html("No routes loaded.");
            }
            if ($("#addseurantaroutesinfo")) {
              $("#addseurantaroutesinfo").html("Data loaded");
            }
            z.loadcoursesplitsidstr();
            z.request_redraw();
          }
        }
      },
    });
    return 1;
  };
  this.errormessage = function (M) {
    alert(M);
  };
  this.infomessage = function (M) {};
  this.load_softsessiongroup = function (N) {
    var M =
      "http://softtracking.cloudapp.net:80/api/internal/sessions?sessionGroupId=" +
      N +
      "&includeInformation=true&includePositions=true&includeSessionGroups=true";
    $.ajax({
      type: "GET",
      url: M,
      dataType: "json",
      error: function (Q, R, O) {
        z.errormessage(
          "Error loading from SOFT session group " +
            sessiongroupid +
            " <i>" +
            R +
            "</i>"
        );
      },
      success: function (V) {
        tmptmp = V;
        for (var R = 0; R < V.length; R++) {
          var W = V[R];
          var ad = W.deviceId;
          var T = "SOFT-" + W.id;
          var Z = W.person;
          if (!Z) {
            Z = "Runner " + (z.routes.length + 1);
          }
          var O = new Array();
          var X = new Array();
          var ae = new Array();
          var af = null;
          var Y = null;
          var ac = W.positions;
          for (var Q = 0; Q < ac.length; Q++) {
            var S = convert_datetime_tosec(ac[Q].time);
            var aa = ac[Q].geoCoordinate.latitude;
            var ab = ac[Q].geoCoordinate.longitude;
            O.push(S);
            X.push(aa);
            ae.push(ab);
          }
          tmptmp2 = X;
          var U = z.getnextcolor();
          Z = Z.replace(/-/, "");
          var W = new Route(
            X.join(";"),
            ae.join(";"),
            O.join(";"),
            Z,
            ad,
            U,
            1,
            z.routes.length + 1,
            T,
            Y,
            af
          );
          z.routes[z.routes.length] = W;
          if (W.zerotime < z.zerotime) {
            z.zerotime = W.zerotime;
          }
          if (W.zerotime + W.latarray.length > z.maxtime) {
            z.maxtime = W.zerotime + W.latarray.length;
          }
          if (!z.playtime || z.playtime == 1e99) {
            z.playtime = z.zerotime;
            z.reset_replaystarttime();
          }
          z.update_routediv(0);
          z.request_redraw();
        }
      },
    });
  };
  this.load_jsonroute = function (O, Q, N, M) {
    $.ajax({
      type: "GET",
      url: O,
      dataType: "json",
      error: function (S, T, R) {
        z.errormessage(
          "Error loading json-file from " + O + " <i>" + T + "</i>"
        );
        z.load_qnr_route++;
        z.load3DRerun_next_in_queue();
      },
      success: function (U) {
        var aa;
        var W = U.lats;
        var ac = U.lngs;
        var S = U.times;
        var X = U.runnername;
        var Y = U.datetime;
        var ad = U.mapreading;
        if (U.unit) {
          aa = U.unit;
        } else {
          aa = "";
        }
        var T = z.getnextcolor();
        X = X.replace(/-/, "");
        if (xc && Y) {
          X = X + " " + Y.substr(0, 10);
        }
        var V = new Route(W, ac, S, X, aa, T, 1, z.routes.length + 1, Q, N, ad);
        z.routes[z.routes.length] = V;
        var Z = U.pulse;
        var R = z.datafieldtypes;
        for (var ab = 0; ab < R.length; ab++) {
          if (U[R[ab]] != null) {
            if (U[R[ab]].indexOf("|") == -1) {
              V.addfield_interp(R[ab], U[R[ab]], S);
            } else {
              V.addfield_startstopval(R[ab], U[R[ab]]);
            }
            mapviewer.used_fieldtypes[R[ab]] = 1;
          }
        }
        if (V.zerotime < z.zerotime) {
          z.zerotime = V.zerotime;
        }
        if (V.zerotime + V.latarray.length > z.maxtime) {
          z.maxtime = V.zerotime + V.latarray.length;
        }
        if (!z.playtime || z.playtime == 1e99) {
          z.playtime = z.zerotime;
          z.reset_replaystarttime();
        }
        if (M == 1) {
          z.load_qnr_route++;
          z.load3DRerun_next_in_queue();
        } else {
          z.update_routediv(0);
        }
        z.request_redraw();
      },
    });
  };
  this.load_3drerun_fromid = function (O) {
    var N = O;
    var M;
    if (xc) {
      M = "../getrouteinfo_xc.php?id=" + O;
    } else {
      M = "../getrouteinfo.php?id=" + O;
    }
    $.ajax({
      type: "GET",
      url: M,
      dataType: "json",
      error: function (R, S, Q) {
        z.errormessage(
          "Tried to read " +
            M +
            ". Unknown error - it just unexpectedly did not work!"
        );
        z.errormessage("Error loading route/map!<i>" + S + "</i>");
        z.load_qnr_route++;
        z.load_qnr_map++;
        z.load3DRerun_next_in_queue();
      },
      success: function (S) {
        if (S != undefined) {
          var T = parseInt(S.isroute);
          var R = parseInt(S.ismap);
          if (z.load3DRerun_maps != null) {
            R = z.load3DRerun_maps[z.load_qnr_map];
            T = z.load3DRerun_routes[z.load_qnr_map];
          }
          if (z.IsLive) {
            T = 0;
          }
          if (z.settings.calibrationmode == 1) {
            R = 0;
          } else {
            if (z.settings.calibrationmode == 2) {
              if (!z.apply_calinfo.maploaded) {
                R = 1;
                T = 0;
                z.apply_calinfo.maploaded = 1;
              } else {
                R = 0;
                T = 1;
              }
            }
          }
          var Q = S.md5;
          if (R && Q) {
            if (z.map.width == null) {
              z.load_map_fromdata(S, O);
            }
            z.load_qnr_map++;
            z.load3DRerun_next_in_queue();
          } else {
            z.load_qnr_map++;
            z.load3DRerun_next_in_queue();
          }
          if (T && Q) {
            z.load_3drerunroute_frommd5(Q, N, 1);
          } else {
            z.load_qnr_route++;
            z.load3DRerun_next_in_queue();
          }
          if (!R && !T) {
            z.errormessage(
              "Error - no route/map associated with this ID!<i> " +
                textStatus +
                "</i>"
            );
          } else {
            if (!Q) {
              console.log("Error - no md5 for this ID!");
            }
          }
        } else {
          z.errormessage("Error - no route/map found!");
          z.load_qnr_route++;
          z.load_qnr_map++;
          z.load3DRerun_next_in_queue();
        }
      },
    });
  };
  this.load_3drerunroute_frommd5 = function (N, O, M) {
    if (!test) {
      if (xc) {
        z.load_jsonroute("../xctracks/" + N + ".json", O, N, M);
      } else {
        z.load_jsonroute("/routes/" + N + ".json", O, N, M);
      }
    } else {
      z.load_jsonroute("test.php?md5=" + N, O, N, M);
    }
  };
  this.load_map_fromdata = function (M, N) {
    if (M.compname) {
      compname = M.compname;
    } else {
      compname = "Noname";
    }
    mapurl = M.imagelink;
    calstring = M.quickrouteinfo;
    el = calstring.split(";");
    mapwidth = parseFloat(el[13]);
    mapheight = parseFloat(el[14]);
    if (!mapwidth || !mapheight) {
      z.errormessage(
        "This map is not supported in the 2D-viewer for now. Can not find width/height for this map. Please send an email to jan@kocbach.net with the full URL"
      );
    } else {
      caltype = "qr";
      z.loadmap(mapurl, mapwidth, mapheight, calstring, caltype, N, compname);
    }
  };
  this.findclosestmarker = function (Q, R, X) {
    var Y = null;
    var aa = null;
    var N = 1e99;
    for (var O = 0; O < z.routes.length; O++) {
      if (z.routes[O].show) {
        var U;
        var T = z.routes[O];
        if (X == "currpos") {
          var Z = parseInt(
            z.playtime - z.routes[O].zerotime + z.routes[O].offset
          );
          if (Z < 0) {
            Z = 0;
          }
          if (Z > z.routes[O].latarray.length) {
            Z = z.routes[O].latarray.length - 1;
          }
          var V = z.routes[O].latarray[Z];
          var W = z.routes[O].lngarray[Z];
          U = new Object();
          U.distance = calcdistance(V, W, Q, R);
          var S = new LatLng(V, W);
          U.P = S;
          U.index = Z;
        } else {
          if (X == "shownsegment") {
            U = T.findclosestpoint(Q, R, "shownsegment", -1);
          }
        }
        var M = U.distance;
        if (M < N) {
          N = M;
          Y = O;
          aa = U;
          aa.markernu = O;
          aa.offset = z.routes[O].offset;
          aa.taillength = z.routes[O].taillength;
          this.tmp = aa;
        }
      }
    }
    if (aa) {
      Pclosest = z.map.toxy(aa.P.lat, aa.P.lng);
    } else {
      Pclosest = null;
    }
    return aa;
  };
  this.findclosesttagpoint = function (S, T) {
    var Y = null;
    var Z = null;
    var N = 1e99;
    for (var O = 0; O < z.currenttag.pointsxy.length; O++) {
      var W;
      var U = z.currenttag.pointsxy[O];
      var X = U.split(",");
      var R = X[0];
      var Q = X[1];
      var V = z.map.tolatlng(R, Q);
      W = new Object();
      W.x = R;
      W.y = Q;
      W.distance = calcdistance(V.lat, V.lng, S, T);
      W.P = V;
      W.index = O;
      var M = W.distance;
      if (M < N) {
        N = M;
        Y = O;
        Z = W;
        Z.pnu = O;
      }
    }
    return Z;
  };
  this.findclosestcontrolnumber = function (U, W) {
    var S = null;
    var aa = null;
    var O = 1e99;
    var N = new Array();
    for (var Q = 1; Q < z.coursecontrolcoords.length; Q++) {
      var Y;
      var V = z.coursecontrolcoords[Q];
      if (V) {
        var Z = V.split(",");
        var T = Z[0];
        var R = Z[1];
        var X = z.map.tolatlng(T, R);
        Y = new Object();
        Y.x = T;
        Y.y = R;
        Y.distance = calcdistance(X.lat, X.lng, U, W);
        Y.P = X;
        Y.index = Q;
        var M = Y.distance;
        N[Q] = M;
        if (M < O) {
          O = M;
          S = Q;
          aa = Y;
          aa.controlnu = Q;
        }
      }
    }
    return aa;
  };
  this.findclosestcontrol = function (U, W) {
    var S = null;
    var ad = null;
    var O = 1e99;
    var N = new Array();
    for (var Q = 0; Q < z.coursecoords.length; Q++) {
      var Z;
      var V = z.coursecoords[Q];
      var ac = V.split(",");
      var T = ac[0];
      var R = ac[1];
      var Y = z.map.tolatlng(T, R);
      Z = new Object();
      Z.x = T;
      Z.y = R;
      Z.distance = calcdistance(Y.lat, Y.lng, U, W);
      Z.P = Y;
      Z.index = Q;
      var M = Z.distance;
      N[Q] = M;
      if (M < O) {
        O = M;
        S = Q;
        ad = Z;
        ad.controlnu = Q;
      }
    }
    var ab = 0;
    if (S == 0) {
      ab = 1;
    } else {
      if (S == z.coursecoords.length - 1) {
        ab = z.coursecoords.length - 2;
      } else {
        var X = N[S - 1];
        var aa = N[S + 1];
        if (X < aa) {
          ab = S - 1;
        } else {
          ab = S + 1;
        }
      }
    }
    ad.controlnu_next = ab;
    return ad;
  };
  this.findclosestleg = function (T, N) {
    var ad = null;
    var S = null;
    var Y = 1e99;
    for (var O = 0; O < z.coursecoords.length - 1; O++) {
      var ac;
      var M = z.coursecoords[O];
      var V = z.coursecoords[O + 1];
      var Z = M.split(",");
      var W = parseInt(Z[0]);
      var af = parseInt(Z[1]);
      var X = V.split(",");
      var U = parseInt(X[0]);
      var ae = parseInt(X[1]);
      var ab = (W + U) / 2;
      var aa = (af + ae) / 2;
      var R = z.map.tolatlng(ab, aa);
      ac = new Object();
      ac.x = ab;
      ac.y = aa;
      ac.distance = calcdistance(R.lat, R.lng, T, N);
      ac.P = R;
      ac.index = O;
      var Q = ac.distance;
      if (Q < Y) {
        Y = Q;
        ad = O + 1;
        S = ac;
        S.controlnu = ad;
      }
    }
    return S;
  };
  this.findclosestcalpoint = function (X, R) {
    var Z = null;
    var W = null;
    var Y = 1e99;
    var N = this.map.calstring_points;
    var af = N.split("|");
    var ag = parseFloat(af[2]);
    var Q = parseFloat(af[3]);
    var ae = parseFloat(af[6]);
    var O = parseFloat(af[7]);
    var ac = parseFloat(af[10]);
    var M = parseFloat(af[11]);
    var ah = new Array();
    ah[0] = ag + "," + Q;
    ah[1] = ae + "," + O;
    ah[2] = ac + "," + M;
    for (var S = 0; S < ah.length; S++) {
      var ad;
      var U = ah[S].split(",");
      var ab = U[0];
      var aa = U[1];
      var V = z.map.tolatlng(ab, aa);
      ad = new Object();
      ad.x = ab;
      ad.y = aa;
      ad.distance = calcdistance(V.lat, V.lng, X, R);
      ad.P = V;
      ad.index = S;
      var T = ad.distance;
      if (T < Y) {
        Y = T;
        Z = S;
        W = ad;
        W.calpoint = S;
      }
    }
    return W;
  };
  this.xc_savegraphs = function () {
    z = mapviewer;
    $("#selectgraph-1").val(4);
    mapviewer.doplotcoursegraph();
    z.saveimage_size(1, "elevation.png");
    var Q = "";
    var aa = new Array();
    for (var T = 0; T < z.routes.length; T++) {
      if (z.routes[T].show) {
        aa[T] = 1;
      } else {
        aa[T] = 0;
      }
    }
    var V = new Array();
    var ab = new Array();
    var S = new Array();
    var ad = new Array();
    var N = new Array();
    var M = 1;
    var U = -1;
    for (var O = 0; O < z.routes.length; O++) {
      if (aa[O]) {
        var R = z.routes[O].runnername.split("-");
        if (!V[R[0]]) {
          V[R[0]] = M;
          ab[M] = R[0];
          N[R[0]] = 0;
          ad[M] = O;
          S[M] = z.routes[O].runnername_long;
          M++;
        }
        N[R[0]] = N[R[0]] + z.routes[O].latarray.length;
        if (parseInt(R[1]) > U) {
          U = parseInt(R[1]);
        }
      }
    }
    settings = new Object();
    settings.ptype = "tid";
    Q = Q + "!Lopsopplegg_Alle,";
    filebase = "";
    $("#savedfiles").val("");
    for (var Y = 2; Y <= U; Y++) {
      type = "lopsopplegg_lap_n";
      filename = filebase + "Lopsopplegg_runde_" + Y;
      settings.lap = Y;
      z.xc_makegraph(type, settings, aa);
      z.saveimage_size(1, filename + ".png");
      Q = Q + filename + ".png,";
    }
    Q = Q + "!Tidstap_per_runde,";
    settings = new Object();
    settings.ptype = "tid";
    for (var Y = 1; Y <= U; Y++) {
      type = "all_lap_n";
      filename = filebase + "Tidstap_til_beste_runde_" + Y;
      settings.lap = Y;
      z.xc_makegraph(type, settings, aa);
      z.saveimage_size(1, filename + ".png");
      Q = Q + filename + ".png,";
    }
    settings = new Object();
    for (var O = 1; O < ab.length; O++) {
      var Z = S[O];
      Z = Z.replace(/ /g, "");
      Q = Q + "!" + Z + ",";
      settings.ptype = "tid";
      type = "each_cmp_best";
      var ac = S[O];
      filename =
        filebase + ac + "_sammenligning_runde_per_runde_" + settings.ptype;
      filename = filename.replace(/ /g, "");
      settings.athlete_number = O;
      z.xc_makegraph(type, settings, aa);
      z.saveimage_size(1, filename + ".png");
      Q = Q + filename + ".png,";
      if (z.routes[ad[O]].dspeed) {
        filename =
          filebase +
          ac +
          "_dspeed_sammenligning_runde_per_runde_" +
          settings.ptype;
        filename = filename.replace(/ /g, "");
        settings.ptype = "dspeed";
        z.xc_makegraph(type, settings, aa);
        z.saveimage_size(1, filename + ".png");
        Q = Q + filename + ".png,";
      }
      for (var W = 0; W <= 2; W++) {
        if (W == 0) {
          settings.ptype = "tid";
        } else {
          if (W == 1) {
            settings.ptype = "puls";
          } else {
            if (W == 2) {
              settings.ptype = "dspeed";
            } else {
              if (W == 3) {
                settings.ptype = "syklusvei";
              } else {
                if (W == 4) {
                  settings.ptype = "frekvens";
                }
              }
            }
          }
        }
        var X = 1;
        if (settings.ptype == "puls") {
          if (!z.routes[ad[O]].maxpulse || z.routes[ad[O]].maxpulse < 10) {
            X = 0;
          }
        }
        if (U <= 1 && settings.ptype == "tid") {
          X = 0;
        }
        if (X) {
          type = "each_cmp_lopsopplegg";
          filename = filebase + S[O] + "_lopsopplegg_" + settings.ptype;
          filename = filename.replace(/ /g, "");
          settings.athlete_number = O;
          z.xc_makegraph(type, settings, aa);
          z.saveimage_size(1, filename + ".png");
          Q = Q + filename + ".png,";
        }
      }
    }
    Q = Q.substr(0, Q.length - 1);
    $("#savedfiles").val(Q);
    $("#savefilename").val(filebase + "PowerPoint");
    z.makeppt_fromtxtarea();
    for (var T = 0; T < z.routes.length; T++) {
      z.routes[T].show = aa[T];
    }
    $("#selectgraph-1").val(1);
    $("#selectgraph-2").val(4);
    $("#selectgraph-3").val(0);
    $("#selectgraph-4").val(0);
    z.recolorxc("byathlete");
    z.plotgraphs();
  };
  this.make_biathlon_shoot_ppt = function () {
    var U = "";
    var M = mapviewer;
    var O = M.courseinfo.lap_spacing.length;
    var R = new Array();
    for (var Q = 0; Q < M.routes.length; Q++) {
      if (M.routes[Q].show) {
        R[Q] = 1;
      } else {
        R[Q] = 0;
      }
    }
    for (var T = 1; T <= O; T++) {
      $("#biabetween").val(T);
      var N = new Object();
      N.ptype = "pulse";
      M.xc_makegraph("biathlon_singlelap", N, null);
      filename_pulse = "Shooting_pulse_" + T;
      M.saveimage_size(1, filename_pulse + ".png");
      N.ptype = "speed";
      M.xc_makegraph("biathlon_singlelap", N, null);
      filename_speed = "Shooting_speed_" + T;
      M.saveimage_size(1, filename_speed + ".png");
      U = U + "*" + filename_pulse + ".png|" + filename_speed + ".png,";
    }
    $("#biabetween").val(0);
    for (var Q = 0; Q < M.routes.length; Q++) {
      if (R[Q]) {
        M.routes[Q].show = 1;
      }
    }
    for (var Q = 0; Q < M.routes.length; Q++) {
      if (R[Q]) {
        for (var S = 0; S < M.routes.length; S++) {
          if (Q == S) {
            M.routes[S].show = 1;
          } else {
            M.routes[S].show = 0;
          }
        }
        var N = new Object();
        N.ptype = "pulse";
        M.xc_makegraph("biathlon_singleathlete", N, null);
        filename_pulse = "Shooting_pulse_" + M.routes[Q].runnername;
        filename_pulse = filename_pulse.replace(" ", "_");
        M.saveimage_size(1, filename_pulse + ".png");
        N.ptype = "speed";
        M.xc_makegraph("biathlon_singleathlete", N, null);
        filename_speed = "Shooting_speed_" + M.routes[Q].runnername;
        filename_speed = filename_speed.replace(" ", "_");
        M.saveimage_size(1, filename_speed + ".png");
        U = U + "*" + filename_pulse + ".png|" + filename_speed + ".png,";
      }
    }
    U = U.substr(0, U.length - 1);
    $("#savedfiles").val(U);
    $("#savefilename").val("PowerPoint");
    M.makeppt_fromtxtarea();
    for (var Q = 0; Q < M.routes.length; Q++) {
      if (R[Q]) {
        M.routes[Q].show = 1;
      }
    }
    var N = new Object();
    N.ptype = "pulse";
    M.xc_makegraph("biathlon_singlelap", N, null);
    for (var Q = 0; Q < M.routes.length; Q++) {
      M.routes[Q].show = R[Q];
    }
  };
  this.findlegnum = function (N, S) {
    var R = -1;
    z = mapviewer;
    var M = z.routes[N];
    var T = M.splits;
    if (T) {
      prevind = 0;
      for (var Q = 0; Q < T.length; Q++) {
        if (S < T[Q].index) {
          var O = (S - prevind) / (T[Q].index - prevind);
          R = O + Q - 1;
          break;
        }
        prevind = T[Q].index;
      }
    }
    return R;
  };
  this.xc_makegraph = function (Y, Q, Z) {
    z = mapviewer;
    if (Z == null) {
      Z = new Array();
      for (var O = 0; O < z.routes.length; O++) {
        Z[O] = 1;
      }
    }
    var X = new Array();
    var aa = new Array();
    var U = new Array();
    var N = new Array();
    var M = 1;
    var W = -1;
    for (var O = 0; O < z.routes.length; O++) {
      if (Z[O]) {
        var S = z.routes[O].runnername.split("-");
        if (!X[S[0]]) {
          X[S[0]] = M;
          aa[M] = S[0];
          N[S[0]] = 0;
          U[M] = z.routes[O].runnername_long;
          M++;
        }
        N[S[0]] = N[S[0]] + z.routes[O].latarray.length;
        if (parseInt(S[1]) > W) {
          W = parseInt(S[1]);
        }
      }
    }
    if (Q.ptype == "puls") {
      if (parseInt($("#select_maxpulseselector").val())) {
        $("#selectgraph-1").val(101);
      } else {
        $("#selectgraph-1").val(5);
      }
    } else {
      if (Q.ptype == "frekvens") {
        $("#selectgraph-1").val(6);
      } else {
        if (Q.ptype == "dspeed") {
          $("#selectgraph-1").val(31);
        } else {
          if (Q.ptype == "syklusvei") {
            $("#selectgraph-1").val(7);
          } else {
            $("#selectgraph-1").val(1);
          }
        }
      }
    }
    $("#selectgraph-2").val(4);
    $("#selectgraph-3").val(0);
    $("#selectgraph-4").val(0);
    mapviewer.showBelowFactor = -3;
    mapviewer.canvas.width = mapviewer.canvas.width - 1;
    if (Y == "each_cmp_best") {
      z.recolorxc("bylap");
      var T = Q.athlete_number;
      if (T < aa.length) {
        var R = "";
        var V = 1e99;
        for (var O = 0; O < aa.length; O++) {
          if (N[aa[O]] < V && T != O) {
            V = N[aa[O]];
            R = aa[O];
          }
        }
        for (var O = 0; O < z.routes.length; O++) {
          if (Z[O]) {
            var S = z.routes[O].runnername.split("-");
            if (S[0] == aa[T]) {
              z.routes[O].show = 1;
            } else {
              z.routes[O].show = 0;
            }
            if (S[0] == R) {
              z.routes[O].show = 1;
              if (Q.ptype == "tid") {
                z.routes[O].color = "000000";
              } else {
                if (Q.ptype == "dspeed") {
                  z.routes[O].color =
                    z.routes[O].color.substr(0, 2) +
                    "88" +
                    z.routes[O].color.substr(4, 2);
                }
              }
            }
          }
        }
        $("#cmplapnumber").val(R + "- lap-by-lap");
        $("#timegraphtype").val(1);
        $("#timegraphgridlines").val(0);
        $("#timegraphfilled").val(0);
        $("#timegraphlimit").val(2);
        mapviewer.doplotcoursegraph();
      }
    } else {
      if (Y == "each_cmp_lopsopplegg") {
        z.recolorxc("bylap");
        var T = Q.athlete_number;
        if (T < aa.length) {
          for (var O = 0; O < z.routes.length; O++) {
            if (Z[O]) {
              var S = z.routes[O].runnername.split("-");
              if (S[0] == aa[T]) {
                z.routes[O].show = 1;
              } else {
                z.routes[O].show = 0;
              }
            }
          }
          $("#cmplapnumber").val(0);
          $("#timegraphtype").val(1);
          $("#timegraphgridlines").val(0);
          $("#timegraphfilled").val(0);
          $("#timegraphlimit").val(2);
          mapviewer.doplotcoursegraph();
        }
      } else {
        if (Y == "all_lap_n") {
          z.recolorxc("byathlete");
          var ab = Q.lap;
          for (var O = 0; O < z.routes.length; O++) {
            if (Z[O]) {
              var S = z.routes[O].runnername.split("-");
              if (parseInt(S[1]) == ab) {
                z.routes[O].show = 1;
              } else {
                z.routes[O].show = 0;
              }
            }
          }
          $("#cmplapnumber").val(0);
          $("#timegraphtype").val(3);
          $("#timegraphgridlines").val(3);
          $("#timegraphfilled").val(0);
          $("#timegraphlimit").val(5);
        } else {
          if (Y == "lopsopplegg_lap_n") {
            z.recolorxc("byathlete");
            var ab = Q.lap;
            if (ab <= 1) {
              ab = 2;
            }
            for (var O = 0; O < z.routes.length; O++) {
              if (Z[O]) {
                var S = z.routes[O].runnername.split("-");
                if (parseInt(S[1]) == ab) {
                  z.routes[O].show = 1;
                } else {
                  z.routes[O].show = 0;
                }
              }
            }
            $("#cmplapnumber").val(99);
            $("#timegraphtype").val(3);
            $("#timegraphgridlines").val(3);
            $("#timegraphfilled").val(0);
            $("#timegraphlimit").val(5);
          } else {
            if (Y == "biathlon_singleathlete") {
              if (Q.ptype == "pulse") {
                $("#selectgraph-1").val(22);
              }
              if (Q.ptype == "speed") {
                $("#selectgraph-1").val(23);
              }
              z.recolorxc("bylap");
            } else {
              if (Y == "biathlon_singlelap") {
                if (Q.ptype == "pulse") {
                  $("#selectgraph-1").val(22);
                }
                if (Q.ptype == "speed") {
                  $("#selectgraph-1").val(23);
                }
                z.recolorxc("byathlete");
              }
            }
          }
        }
      }
    }
    z.update_routediv(false);
    z.request_redraw();
    z.doplotcoursegraph();
  };
  this.recolorbyvariants = function () {
    z = mapviewer;
    z.colorcounter = 0;
    for (var N = 0; N < z.variant_array.length; N++) {
      routes = z.variant_array[N].toString();
      showarray = routes.split(" ");
      if (showarray.length > 0) {
        var O = z.getnextcolor();
        for (var M = 0; M < showarray.length; M++) {
          if (z.routes[showarray[M]]) {
            z.routes[showarray[M]].color = O;
          }
        }
      }
    }
    z.request_redraw();
  };
  this.recolorxc = function (Q) {
    z.settings.recolormode = Q;
    if (Q == "bylap") {
      z = mapviewer;
      for (var S = 0; S < z.routes.length; S++) {
        var O = z.routes[S].runnername.split("-");
        if (O.length >= 1) {
          z.colorcounter = parseInt(O[1]) - 1;
        } else {
          z.colorcounter = 0;
        }
        if (!z.colorcounter) {
          z.colorcounter = 0;
        }
        z.routes[S].color = z.getnextcolor();
      }
    } else {
      if (Q == "byathlete") {
        z = mapviewer;
        var N = new Array();
        var M = 1;
        for (var S = 0; S < z.routes.length; S++) {
          var O = z.routes[S].runnername.split("-");
          if (!N[O[0]]) {
            N[O[0]] = M;
            M++;
          }
        }
        for (var S = 0; S < z.routes.length; S++) {
          var O = z.routes[S].runnername.split("-");
          z.colorcounter = N[O[0]] - 1;
          z.routes[S].color = z.getnextcolor();
        }
      } else {
        if (Q == "byshown") {
          z = mapviewer;
          z.recolorbyorg();
          z.colorcounter = 0;
          for (var S = 0; S < z.routes.length; S++) {
            if (z.routes[S].show) {
              z.routes[S].color = z.getnextcolor();
              z.routes[S].orgcolor = z.routes[S].color;
            }
          }
        } else {
          if (Q == "byall") {
            z = mapviewer;
            for (var S = 0; S < z.routes.length; S++) {
              z.colorcounter = S;
              z.routes[S].color = z.getnextcolor();
            }
            z.update_routediv(false);
            z.request_redraw();
          } else {
            if (Q == "byboth") {
              z = mapviewer;
              var N = new Array();
              var M = 1;
              for (var S = 0; S < z.routes.length; S++) {
                var O = z.routes[S].runnername.split("-");
                if (!N[O[0]]) {
                  N[O[0]] = M;
                  M++;
                }
              }
              var R = new Array(
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff",
                "00",
                "88",
                "ff"
              );
              for (var S = 0; S < z.routes.length; S++) {
                var O = z.routes[S].runnername.split("-");
                z.colorcounter = N[O[0]] - 1;
                z.routes[S].color =
                  z.getnextcolor().substr(0, 4) + R[parseInt(O[1]) - 1];
              }
              z.update_routediv(false);
              z.request_redraw();
            }
          }
        }
      }
    }
    z.update_routediv(false);
    z.request_redraw();
  };
  this.recolorbyorg = function () {
    for (var M = 0; M < z.routes.length; M++) {
      this.routes[M].color = this.routes[M].orgcolor;
    }
    z.update_routediv(false);
    z.request_redraw();
  };
  this.Routes_set_realtime = function () {
    z = mapviewer;
    for (var M = 0; M < z.routes.length; M++) {
      z.routes[M].offset = 0;
    }
    z.playtime = z.zerotime;
    z.reset_replaystarttime();
    z.update_routediv(false);
    z.realtime = 1;
    z.request_redraw();
  };
  this.realtimeslide = function () {
    z.toggleplay();
    z.playtime = parseFloat($("#realtimeslider").val());
    z.request_redraw();
    z.toggleplay();
  };
  this.updatetimer = function () {
    $("#realtimeslider").attr("min", z.zerotime);
    $("#realtimeslider").attr("max", z.maxtime);
    $("#realtimeslider").val(z.playtime);
  };
  this.showsplitanalysis_leg = function (Q, O, S, Y) {
    if (!Y) {
      Y = 0.2;
    }
    if (!O) {
      O = 8;
    }
    if (!S) {
      S = 5;
    }
    antcntrls = z.coursecoords.length;
    var M = new Array();
    for (var N = 0; N < z.routes.length; N++) {
      T = z.routes[N];
      if (T.splits) {
        if (T.splits[antcntrls - 1]) {
          tottime = T.splits[antcntrls - 1].index - T.splits[0].index;
        } else {
          tottime = 1e99;
        }
      } else {
        tottime = 1e99;
      }
      if (tottime < 0) {
        tottime = 1e99;
      }
      M.push(tottime);
    }
    sortWithIndeces(M);
    for (var N = 0; N < z.routes.length; N++) {
      var T = z.routes[M.sortIndices[N]];
      if (N < S) {
        T.include_always_plot = 1;
      } else {
        T.include_always_plot = 0;
      }
    }
    z.centerleg(Q - 1, Y);
    minoffset = 1e99;
    for (var N = 0; N < z.routes.length; N++) {
      var T = z.routes[N];
      var R = T.splits[Q];
      var W = T.splits[Q - 1];
      if (R && W) {
        var X = R.index;
        var V = X - W.index;
        if (!V) {
          T.show = 0;
        } else {
          T.show = 1;
        }
        T.offset = R.index - (z.zerotime - T.zerotime);
        T.taillength = V;
        T.segmenttime = V;
        T.segmentlength = T.calc_length(W.index, R.index);
        if (T.offset < minoffset) {
          minoffset = T.offset;
        }
      } else {
        T.segmenttime = -1;
        T.segmentlength = -1;
        T.segmentpace = 0;
        T.taillength = -1;
      }
    }
    if (T.segmenttime == -1 || isNaN(T.segmentlength)) {
      T.segmentlength = -1;
    }
    if (minoffset < 1e99) {
      for (var N = 0; N < z.routes.length; N++) {
        z.routes[N].offset = z.routes[N].offset - minoffset;
      }
      z.playtime = z.zerotime + minoffset;
    }
    z.update_routediv(false);
    var U = 0;
    for (var N = 0; N < z.routes.length; N++) {
      if (N < O || z.routes[N].include_always_plot) {
        z.routes[N].show = 1;
      } else {
        z.routes[N].show = 0;
      }
    }
    z.center_drawn_routes();
    z.request_redraw();
    z.recolorbysplit(1);
    z.update_routediv(false);
  };
  this.savesplitanalysis = function () {
    z = mapviewer;
    antcntrls = z.coursecoords.length;
    z.togglerightmenu("togglerightmenu");
    for (var O = 0; O < antcntrls - 2; O++) {
      z.settings.showcourse = 0;
      z.showsplitanalysis_leg(O + 1);
      z.play_loop();
      var M = O + 1;
      if (seurantaidstr) {
        base = seurantaidstr;
      } else {
        base = new Date().valueOf();
      }
      var Q = base + "_" + M.toFixed().pad(2, "0") + "_routes";
      z.canvas.saveDataURL(Q);
      var Q = base + "_" + M.toFixed().pad(2, "0") + "_blank";
      for (var N = 0; N < z.routes.length; N++) {
        z.routes[N].show = 0;
      }
      z.redraw();
      z.play_loop();
      z.canvas.saveDataURL(Q);
    }
    z.togglerightmenu("togglerightmenu");
  };
  this.recolorbysplit = function (S) {
    z.routes.sort(sort_segmenttimelength);
    var T = new Array(
      "008000",
      "40A000",
      "80C000",
      "C0E000",
      "FFFF00",
      "FFC000",
      "FF8000",
      "FF4000",
      "FF0000"
    );
    var N = new Array();
    for (var O = 0; O < z.routes.length; O++) {
      if (this.routes[O].segmenttime > 0 && this.routes[O].show) {
        N[O] = this.routes[O].segmenttime;
      } else {
        N[O] = undefined;
      }
    }
    var Q = N.max();
    var U = N.min();
    var R = 0;
    for (var O = 0; O < z.routes.length; O++) {
      if (this.routes[O].segmenttime > 0 && this.routes[O].show) {
        split_time = this.routes[O].segmenttime;
        var W = -1;
        if (!S) {
          for (var V = 0; V < T.length - 1; V++) {
            if (split_time <= U + (V * (Q - U)) / T.length) {
              W = V;
              V = T.length;
            }
          }
          if (W == -1) {
            W = T.length - 1;
          }
          var M = T[W];
          z.routes[O].color = M;
        } else {
          if (S == 1) {
            var M;
            if (R < T.length) {
              M = T[R];
            } else {
              M = T[T.length - 1];
            }
            z.routes[O].color = M;
            R++;
          }
        }
      }
    }
    z.update_routediv(false);
    z.request_redraw();
  };
  this.recolorbylength = function (S) {
    z.routes.sort(sort_segmenttimelength);
    var T = new Array(
      "008000",
      "40A000",
      "80C000",
      "C0E000",
      "FFFF00",
      "FFC000",
      "FF8000",
      "FF4000",
      "FF0000"
    );
    var O = new Array();
    for (var N = 0; N < z.routes.length; N++) {
      if (
        this.routes[N].segmentlength > 0 &&
        this.routes[N].segmenttime > 0 &&
        this.routes[N].show
      ) {
        O[N] = this.routes[N].segmentlength;
      } else {
        O[N] = undefined;
      }
    }
    var Q = O.max();
    var U = O.min();
    var R = 0;
    for (var N = 0; N < z.routes.length; N++) {
      if (this.routes[N].segmentlength > 0 && this.routes[N].show) {
        if (this.routes[N].segmenttime > 0) {
          split_length = this.routes[N].segmentlength;
        } else {
          split_length = undefined;
        }
        var W = -1;
        if (!S) {
          for (var V = 0; V < T.length - 1; V++) {
            if (split_length <= U + (V * (Q - U)) / T.length) {
              W = V;
              V = T.length;
            }
          }
          if (W == -1) {
            W = T.length - 1;
          }
          var M = T[W];
          z.routes[N].color = M;
        } else {
          if (S == 1) {
            var M;
            if (R < T.length) {
              M = T[R];
            } else {
              M = T[T.length - 1];
            }
            z.routes[N].color = M;
            R++;
          }
        }
      }
    }
    z.update_routediv(false);
    z.request_redraw();
  };
  this.AllRoutestoStart = function () {
    this.playtime = this.zerotime;
    z.reset_replaystarttime();
    for (j = 0; j < this.routes.length; j++) {
      this.routes[j].offset = this.routes[j].zerotime - this.zerotime;
    }
  };
  this.AutOanalysis_inner = function (ag, af, aq, S, ao, R) {
    var ae;
    var ac;
    var am;
    var ap;
    var ah = 0;
    var Z = -1;
    var ad;
    var ak;
    withindistance = z.settings.autoanalysis_withindistance;
    withinseconds_samesegment =
      z.settings.autoanalysis_withinseconds_samesegment;
    maxsamesegmentlength = z.settings.autoanalysis_maxsamesegmentlength;
    var an = this.routes[ag];
    var al = this.routes[af];
    var Y = an.latarray;
    var aj = an.lngarray;
    var X = an.timearray;
    this.autornr1 = ag;
    this.autornr2 = af;
    var Q = aq;
    var O = ao;
    var W = 0;
    for (var Q = aq; Q <= S; Q++) {
      lat1 = an.latarray[Q];
      lng1 = an.lngarray[Q];
      lat2 = al.latarray[O];
      lng2 = al.lngarray[O];
      if (W == 0) {
        var ab;
        var ai = calcdistance(lat1, lng1, lat2, lng2);
        if (ai > withindistance) {
          ab = 0;
        } else {
          ab = 1;
        }
        thissegment = new Segment(Q, O, ab, ag, af);
        this.segments[this.numsegments] = thissegment;
        this.numsegments++;
      }
      W++;
      var U = Q - thissegment.pos1start;
      if (ab) {
        Z = al.findclosestwithdistance_seconds(
          O,
          lat1,
          lng1,
          withinseconds_samesegment,
          withindistance
        );
        if (Z >= 0) {
          O = Z;
          ak = O;
          ad = Q;
          var T = O - thissegment.pos2start;
          if (T >= maxsamesegmentlength && U >= maxsamesegmentlength) {
            thissegment.pos1end = Q;
            thissegment.pos2end = O;
            thissegment.length1 = U;
            thissegment.length2 = T;
            thissegment = new Segment(Q, O, ab, ag, af);
            this.segments[this.numsegments] = thissegment;
            this.numsegments++;
          }
        } else {
          var T = O - thissegment.pos2start;
          if (U >= this.settings.minsegmentlength) {
            ab = 0;
            thissegment.pos1end = ad;
            thissegment.pos2end = ak;
            thissegment.length1 = thissegment.pos1end - thissegment.pos1start;
            thissegment.length2 = thissegment.pos2end - thissegment.pos2start;
            thissegment = new Segment(ad, ak, ab, ag, af);
            this.segments[this.numsegments] = thissegment;
            this.numsegments++;
          }
        }
      } else {
        var V = R - O;
        var Z = al.findfirstwithdistance_seconds(
          O,
          lat1,
          lng1,
          V,
          withindistance
        );
        var aa = 200;
        if (Z >= 0 && Z - O - (Q - ad) > aa) {
          if (this.ant_rechecks <= this.settings.maxrecheck) {
            if (0) {
              alert(Q - ad + "," + (Z - O));
            } else {
              for (var N = Q + 1; N <= S; N++) {
                tmplat1 = an.latarray[N];
                tmplng1 = an.lngarray[N];
                var V = R - O;
                var M = al.findfirstwithdistance_seconds(
                  O,
                  tmplat1,
                  tmplng1,
                  V,
                  withindistance
                );
                if (M < Z) {
                  Z = M;
                  Q = N;
                }
              }
            }
            this.ant_rechecks++;
          }
        }
        if (Z >= 0) {
          if (U >= this.settings.minsegmentlength) {
            var ab = 1;
            O = Z;
            var T = O - thissegment.pos2start;
            thissegment.pos1end = Q;
            thissegment.pos2end = O;
            thissegment.length1 = U;
            thissegment.length2 = T;
            thissegment = new Segment(Q, O, ab, ag, af);
            this.segments[this.numsegments] = thissegment;
            this.numsegments++;
          }
        } else {
        }
      }
    }
    var U = S - thissegment.pos1start;
    var T = R - thissegment.pos2start;
    thissegment.pos1end = S;
    thissegment.pos2end = R;
    thissegment.length1 = U;
    thissegment.length2 = T;
    this.request_redraw();
  };
  this.AutOanalysis_calcinfo = function () {
    var N = new Object();
    var Y = 0;
    var U = 0;
    var V = 0;
    var M = 0;
    var Q = 0;
    var X = new Array();
    var T = new Array();
    for (seg = Y; seg < z.numsegments; seg++) {
      thissegment = z.segments[seg];
      length1 = thissegment.length1;
      length2 = thissegment.length2;
      type = thissegment.segmenttype;
      if (type == 0) {
        V = V + length1;
        Q = Q + length2;
        if (length1 != 0) {
          T.push(length2 / length1);
        }
      } else {
        U = U + length1;
        M = M + length2;
        if (length1 != 0) {
          X.push(length2 / length1);
        }
      }
    }
    N.tot1_different = V;
    N.tot2_different = Q;
    N.tot1_same = U;
    N.tot2_same = M;
    N.same_median = median(X);
    N.different_median = median(T);
    N.tot_difference_percent = (Q + M) / (V + U);
    var W = Math.floor(((N.tot2_same - N.tot1_same) / N.tot1_same) * 100);
    if (W > 0) {
      W = "+" + W.toString();
    }
    var O = Math.floor(
      ((N.tot2_different - N.tot1_different) / N.tot1_different) * 100
    );
    if (O > 0) {
      O = "+" + O.toString();
    }
    N.same_behind_percent = W;
    N.different_behind_percent = O;
    var R = tominsec(N.tot2_same - N.tot1_same);
    if (N.tot2_same - N.tot1_same > 0) {
      R = "+" + R.toString();
    } else {
      R = "-" + R.toString();
    }
    var S = tominsec(N.tot2_different - N.tot1_different);
    if (N.tot2_different - N.tot1_different > 0) {
      S = "+" + S.toString();
    } else {
      S = "-" + S.toString();
    }
    N.same_behind = R;
    N.different_behind = S;
    return N;
  };
  this.WriteCoursePointNumber = function () {
    for (var O = 0; O < z.coursecoords.length; O++) {
      var Q = z.coursecoords[O].split(",");
      var N = Q[0];
      var M = Q[1];
      z.canvas.writeTextOutlined(
        parseInt(N) + 1,
        parseInt(M) + 1,
        "#0000ff",
        O + 1,
        parseInt(mapviewer.canvas.outlinetxtsize / 2)
      );
    }
  };
  this.WriteTextBehindCourse = function () {
    var N = new Array();
    for (var Q = 0; Q < z.routes.length; Q++) {
      if (z.routes[Q].show) {
        if (z.routes[Q].lapdata.length) {
          N.push(Q);
        } else {
        }
      }
      if (N.length > 2) {
      }
    }
    if (N.length >= 2) {
      r1 = N[0];
      r2 = N[1];
      lnr1 = 0;
      lnr2 = 0;
      fname = "times";
      times1 = z.routes[r1].lapdata[lnr1].averages[fname];
      times2 = z.routes[r2].lapdata[lnr2].averages[fname];
      acctimes1 = 0;
      acctimes2 = 0;
      for (var M = 0; M < z.courseinfo.hillsegments.length; M++) {
        thisseg = z.courseinfo.hillsegments[M];
        acctimes1 = acctimes1 + times1[M];
        acctimes2 = acctimes2 + times2[M];
        delta_acc = parseInt((acctimes2 - acctimes1) * 10) / 10;
        color = thisseg.hillcolor;
        updown_int = thisseg.thetypeint;
        percent = thisseg.percent;
        startind = thisseg.startind;
        endind = thisseg.endind;
        coords = z.coursecoords[parseInt((startind + endind) / 2)];
        xyh = coords.split(",");
        var O = mapviewer.map.tolatlng(xyh[0], xyh[1]);
        var R = new Object();
        R.txt = parseInt((times2[M] - times1[M]) * 10) / 10;
        R.color = "ff0000";
        R.lat1 = O.lat;
        R.lng1 = O.lng;
        R.lat2 = O.lat;
        R.lng2 = O.lng;
        if (Math.abs(R.txt) >= 0.3) {
          if (R.txt > 0) {
            R.txt = "+" + R.txt;
            R.color = "aa0000";
          } else {
            R.color = "00aa00";
          }
          R.txt = R.txt;
          this.writeOutlineTextLatLngDiff(
            R.lat1,
            R.lng1,
            R.lat2,
            R.lng2,
            R.txt,
            R.color
          );
        }
      }
    }
  };
  this.DrawDetailedanalysis = function () {
    z.drawroutes();
    diffs = new Array();
    for (var O = 0; O < z.detailedpoints.length; O++) {
      thispoint = z.detailedpoints[O];
      thisroute = null;
      thisroutenum = null;
      for (var R = 0; R < z.routes.length; R++) {
        if (thispoint.routemd5 == z.routes[R].md5) {
          thisroute = z.routes[R];
          thisroutenum = R;
        }
      }
      if (thisroute) {
        if (thisroute.show) {
          var N = thisroute.color;
          var W = 5;
          var T = 2;
          lat = thispoint.point.P.lat;
          lng = thispoint.point.P.lng;
          z.drawOutlineCircleLatLng(lat, lng, N, W, T);
          if (!diffs[thisroutenum]) {
            diffs[thisroutenum] = "";
          }
          diffs[thisroutenum] =
            diffs[thisroutenum] + thispoint.point.index + ";";
        }
      }
    }
    for (var O = 0; O < diffs.length; O++) {
      if (diffs[O]) {
        diffs[O] = diffs[O].substr(0, diffs[O].length - 1);
        diffarr = diffs[O].split(";");
        diffarr = diffarr.sort(function (Y, X) {
          return Y - X;
        });
        thisroute = z.routes[O];
        for (var R = 1; R < diffarr.length; R++) {
          var U = diffarr[R - 1];
          var V = diffarr[R];
          var S = thisroute.calc_length(U, V);
          var Q = V - U;
          var M = tominsec(Math.round((Q / S) * 1000));
          thetext = Math.round(S) + " m\n" + tominsec(Q) + "\n" + M + " min/km";
          var N = thisroute.color;
          tmpsize = mapviewer.canvas.outlinetxtsize;
          mapviewer.canvas.outlinetxtsize = Math.round(
            mapviewer.canvas.outlinetxtsize * 0.66
          );
          z.writeOutlineTextLatLngDiff(
            thisroute.latarray[U],
            thisroute.lngarray[U],
            thisroute.latarray[V],
            thisroute.lngarray[V],
            thetext,
            N
          );
          mapviewer.canvas.outlinetxtsize = tmpsize;
        }
      }
    }
  };
  this.DrawAutOanalysis = function () {
    var ac = this.autornr1;
    var aa = this.autornr2;
    var am = z.routes[ac];
    var al = z.routes[aa];
    var Q = z.AutOanalysis_calcinfo();
    slines = new Array();
    for (aD = 0; aD <= 1; aD++) {
      sline = new Object();
      sline.tvec = new Array();
      sline.runnername = "";
      slines[aD] = sline;
    }
    slines[0].runnername = z.routes[ac].runnername;
    slines[1].runnername = z.routes[aa].runnername;
    var au = new Array();
    var aE = new Array();
    var Z = 0;
    var Y = 0;
    var aF = 0;
    var O = 0;
    var az;
    var ai;
    var ay;
    var ah;
    var at;
    var ae;
    var ar;
    var ab;
    for (seg = aF; seg < this.numsegments; seg++) {
      thissegment = this.segments[seg];
      end1 = thissegment.pos1end;
      end2 = thissegment.pos2end;
      az = z.routes[ac].latarray[end1];
      ai = z.routes[ac].lngarray[end1];
      ay = z.routes[aa].latarray[end2];
      ah = z.routes[aa].lngarray[end2];
      type = thissegment.segmenttype;
      if (seg == aF) {
        start1 = thissegment.pos1start;
        start2 = thissegment.pos2start;
        at = this.routes[ac].latarray[start1];
        ae = this.routes[ac].lngarray[start1];
        ar = this.routes[aa].latarray[start2];
        ab = this.routes[aa].lngarray[start2];
        thistotlength1 = 0;
        thistotlength2 = 0;
      }
      thislength1 = thissegment.length1;
      thislength2 = thissegment.length2;
      thistotlength1 = thistotlength1 + thislength1;
      thistotlength2 = thistotlength2 + thislength2;
      var ao = 1;
      if (this.segments[seg].noshow) {
        ao = 0;
      }
      if (!this.segments[seg].show == 2) {
        this.segments[seg].show = 0;
      }
      if (
        (thistotlength1 >= this.settings.minsegmentlength &&
          thistotlength2 >= this.settings.minsegmentlength &&
          ao) ||
        this.segments[seg].show == 2
      ) {
        if (!this.segments[seg].show == 2) {
          this.segments[seg].show = 1;
        }
        O++;
        var W = thistotlength2 - thistotlength1;
        var aw = Math.round(thistotlength2 / Q.same_median);
        var U = aw - thistotlength1;
        var af = Math.round(thistotlength2 / Q.tot_difference_percent);
        var ap = af - thistotlength1;
        if (z.settings.autoanalysis_adjusted == 1) {
          W = U;
        } else {
          if (z.settings.autoanalysis_adjusted == 2) {
            W = ap;
          }
        }
        var aj;
        if (W > 0) {
          aj = "ff1111";
          W = "+" + W;
        } else {
          if (W < 0) {
            aj = "11ff11";
          } else {
            aj = "CDAD00";
            W = "+0";
          }
        }
        if (z.settings.autoanalysis_adjusted == 1) {
          W = W + " (s)";
        }
        if (z.settings.autoanalysis_adjusted == 2) {
          W = W + " (a)";
        }
        if (z.settings.autoanalysis_adjusted == 3) {
          if (type == 0) {
            W = "d " + W;
            aj = "ff0000";
          } else {
            W = "s " + W;
            aj = "00ff00";
          }
        }
        var S = 1;
        if (
          z.settings.autoanalysis_adjusted >= 4 &&
          z.settings.autoanalysis_adjusted <= 5
        ) {
          var aA = $("#autoanalysis_adjust_ch2").val();
          var aB = aA.split("-");
          var an = 1;
          var V = 1;
          show_threshold = parseInt(aB[1]);
          if (aB[0] == "g") {
            V = 0;
          }
          if (aB[0] == "l") {
            an = 0;
          }
          if (W >= show_threshold && V) {
            aj = "ff1111";
          } else {
            if (W <= -show_threshold && an) {
              aj = "11ff11";
            } else {
              if (z.settings.autoanalysis_adjusted == 4) {
                aj = "777777";
                S = 0;
              } else {
                aj = "777777";
                S = 2;
              }
            }
          }
        }
        if (S == 1) {
          var X = new Object();
          X.lat = az;
          X.lng = ai;
          X.seg = O;
          aE.push(X);
          var X = new Object();
          X.lat = ay;
          X.lng = ah;
          X.seg = O;
          aE.push(X);
        }
        var aq = new Object();
        aq.lat1 = at;
        aq.lat2 = az;
        aq.lng1 = ae;
        aq.lng2 = ai;
        aq.lengthdiff = W;
        aq.color = aj;
        if (
          z.settings.autoanalysis_adjusted == 6 ||
          z.settings.autoanalysis_adjusted == 7
        ) {
          var N = "";
          if (z.settings.autoanalysis_adjusted == 7) {
            N = " min/km";
          }
          l2xtra = "";
          if (W != "+0") {
            l2xtra = ", " + W + " s";
          }
          pace1 =
            (thislength1 /
              z.routes[ac].calc_length(
                thissegment.pos1start,
                thissegment.pos1end
              )) *
            1000;
          pace2 =
            (thislength2 /
              z.routes[aa].calc_length(
                thissegment.pos2start,
                thissegment.pos2end
              )) *
            1000;
          var aq = new Object();
          aq.lat1 = ar;
          aq.lat2 = ay;
          aq.lng1 = ab;
          aq.lng2 = ah;
          aq.lengthdiff = tominsecpad(pace2) + N + l2xtra;
          if (pace1 < pace2) {
            aj = "ff1111";
          } else {
            if (pace1 > pace2) {
              aj = "11ff11";
            } else {
              aj = "CDAD00";
            }
          }
          aq.color = aj;
          au.push(aq);
          var aq = new Object();
          aq.lat1 = at;
          aq.lat2 = az;
          aq.lng1 = ae;
          aq.lng2 = ai;
          aq.lengthdiff = tominsecpad(pace1) + N;
          aq.color = "0000ff";
          au.push(aq);
        } else {
          if (S == 1) {
            au.push(aq);
          }
        }
        thistotlength1 = 0;
        thistotlength2 = 0;
        var ak = this.settings.routewidth;
        if (S == 2) {
          ak = 2;
        }
        this.canvas.setLineStyle(aj, this.settings.routeopacity, ak);
        var ag = "";
        for (var aD = start2; aD <= end2; aD++) {
          lat = al.latarray[aD];
          lng = al.lngarray[aD];
          P = z.map.toxy(lat, lng);
          thisx = P.x;
          thisy = P.y;
          ag += thisx + "," + thisy + " ";
        }
        if (S > 0) {
          m.drawPoly(ag);
        }
        this.canvas.setLineStyle(
          aj,
          this.settings.routeopacity,
          this.settings.routewidth
        );
        if (
          z.settings.autoanalysis_adjusted >= 4 &&
          z.settings.autoanalysis_adjusted <= 5 &&
          S >= 1
        ) {
          var ag = "";
          this.canvas.setLineStyle("0000ff", this.settings.routeopacity, ak);
          for (var aD = start1; aD <= end1; aD++) {
            lat = am.latarray[aD];
            lng = am.lngarray[aD];
            P = z.map.toxy(lat, lng);
            thisx = P.x;
            thisy = P.y;
            ag += thisx + "," + thisy + " ";
          }
          m.drawPoly(ag);
        }
        length1 = end1 - start1;
        length2 = end2 - start2;
        Z += length1;
        Y += length2;
        slines[0].tvec.push(Z);
        slines[1].tvec.push(Y);
        length = length2;
        if (length2 > length1) {
          length = length1;
        }
        if (S > 0) {
          var R = "ff0000";
          for (var aD = 0; aD < length; aD = aD + z.settings.dotstep) {
            if (R == "ff0000") {
              R = "0000ff";
            } else {
              R = "ff0000";
            }
            if (S == 2) {
              R = "777777";
            }
            var M = Math.round(z.settings.routewidth / 4);
            if (z.settings.dotstep > 1000) {
              z.canvas.setLineStyle(R, 0.5, M * 2);
            } else {
              z.canvas.setLineStyle(R, 0.5, M);
            }
            P1 = z.map.toxy(am.latarray[aD + start1], am.lngarray[aD + start1]);
            P2 = z.map.toxy(al.latarray[aD + start2], al.lngarray[aD + start2]);
            z.canvas.drawLine(P1.x, P1.y, P2.x, P2.y);
          }
        }
        start1 = end1;
        start2 = end2;
        at = az;
        ae = ai;
        ar = ay;
        ab = ah;
      } else {
      }
    }
    if (
      z.settings.autoanalysis_adjusted < 4 ||
      z.settings.autoanalysis_adjusted >= 6
    ) {
      this.canvas.setLineStyle(
        "0000ff",
        this.settings.routeopacity,
        this.settings.routewidth
      );
      var T = am.drawRoute(
        this.map,
        this.canvas,
        this.playtime,
        this.settings.taillength,
        0
      );
    }
    for (var aD = 0; aD < aE.length; aD++) {
      X = aE[aD];
      var ax = "000000";
      var aC = X.seg;
      var av = 4;
      var ad = 1;
      if (z.splitsbrowsermarkedsegment) {
        if (
          aC == z.splitsbrowsermarkedsegment - 1 ||
          aC == z.splitsbrowsermarkedsegment
        ) {
          ax = "ffff00";
          av = 8;
          ad = 3;
        }
      }
      this.drawOutlineCircleLatLng(X.lat, X.lng, ax, av, ad);
    }
    for (var aD = 0; aD < au.length; aD++) {
      aq = au[aD];
      this.writeOutlineTextLatLngDiff(
        aq.lat1,
        aq.lng1,
        aq.lat2,
        aq.lng2,
        aq.lengthdiff,
        aq.color
      );
    }
    z.canvas.use_translated_coordinates = 0;
    xinfo = "";
    z.canvas.context.textAlign = "left";
    if (z.settings.autoanalysis_writefull) {
      xinfo =
        " (" +
        tominsec(Q.tot1_same) +
        " on same route / " +
        tominsec(Q.tot1_different) +
        " on different route)";
    }
    this.canvas.writeTextOutlined(
      10,
      this.canvas.height - 10 - this.canvas.outlinetxtsize * 1.1,
      "0000ff",
      this.routes[ac].runnername +
        " " +
        tominsec(this.routes[ac].segmenttime) +
        xinfo
    );
    xinfo = "";
    if (z.settings.autoanalysis_writefull) {
      xinfo =
        " (" +
        Q.same_behind +
        " on same route / " +
        Q.different_behind +
        " on different route)";
    }
    this.canvas.writeTextOutlined(
      10,
      this.canvas.height - 10,
      "ff0000",
      this.routes[aa].runnername +
        " " +
        tominsec(this.routes[aa].segmenttime) +
        xinfo
    );
    z.canvas.use_translated_coordinates = 1;
    if (slines[0].tvec.length > 1 && slines[1].tvec.length > 1) {
      z.splitsbrowserlines = new Array();
      z.splitsbrowserlines[0] = new SplitsbrowserLine(
        slines[0].runnername,
        slines[0].tvec
      );
      z.splitsbrowserlines[1] = new SplitsbrowserLine(
        slines[1].runnername,
        slines[1].tvec
      );
    }
    if (z.settings.showInfoBelow == "Splitsbrowser") {
      Segment_to_SplitsBrowser();
      z.request_redraw();
    }
  };
  this.AutOanalysis = function () {
    this.segments = new Array();
    this.splitsbrowsermarkedsegment = null;
    this.numsegments = 0;
    this.ant_rechecks = 0;
    this.request_redraw();
    z.update_routediv();
    var M = new Array();
    for (var N = 0; N < z.routes.length; N++) {
      if (z.routes[N].show) {
        M.push(N);
      }
      if (M.length > 2) {
        z.routes[N].show = 0;
      }
    }
    z.update_routediv();
    if (M.length > 1) {
      L1 = z.DrawnLines[M[0]];
      L2 = z.DrawnLines[M[1]];
      if (!L1 || !L2) {
        z.drawroutes();
        L1 = z.DrawnLines[M[0]];
        L2 = z.DrawnLines[M[1]];
      }
      if (L1 && L2) {
        if (L1.end == 0 || L2.end == 0) {
          alert("Part of routes for autOanalysis not defined!");
        } else {
          z.AutOanalysis_inner(M[0], M[1], L1.start, L1.end, L2.start, L2.end);
          if (!z.settings.autoanalysis) {
            z.settings.autoanalysis = 1;
          }
        }
      } else {
        alert("Not enough routes drawn!");
      }
    } else {
      alert("Not enough routes drawn - 2!");
    }
  };
  this.check_if_same_routechoice = function (R, Q, Y, U, W, T) {
    var N = this.routes[R];
    var aa = this.routes[Q];
    var V = 0;
    var O = 0;
    var S = 0;
    for (var Z = Y; Z <= U; Z++) {
      lat1 = N.latarray[Z];
      lng1 = N.lngarray[Z];
      var M = 0;
      for (var X = W; X <= T; X++) {
        lat2 = aa.latarray[X];
        lng2 = aa.lngarray[X];
        dist = calcdistance(lat1, lng1, lat2, lng2);
        if (dist < z.settings.sameroutechoice_distance) {
          M = 1;
          X = T + 1;
        }
      }
      if (M) {
        O++;
      } else {
        S++;
      }
    }
    if ((S / (O + S)) * 100 > z.settings.sameroutechoice_percent) {
      return 0;
    } else {
      return 1;
    }
  };
  this.writeOutlineTextLatLngDiff = function (T, W, S, V, U, Q) {
    var N = m.context;
    var M = z.map.toxy(T, W);
    var X = z.map.toxy(S, V);
    var R = (M.x + X.x) / 2;
    var O = (M.y + X.y) / 2;
    m.writeTextOutlined(R, O, Q, U);
  };
  this.connectpointslatlng = function (R, Q, O, N, M) {};
  this.drawOutlineCircleLatLng = function (N, T, O, M, R) {
    var Q = m.context;
    var S = z.map.toxy(N, T);
    thisx = Math.round(m.width / 2 + (S.x - m.cx) * m.zoomfactor);
    thisy = Math.round(m.height / 2 + (S.y - m.cy) * m.zoomfactor);
    if (
      (thisx > -m.outerborder &&
        thisy > -m.outerborder &&
        thisx < m.width + m.outerborder &&
        thisy < m.height + m.outerborder) ||
      z.canvas.use_rotate
    ) {
      m.setLineStyle(O, 1, R);
      if (R > 1) {
        Q.fillStyle = "rgba(1,1,1,1)";
      } else {
        Q.fillStyle = "rgba(1,1,1,.3)";
      }
      Q.beginPath();
      Q.arc(thisx, thisy, M, 0, Math.PI * 2, true);
      Q.closePath();
      Q.fill();
      Q.stroke();
    }
  };
  this.addTag = function () {
    var M = $("#savetagname").val();
    var O = $("#savetagdesc").val();
    var N = $("#tagcategory").val();
    var Q = $("#newtagtype").val();
    if (Q) {
      N = Q;
      z.settings.tagcategories[z.settings.tagcategories.length] = Q;
    }
    if (N == "-") {
      N = "";
    }
    z.currenttag.name = M;
    z.currenttag.description = O;
    z.currenttag.category = N;
    z.tags[z.tags.length] = z.currenttag;
    z.currenttag = null;
    z.request_redraw();
    z.close_dialog();
  };
  this.addrouteTag = function (U) {
    var O = $("#savetagname").val();
    var R = $("#savetagdesc").val();
    var N = $("#tagcolor").val();
    if (U) {
      var M = new Array(
        "ff0000|Red",
        "005500|Green",
        "0000ff|Blue",
        "993399|Purple",
        "0099FF|LightBlue"
      );
      var T = M[z.settings.tagging_lastcolorindex].split("|");
      N = T[0];
      z.settings.tagging_lastcolorindex++;
      if (z.settings.tagging_lastcolorindex == M.length - 1) {
        z.settings.tagging_lastcolorindex = 0;
      }
      O = "";
      R = "";
    }
    z.currenttag.name = O;
    z.currenttag.description = R;
    z.currenttag.color = N;
    var Q = 0;
    for (var S = 0; S < z.tags.length; S++) {
      if (z.currenttag == z.tags[S]) {
        Q = 1;
      }
    }
    if (!Q) {
      z.tags[z.tags.length] = z.currenttag;
    }
    z.currenttag = null;
    z.request_redraw();
    z.close_dialog();
  };
  this.saveState = function (M, W, T) {
    if (!M) {
      M = $("#savestatename").val();
      W = $("#savestatedesc").val();
      T = $("#savestatetype").val();
    }
    var X = new Object();
    X.settings = z.settings;
    X.cx = z.canvas.cx;
    X.cy = z.canvas.cy;
    X.zoomfactor = z.canvas.zoomfactor;
    X.playtime = z.playtime;
    X.zerotime = z.zerotime;
    X.routes = new Array();
    var O = "";
    for (var N = 0; N < z.routes.length; N++) {
      var R = jQuery.extend({}, z.routes[N]);
      X.routes[N] = R;
      X.routes[N].latarray = null;
      X.routes[N].lngarray = null;
      X.routes[N].timearray = null;
      if (X.routes[N].show) {
        O += X.routes[N].runnername + ", ";
      }
    }
    O = O.substr(0, O.length - 2);
    X.segments = z.segments;
    X.numsegments = z.numsegments;
    X.tags = z.tags;
    X.coursecoords = z.coursecoords;
    X.courseinfo = z.courseinfo;
    X.maps = new Array();
    for (var N = 0; N < z.maps.length; N++) {
      var V = jQuery.extend({}, z.maps[N]);
      X.maps[N] = V;
      X.maps[N].mapobject = null;
    }
    if (T == "runningwild") {
      X.settings.runningwild = 1;
      X.settings.orunningwild.sameroutechoice_distance = parseInt(
        $("#rwmetersaway").val()
      );
      X.settings.orunningwild.name = M;
      X.settings.orunningwild.description = W;
      X.settings.orunningwild.speed = parseInt($("#rwspeed").val());
      X.settings.orunningwild.showcourse = parseInt($("#rwshowcourse").val());
      X.settings.orunningwild.compareideal = parseInt(
        $("#rwcompareideal").val()
      );
      X.settings.mode = z.settings.modes.ReplayMode;
      X.settings.orunningwild.password = $("#password").val();
      X.settings.orunningwild.passworddraw = $("#passworddraw").val();
    } else {
      X.settings.runningwild = 0;
    }
    numlegs = z.coursecoords.length - 1;
    var Q = mapviewer.map.tolatlng(0, 0);
    var S = Q.lat;
    var U = Q.lng;
    data = {
      name: M,
      description: W,
      pwdraw: $("#passworddraw").val(),
      pwview: $("#password").val(),
      speed: parseInt($("#rwspeed").val()),
      numlegs: numlegs,
      lat: S,
      lng: U,
      runningwild: X.settings.runningwild,
      runners: O,
      savedata: X,
    };
    data = JSON.stringify(data);
    X.settings.runningwild = 0;
    $.ajax({
      type: "POST",
      url: "loadsavedata.php",
      dataType: "json",
      data: { data: data },
      error: function (Z, aa, Y) {
        z.close_dialog();
        z.open_dialog(
          "Unexpexted error",
          "Could not save data! " + aa + " " + Y,
          1
        );
        return;
      },
      success: function (Z) {
        z.close_dialog();
        if (Z.status == "OK") {
          if (!Z.id) {
            z.open_dialog(
              "Error! Could not save data!",
              "Unknown error - no ID given",
              1
            );
          } else {
            var Y = "http://3drerun.worldofo.com/2d/?analysis=1&anid=" + Z.id;
            if (T == "runningwild") {
              Y = "http://3drerun.worldofo.com/2d/runningwild.php?anid=" + Z.id;
            }
            z.open_dialog(
              "Data saved",
              "The link to the saved analysis state is <a href='" +
                Y +
                "'>" +
                Y +
                "</a>. Copy the link now, as you will not be able to find it anywhere else in this early test implementation.",
              1
            );
          }
        } else {
          z.open_dialog("Error! Could not save data!", Z.status, 1);
        }
      },
    });
  };
  this.savecourseandtags = function (T, M, Z, N) {
    if (T == "loadbrowser") {
      if (!M) {
        var ac = JSON.parse(localStorage.getItem("coursetags_index"));
        var ag = 0;
        if (ac) {
          var Q = '<select id="loadcoursetagsid">';
          Q +=
            '<option value="0">-------------------------------------</option>';
          for (var X = ac.length - 1; X >= 0; X--) {
            thisinfo = ac[X];
            info = thisinfo.info;
            id = thisinfo.id;
            datetime = thisinfo.datetime;
            compname = thisinfo.compname;
            if (!N || compname == N) {
              ag++;
              Q +=
                '<option value="' +
                id +
                '">' +
                datetime +
                ", " +
                compname +
                ", " +
                info +
                "</option>";
            }
          }
          Q += "</select><p>";
          Q +=
            "<button onclick=\"mapviewer.savecourseandtags('loadbrowser',1,null)\">Load course/tags</button>";
          if (!N || ag > 0) {
            if (N) {
              Q =
                "Found " +
                ag +
                " saved entries in the browser for this map. You may load an entry below, or click OK to close without loading.<p>" +
                Q;
            }
            z.open_dialog("Load course/tags from browser", Q, 1);
          } else {
            return "none";
          }
        } else {
          alert(
            "No saved data found in this browser. Are you sure you used the same browser on the same computer when saving data?"
          );
        }
      } else {
        thisid = $("#loadcoursetagsid").val();
        if (thisid == 0) {
          alert("Nothing to load!");
        } else {
          z.tags = JSON.parse(localStorage.getItem(thisid + "_tags"));
          z.coursecoords = JSON.parse(
            localStorage.getItem(thisid + "_coursecoords")
          );
          z.otechinfo = JSON.parse(localStorage.getItem(thisid + "_otechinfo"));
          z.request_redraw();
          z.update_routediv();
          if (typeof courseplanning != "undefined") {
          } else {
            courseplanning = 0;
          }
          if (courseplanning) {
            value = "drawcourse";
            $("#selectmode option[value=" + value + "]").removeAttr("disabled");
            value = "savedata";
            $("#selectmode option[value=" + value + "]").removeAttr("disabled");
            value = "analyzecourse";
            $("#selectmode option[value=" + value + "]").removeAttr("disabled");
          }
        }
      }
    } else {
      if (T == "savebrowser") {
        ac = JSON.parse(localStorage.getItem("coursetags_index"));
        if (!ac) {
          ac = new Array();
        }
        datetime = new Date().toString();
        compname = z.maps[0].name;
        if (!compname) {
          compname = "Noname";
        }
        eventid = datetime + "_" + compname;
        thisinfo = new Object();
        thisinfo.info =
          z.coursecoords.length + " controls. " + z.tags.length + " tags";
        thisinfo.id = eventid;
        thisinfo.datetime = datetime;
        thisinfo.compname = compname;
        localStorage.setItem(eventid + "_tags", JSON.stringify(z.tags));
        localStorage.setItem(
          eventid + "_coursecoords",
          JSON.stringify(z.coursecoords)
        );
        localStorage.setItem(
          eventid + "_otechinfo",
          JSON.stringify(z.otechinfo)
        );
        ac.push(thisinfo);
        localStorage.setItem("coursetags_index", JSON.stringify(ac));
      } else {
        if (T == "savefile") {
          datetime = new Date().toString();
          compname = z.maps[0].name;
          if (!compname) {
            compname = "Noname";
          }
          eventid = compname + "_" + datetime;
          fname = eventid + ".json";
          saveobj = new Object();
          saveobj.tags = z.tags;
          saveobj.coursecoords = z.coursecoords;
          saveobj.otechinfo = z.otechinfo;
          savedata = JSON.stringify(saveobj);
          z.savetxtfile(fname, savedata);
        } else {
          if (T == "saveserverwithmap") {
            datetime = new Date().toString();
            saveobj = new Object();
            saveobj.tags = z.tags;
            saveobj.coursecoords = z.coursecoords;
            saveobj.otechinfo = z.otechinfo;
            saveobj.mapfile = "";
            saveobj.calstr = "";
            savedata = JSON.stringify(saveobj);
            z.savecoursewithmap(savedata);
          } else {
            if (T == "saveservercoursesplits") {
              saveobj = new Object();
              saveobj.tags = z.tags;
              saveobj.coursecoords = z.coursecoords;
              var W = new Array();
              var ab = new Array();
              for (var X = 0; X < z.routes.length; X++) {
                W.push(z.routes[X].splits);
                ab.push(z.routes[X].unit);
              }
              saveobj.splits = W;
              saveobj.units = ab;
              savedata = JSON.stringify(saveobj);
              idstr = getURLParameter("lidstr");
              $.ajax({
                url: "../uploadjson.php",
                type: "POST",
                dataType: "json",
                data: { idstr: idstr, data: savedata },
                success: function (ak) {
                  var aj = ak.status;
                  alert("Thanks - course and splits saved");
                  return;
                },
                error: function (ak, al, aj) {
                  alert(aj);
                },
              });
            } else {
              if (T == "savegpxfile") {
                datetime = new Date().toString();
                compname = z.maps[0].name;
                if (!compname) {
                  compname = "Noname";
                }
                eventid = compname + "_" + datetime;
                fname = eventid + ".gpx";
                var Y =
                  '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\n';
                Y +=
                  '<gpx creator="2DRerun" version="1.0" xmlns="http://www.topografix.com/GPX/1/0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd">\n';
                Y += " <trk>\n";
                Y += "   <trkseg>\n";
                var ai = 0;
                var aa = 0;
                for (var S = 0; S < z.coursecoords.length; S++) {
                  var U = z.coursecoords[S].split(",");
                  var af = U[0];
                  var ae = U[1];
                  var V = mapviewer.map.tolatlng(af, ae);
                  lat = V.lat;
                  lng = V.lng;
                  if (S == 0) {
                    name = "Start";
                  } else {
                    dist = parseInt(calcdistance(lat, lng, ai, aa));
                    name = "Control " + S + ", " + dist + " meter";
                  }
                  ai = lat;
                  aa = lng;
                  Y += '      <trkpt lat="' + lat + '" lon="' + lng + '">\n';
                  Y += "      </trkpt>\n";
                }
                Y += "   </trkseg>\n";
                Y += " </trk>\n";
                Y += "</gpx>\n";
                z.savetxtfile(fname, Y);
              } else {
                if (T == "savexmlfile") {
                  datetime = new Date().toString();
                  compname = z.maps[0].name;
                  if (!compname) {
                    compname = "Noname";
                  }
                  eventid = compname + "_" + datetime;
                  fname = eventid + ".xml";
                  datetime = datetime.replace(" ", "T");
                  datetime = datetime + "+01:00";
                  var R = '<?xml version="1.0" encoding="UTF-8"?>\n';
                  R +=
                    '<CourseData xmlns="http://www.orienteering.org/datastandard/3.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" iofVersion="3.0" createTime="' +
                    datetime +
                    '" creator="2DRerun Courseplanning">\n';
                  R +=
                    "<Event> <Name>2DRerun event</Name> <StartTime> <Date>2020-01-01</Date> <Time>00:00:00+01:00</Time> </StartTime> </Event>\n";
                  R += "<RaceCourseData>\n";
                  var ai = 0;
                  var aa = 0;
                  code = 29;
                  totdist = 0;
                  dists = new Array();
                  for (var S = 0; S < z.coursecoords.length; S++) {
                    code = code + 1;
                    var U = z.coursecoords[S].split(",");
                    var af = U[0];
                    var ae = U[1];
                    var V = mapviewer.map.tolatlng(af, ae);
                    lat = V.lat;
                    lng = V.lng;
                    if (S == 0) {
                      name = "S";
                    } else {
                      dist = parseInt(calcdistance(lat, lng, ai, aa));
                      dists.push(dist);
                      totdist = totdist + dist;
                      name = code;
                      if (S == z.coursecoords.length) {
                        name = "F";
                      }
                    }
                    ai = lat;
                    aa = lng;
                    R += "<Control>\n";
                    R += "<Id>" + name + "</Id>\n";
                    R += '<Position lat="' + lat + '" lng="' + lng + '"/>\n';
                    R +=
                      '<MapPosition unit="px" x="' +
                      af +
                      '" y="' +
                      ae +
                      '"/>\n';
                    R += "</Control>\n";
                  }
                  R += "<Course>\n";
                  R += "<Name>Course</Name>\n";
                  R += "<Length>" + parseInt(totdist) + "</Length>\n";
                  R +=
                    '<CourseControl type="Start"><Control>S</Control><LegLength>0</LegLength></CourseControl>\n';
                  code = 30;
                  for (var S = 1; S < z.coursecoords.length; S++) {
                    code = code + 1;
                    if (S == z.coursecoords.length) {
                      code = "F";
                    }
                    R +=
                      '<CourseControl type="Control"><Control>' +
                      code +
                      "</Control><LegLength>" +
                      parseInt(dists[S - 1]) +
                      "</LegLength><MapText>" +
                      S +
                      "</MapText></CourseControl>\n";
                  }
                  R += "</Course>\n";
                  R += "</RaceCourseData>\n";
                  R += "</CourseData>\n";
                  z.savetxtfile(fname, R);
                } else {
                  if (T == "loadfile") {
                    var ah = Z[0];
                    var ad = ah.name;
                    var O = new FileReader();
                    O.onload = function (ak) {
                      var al = ak.target.result;
                      var aj = jQuery.parseJSON(al);
                      z.tags = aj.tags;
                      z.coursecoords = aj.coursecoords;
                      z.otechinfo = aj.otechinfo;
                      z.request_redraw();
                      z.update_routediv();
                    };
                    O.readAsText(ah, "ISO-8859-1");
                    if (typeof courseplanning != "undefined") {
                    } else {
                      courseplanning = 0;
                    }
                    if (courseplanning) {
                      value = "drawcourse";
                      $("#selectmode option[value=" + value + "]").removeAttr(
                        "disabled"
                      );
                      value = "savedata";
                      $("#selectmode option[value=" + value + "]").removeAttr(
                        "disabled"
                      );
                      value = "analyzecourse";
                      $("#selectmode option[value=" + value + "]").removeAttr(
                        "disabled"
                      );
                    }
                  } else {
                    alert("Not implemented yet");
                  }
                }
              }
            }
          }
        }
      }
    }
  };
  this.updatelocalmaps = function () {
    if (z.settings.localmaps) {
      var N = "-1:------------------------|";
      for (var M = 0; M < z.settings.localmaps.length; M++) {
        N += M + ":" + z.settings.localmaps[M].name + "|";
      }
      var O = "<br><b>Choose local map</b><br>";
      O += z.printselect(
        "Replace current map with map from list",
        "changelocalmap",
        N.substr(0, N.length - 1),
        -1
      );
      $("#localmaps").html(O);
      $("#changelocalmap").bind("change", function (U, V) {
        var T = $("#changelocalmap").val();
        if (T >= 0) {
          var S = mapviewer.settings.localmaps[T];
          var Q = S.name;
          var R = S.size;
          mapviewer.readlocalimage(S, Q, R);
        }
      });
    }
  };
  this.saveloadcalstring = function (R, N) {
    if (R == "savefile") {
      datetime = new Date().toString();
      compname = z.maps[0].name;
      if (!compname) {
        compname = "Noname";
      }
      eventid = compname + "_" + datetime;
      fname = eventid + ".cal";
      savedata = mapviewer.map.calstring_points;
      z.savetxtfile(fname, savedata);
    } else {
      if (R == "loadfile") {
        var Q = N[0];
        var O = Q.name;
        var M = new FileReader();
        M.onload = function (S) {
          var T = S.target.result;
          T = T.replace("\n", "");
          mapviewer.map.initcalibration(T);
          mapviewer.map.calstring = T;
          mapviewer.redraw();
          z.request_redraw();
          z.update_routediv();
        };
        M.readAsText(Q, "ISO-8859-1");
      } else {
        alert("Not implemented yet");
      }
    }
  };
  this.saveCourse = function (W, ab, ah) {
    if (z.coursecoords.length < 1 && !ah) {
      alert("No course defined! Nothing to save!");
      return;
    }
    if (!W) {
      W = $("#savecoursename").val();
      ab = $("#savecoursedesc").val();
    }
    var Q = 0;
    if (W == "XCserverform") {
      ah = 1;
      Q = 1;
      save_place = $("#save_place").val();
      save_coursename = $("#save_coursename").val();
      save_sessionname = $("#save_sessionname").val();
      save_groupname = $("#save_groupname").val();
      save_place = save_place.replace(/['"\n\r]/, "");
      save_coursename = save_coursename.replace(/['"\n\r]/, "");
      save_sessionname = save_sessionname.replace(/['"\n\r]/, "");
      save_groupname = save_groupname.replace(/['"\n\r]/, "");
      if (save_place == "") {
        alert("Error: No place entered!");
        return;
      }
      if (save_coursename == "") {
        alert("Error: No course name entered!");
        return;
      }
      if (save_sessionname == "") {
        alert("Error: No session name entered!");
        return;
      }
      if (save_groupname == "") {
        alert("Error: No group entered!");
        return;
      }
    }
    compname = z.maps[0].name;
    if (!compname) {
      compname = "Noname";
    }
    var Y = new Object();
    Y.segments = z.segments;
    Y.numsegments = z.numsegments;
    Y.coursecoords = z.coursecoords;
    Y.courseinfo = z.courseinfo;
    Y.courseeditor_data = z.courseeditor_data;
    if (z.zerotime) {
      var ad = z.playtime;
      if (ad < 707055816) {
        ad = ad + 1136070000;
      }
      datetime = new Date(ad * 1000).toString();
    } else {
      datetime = "1970-01-01 00:00:00";
    }
    Y.maps = new Array();
    for (var O = 0; O < z.maps.length; O++) {
      var M = jQuery.extend({}, z.maps[O]);
      Y.maps[O] = M;
      Y.maps[O].mapobject = null;
    }
    routenames = "";
    routenamesshort = "";
    routeids = "";
    for (var O = 0; O < z.routes.length; O++) {
      if (z.routes[O].show) {
        routenames += z.routes[O].runnername + ", ";
        routeids += z.routes[O].id + ";";
      }
      routenamesshort += z.routes[O].runnername_short + ", ";
    }
    routenamesshort = routenamesshort.substr(0, routenamesshort.length - 2);
    numlegs = z.coursecoords.length - 1;
    var T = 0,
      ag = 0;
    if (numlegs > 0) {
      var R = z.coursecoords[0].split(",");
      var ac = R[0];
      var aa = R[1];
      var U = mapviewer.map.tolatlng(ac, aa);
      T = U.lat;
      ag = U.lng;
    }
    var S = z.map.id;
    var X = new Array();
    for (var O = 0; O < z.coursecoords.length; O++) {
      var R = z.coursecoords[O].split(",");
      var ac = R[0];
      var aa = R[1];
      var U = mapviewer.map.tolatlng(ac, aa);
      X[O] = U.lat + "," + U.lng;
    }
    Y.coursecoordslatlng = X;
    var af = "";
    if (ah) {
      af = z.routes;
    }
    var V = 0;
    if (!xc) {
      V = 1;
    }
    var Z = "";
    var N = z.map.calstring;
    if (V) {
      Z = z.map.mapobject.src;
    }
    if (Q) {
      var ae = {
        coursename: W,
        compname: compname,
        description: ab,
        numlegs: numlegs,
        lat: T,
        lng: ag,
        mapid: S,
        datetime: datetime,
        runners: routenames,
        routes: routeids,
        fullroutes: af,
        fullmap: Z,
        calstring: N,
        savedata: Y,
        save_place: save_place,
        save_coursename: save_coursename,
        save_sessionname: save_sessionname,
        save_groupname: save_groupname,
      };
    } else {
      var ae = {
        coursename: W,
        compname: compname,
        description: ab,
        numlegs: numlegs,
        lat: T,
        lng: ag,
        mapid: S,
        datetime: datetime,
        runners: routenames,
        routes: routeids,
        fullroutes: af,
        fullmap: Z,
        calstring: N,
        savedata: Y,
      };
    }
    data = JSON.stringify(ae);
    Y = null;
    if (Q) {
      $.ajax({
        type: "POST",
        url: "savexcserver.php",
        dataType: "json",
        data: {
          data: data,
          save_place: save_place,
          save_coursename: save_coursename,
          save_sessionname: save_sessionname,
          save_groupname: save_groupname,
          datetime: datetime,
          runners: routenamesshort,
          lat: T,
          lng: ag,
        },
        error: function (aj, ak, ai) {
          z.close_dialog();
          z.open_dialog(
            "Unexpexted error",
            "Could not save data! " + ak + " " + ai,
            1
          );
          return;
        },
        success: function (ai) {
          z.close_dialog();
          if (ai.status == "ok") {
            thislink = "?loadsession=1&id=" + ai.id;
            details = ai.details;
            if (!details) {
              z.open_dialog(
                "Session saved",
                "The session is saved to the server. You can <a target=_blank href='" +
                  thislink +
                  "'>share the data using this link</a>.",
                1
              );
            } else {
              z.open_dialog(
                "Session saved",
                "The session is saved to the server, but not entered into the database (" +
                  details +
                  "). You can still <a target=_blank href='" +
                  thislink +
                  "'>share the data using this link</a>.",
                1
              );
            }
          } else {
            z.open_dialog("Error! Could not save data!", ai.status, 1);
          }
        },
      });
    } else {
      if (xc || ah) {
        if (af) {
          fname = "routes_and_course_" + new Date().valueOf() + ".json";
        } else {
          fname = "course_" + new Date().valueOf() + ".json";
        }
        if (0) {
          if (typeof use_exeoutput != "undefined") {
            exeoutput.SetGlobalVariable("fname", fname, false);
            exeoutput.SetGlobalVariable("data", data, false);
          } else {
            fname = "map_and_routes_" + new Date().valueOf() + ".json";
          }
          $.ajax({
            type: "POST",
            url: "savefull.php",
            dataType: "text",
            data: { data: data, fname: fname },
          });
        } else {
          z.savetxtfile(fname, data);
        }
      } else {
        $.ajax({
          type: "POST",
          url: "loadsavedata.php",
          dataType: "json",
          data: { data: data, course: 1 },
          error: function (aj, ak, ai) {
            z.close_dialog();
            z.open_dialog(
              "Unexpexted error",
              "Could not save data! " + ak + " " + ai,
              1
            );
            return;
          },
          success: function (ak) {
            z.close_dialog();
            if (ak.status == "OK") {
              if (!ak.id) {
                z.open_dialog(
                  "Error! Could not save data!",
                  "Unknown error - no ID given",
                  1
                );
              } else {
                var ai = ak.added;
                var aj =
                  "http://3drerun.worldofo.com/?courseid=" +
                  ak.id +
                  "&type=info";
                z.open_dialog(
                  "Course saved",
                  "Thank you for adding a course to 2DRerun.  <b>" +
                    ai +
                    " routes</b> were assigned to your course. If you want to add further routes to the course (also routes which are currently assigned to another course), use the link to the saved course below.<p>The link to the saved course is <a target=_blank href='" +
                    aj +
                    "'>" +
                    aj +
                    "</a>.",
                  1
                );
              }
            } else {
              z.open_dialog("Error! Could not save data!", ak.status, 1);
            }
          },
        });
      }
    }
  };
  this.loadCourse = function (M) {
    $.ajax({
      type: "GET",
      url: "loadsavedata.php?loadcourse=1&id=" + M,
      dataType: "json",
      error: function (O, Q, N) {
        alert("Unexpected error: Could not load data! " + Q + " " + N);
        return;
      },
      success: function (N) {
        z.loadCoursedata = N;
        if (N.error) {
          z.open_dialog(
            "Error",
            "Error - could not load any course! Please click OK to proceed without course.",
            0
          );
          return;
        }
        N = N.savedata;
        z.loadCoursefromdata(N);
      },
    });
  };
  this.loadCoursefromlocalfile = function (M) {
    $.ajax({
      type: "GET",
      url: M + "?ver=" + Math.random(1),
      dataType: "json",
      error: function (O, Q, N) {
        alert("Unexpected error: Could not load data! " + Q + " " + N);
        return;
      },
      success: function (N) {
        z.loadCoursedata = N;
        if (N.error) {
          z.open_dialog(
            "Error",
            "Error - could not load any course! Please click OK to proceed without course.",
            0
          );
          return;
        }
        N = N.savedata;
        z.loadCoursefromdata(N);
      },
    });
  };
  this.loadSettingsfromlocalfile = function (M) {
    $.ajax({
      type: "GET",
      url: M + "?ver=" + Math.random(1),
      dataType: "text",
      error: function (O, Q, N) {
        console.log(
          "Unexpected error for " + M + ": Could not load data! " + Q + " " + N
        );
        return;
      },
      success: function (N) {
        z.loadCoursedata = N;
        if (N.error) {
          z.open_dialog(
            "Error",
            "Error - could not load any settings-file (" +
              M +
              ")! Please click OK to proceed without.",
            0
          );
          return;
        }
        z.loadSettingsfromdata(N);
      },
    });
  };
  this.loadRoutesfromlocalfile = function (M) {
    $.ajax({
      type: "GET",
      url: M + "?ver=" + Math.random(1),
      dataType: "json",
      error: function (O, Q, N) {
        alert("Unexpected error: Could not load data! " + Q + " " + N);
        return;
      },
      success: function (N) {
        z.loadCoursedata = N;
        if (N.error) {
          z.open_dialog(
            "Error",
            "Error - could not load any course! Please click OK to proceed without course.",
            0
          );
          return;
        }
        mapviewer.loaddata = N.savedata;
        z.loadRoutesfromdata(N.fullroutes);
        setTimeout("mapviewer.loadCoursefromdata(mapviewer.loaddata);", 2000);
        $("#selectmode").val("graphmode");
        $("#selectmode").change();
      },
    });
  };
  this.loadSkiiotfilefromdata = function (S, O) {
    tmptmp = new Object();
    tmptmp.latarray = new Array();
    tmptmp.lngarray = new Array();
    tmptmp.timearray = new Array();
    data = jQuery.parseJSON(S);
    if (O == "location.json") {
      for (var N = 1; N < data.length; N++) {
        var Q = data[N].time;
        var W = data[N].lat;
        var X = data[N].lon;
        tmptmp.latarray.push(W);
        tmptmp.lngarray.push(X);
        tmptmp.timearray.push(Q);
      }
      var V = "Skiiot";
      var Y = null;
      var R = z.getnextcolor();
      var U = new Route(
        tmptmp.latarray.join(";"),
        tmptmp.lngarray.join(";"),
        tmptmp.timearray.join(";"),
        V,
        Y,
        R,
        1,
        z.routes.length + 1,
        null,
        null,
        null
      );
      z.routes.push(U);
      if (U.zerotime < z.zerotime) {
        z.zerotime = U.zerotime;
      }
      z.playtime = z.zerotime;
      z.reset_replaystarttime();
      z.update_routediv(false);
      if (z.map.width == null) {
        z.load_blank_map();
      }
    } else {
      if (O == "skiiot_snow.json") {
        if (z.routes.length != 1) {
          alert(
            "Import of snow temperature data for now works only when you have exactly one location.json-file loaded"
          );
          return;
        }
        tmptmp = new Object();
        tmptmp.times = new Array();
        tmptmp.ir_temp = new Array();
        var M = -1;
        var Z = new Array();
        for (var N = 1; N < data.length; N++) {
          var Q = data[N].time;
          var T = data[N].ir_temp;
          T = T / 250;
          timeint = parseInt(Q);
          if (timeint != M) {
            if (Z.length > 0) {
              tmptmp.times.push(M);
              tmptmp.ir_temp.push(Z.sum() / Z.length);
            }
            M = timeint;
            Z = new Array();
          }
          Z.push(T);
        }
        var U = z.routes[0];
        U.addfield_interp(
          "pace",
          tmptmp.ir_temp.join(";"),
          tmptmp.times.join(";")
        );
        z.settings.pacecoloring.type = 6;
        z.settings.pacecoloring.minpace = -10;
        z.settings.pacecoloring.maxpace = +2;
        z.settings.pacecoloringslider.minpace = -20;
        z.settings.pacecoloringslider.maxpace = 20;
        z.settings.pacecoloringslider.minsec = 0;
        z.settings.pacecoloring.dt = 10;
        z.settings.colormode = 3;
        mapviewer.updateinfobottomdiv();
        z.Draw_all_full_routes(1);
      }
    }
  };
  this.loadTemperaturefilefromdata = function (ad, al) {
    ad.replace(/\r/, "\n");
    ad.replace(/\n\n/, "\n");
    var O = ad.split("\n");
    var T = new Array();
    var U = new Array();
    var Y = new Array();
    var af = new Array();
    var aj = new Array();
    var N = 0;
    for (var R = 0; R < O.length; R++) {
      var aa = O[R];
      if (aa) {
        var ae = aa.split(/ /);
        var Z = ae[0];
        var V = ae[1] / 1000000;
        var am = ae[2] / 1000000;
        var W = ae[3];
        var ak = ae[4];
        var Q = ae[5];
        var ab = ae[6];
        var ai = 0;
        if (V >= 99.99 && V <= 100) {
          ai = 1;
          console.log("Ignoring!");
        }
        var ae = Z.split(":");
        var S = parseInt(ae[0]) * 3600 + parseInt(ae[1]) * 60 + parseInt(ae[2]);
        var ag = 1136070000;
        var X = S + ag;
        if (X != N && !ai) {
          aj.push(X);
          T.push(V);
          U.push(am);
          af.push(ab);
          Y.push(ak);
        }
        N = X;
      }
    }
    var ac = 0;
    var ah = z.getnextcolor();
    var M = new Route(
      T.join(";"),
      U.join(";"),
      aj.join(";"),
      al,
      ac,
      ah,
      1,
      z.routes.length + 1,
      null,
      null,
      null
    );
    z.routes.push(M);
    M.pulse = Y;
    M.elevation = af;
    if (z.map.width == null) {
      z.load_blank_map();
    } else {
      if (z.map.calstring == "0|0|0|0|1|1|1600|1600|0|1|0|1600") {
        newroutemap = 1;
        $("#selectmode").val("calibrate");
        $("#selectmode").change();
        calstring = mapviewer.find_initial_calstring();
        mapviewer.map.initcalibration(calstring);
        mapviewer.map.calstring = calstring;
        mapviewer.redraw();
      }
    }
  };
  this.loadSettingsfromdata = function (T) {
    z.settings.settings_from_file = new Object();
    z.settings.settings_from_file.rawtxt = T;
    var S = z.settings.settings_from_file;
    T.replace(/\r/, "\n");
    T.replace(/\n\n/, "\n");
    var U = T.split("\n");
    for (var M = 0; M < U.length; M++) {
      var V = U[M];
      if (V) {
        if (V.substr(0, 1) == "#") {
        } else {
          var R = V.split("|");
          var O = R[0];
          var Q = R[1];
          var N = R[2];
          if (O && Q) {
            if (!S.hasOwnProperty(O)) {
              S[O] = new Array();
            }
            S[O][Q] = N;
          }
        }
      }
    }
    z.apply_settingsfromfile("global");
    z.apply_settingsfromfile("maxpulse");
    z.apply_settingsfromfile("rename");
  };
  this.apply_settingsfromfile = function (X, U) {
    var Q = {
      hillcolors_profile: "hillcolors",
      hillcolor_background_fullcolumn: "hillcolorsongraph",
      hillcolor_background_boxes: "hillcolorsongraph2",
      routecolors: "linecolors",
    };
    if (z.settings.settings_from_file) {
      var T = z.settings.settings_from_file[X];
      for (var R in T) {
        if (T.hasOwnProperty(R)) {
          var O = T[R];
          if (X == "maxpulse" || X == "rename") {
            var Y = R;
            var M;
            if (U) {
              M = new Array();
              M.push(U);
            } else {
              M = z.routes;
            }
            for (var N = 0; N < M.length; N++) {
              var V = M[N];
              var W = V.runnername;
              W = W.replace(" - 1", "");
              if (W.toLowerCase() == Y.toLowerCase()) {
                if (X == "maxpulse") {
                  V.maxpulse = O;
                  console.log(
                    "Apply settings: Set maxpulse for route " +
                      N +
                      " (" +
                      V.runnername +
                      ") to " +
                      O
                  );
                } else {
                  if (X == "rename") {
                    V.runnername = O;
                    if (O) {
                      V.runnername_long = O;
                      V.runnername_short = O.substr(0, 8);
                      V.runnername_middle = O.substr(0, 19);
                      console.log(
                        "Apply settings: Set name for route " +
                          N +
                          " (" +
                          V.runnername +
                          ") to " +
                          O
                      );
                    }
                  }
                }
              }
            }
          }
          if (X == "global") {
            var Z = 0;
            if (R == "timeaveraging") {
              if (O) {
                z.datafieldtypes_basic_avpoints[1] = parseInt(O);
              }
              $("#graph_time_averaging").val(
                z.datafieldtypes_basic_avpoints[1]
              );
              Z = 1;
            } else {
              if (
                R == "hillcolors_profile" ||
                R == "hillcolor_background_fullcolumn" ||
                R == "hillcolor_background_boxes" ||
                R == "routecolors"
              ) {
                var S = O.split(";");
                for (var aa = 0; aa < S.length; aa++) {
                  tovar = Q[R];
                  z[tovar][aa] = S[aa];
                }
                Z = 1;
              } else {
                if (z.settings.hasOwnProperty(R)) {
                  z.settings[R] = parseInt(O);
                  Z = 1;
                }
              }
            }
            if (Z) {
              console.log("Apply settings: Set " + R + " to " + O);
            } else {
              console.log(
                "Warning: Could not apply settings " + R + " to " + O
              );
            }
          }
        }
      }
    }
  };
  this.loadRoutesfromdata = function (O) {
    if (O.length > 0) {
      for (var Q = 0; Q < O.length; Q++) {
        var N = O[Q];
        tmptmp = N;
        M = new Route(
          N.latarray.join(";"),
          N.lngarray.join(";"),
          N.timearray.join(";"),
          N.runnername,
          N.unit,
          N.color,
          1,
          z.routes.length + 1,
          null,
          null,
          null
        );
        M.mapreading = N.mapreading;
        M.md5 = N.md5;
        M.pace = N.pace;
        M.pulse = N.pulse;
        M.dspeed = N.dspeed;
        if (N.maxpulse) {
          M.maxpulse = N.maxpulse;
        }
        if (M.pulse && !M.maxpulse) {
          M.maxpulse = M.pulse.max();
        }
        M.elevation = N.elevation;
        M.splits = N.splits;
        M.lapdata = N.lapdata;
        M.datafields = N.datafields;
        if (M.cutstart) {
          M.removedatapoints(0, M.cutstart);
          M.zerotime = M.zerotime + M.cutstart;
        }
        if (M.cutend) {
          M.removedatapoints(M.latarray.length - M.cutend, M.cutend);
        }
        z.routes.push(M);
        rnr = z.routes.length - 1;
        if (M.zerotime < z.zerotime) {
          z.zerotime = M.zerotime;
        }
      }
      z.settings.autosplits_calculated = 1;
      z.playtime = z.zerotime;
      z.reset_replaystarttime();
      z.update_routediv(false);
      var M = z.routes[0];
      P1 = z.map.toxy(M.latarray[0], M.lngarray[0]);
      z.map_start_x = P1.x;
      z.map_start_y = P1.y;
      z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
      z.AllRoutestoStart();
    }
  };
  this.loadMapfromdata = function (N, M) {
    z.load_blank_map();
    z.map.mapobject.src = N;
    z.map.width = z.map.mapobject.width;
    z.map.height = z.map.mapobject.height;
    z.map.name = "loadfromfile";
    z.map.id = "localimage";
    z.map.initcalibration(M);
    z.map.calstring = M;
    z.redraw();
    if (!xc) {
      setTimeout(
        "console.log('Late fix calstring for drag-drop');mapviewer.map.initcalibration('" +
          M +
          "');mapviewer.redraw();$('#selectmode').val('analysis');$('#selectmode').change();mapviewer.canvas.cx=mapviewer.map.width/2;mapviewer.canvas.cy=mapviewer.map.height/2;mapviewer.canvas.zoomfactor=0.5;mapviewer.redraw();",
        10000
      );
      console.log(
        "mapviewer.map.initcalibration('" +
          M +
          "');mapviewer.redraw();$('#selectmode').val('analysis');$('#selectmode').change();mapviewer.canvas.cx=mapviewer.map.width/2;mapviewer.canvas.cy=mapviewer.map.height/2;mapviewer.canvas.zoomfactor=0.5;mapviewer.redraw();"
      );
    }
  };
  this.loadCoursefromdata = function (W) {
    if (z.map.width == null) {
      z.load_blank_map();
    }
    tmptmp2 = W;
    if (xc) {
      mapviewer.map.c1 = tmptmp2.maps[0].c1;
      mapviewer.map.c2 = tmptmp2.maps[0].c2;
      mapviewer.map.c3 = tmptmp2.maps[0].c3;
      mapviewer.map.c4 = tmptmp2.maps[0].c4;
      mapviewer.map.c5 = tmptmp2.maps[0].c5;
      mapviewer.map.c6 = tmptmp2.maps[0].c6;
      mapviewer.map.c1inv = tmptmp2.maps[0].c1inv;
      mapviewer.map.c2inv = tmptmp2.maps[0].c2inv;
      mapviewer.map.c3inv = tmptmp2.maps[0].c3inv;
      mapviewer.map.c4inv = tmptmp2.maps[0].c4inv;
      mapviewer.map.c5inv = tmptmp2.maps[0].c5inv;
      mapviewer.map.c6inv = tmptmp2.maps[0].c6inv;
    }
    z.segments = W.segments;
    z.numsegments = W.numsegments;
    if (z.segments) {
    }
    z.coursecoords = W.coursecoords;
    z.courseeditor_data = W.courseeditor_data;
    var aa = W.coursecoordslatlng;
    for (var N = 0; N < z.coursecoords.length; N++) {
      var ab = z.coursecoords[N].split(",");
      var Q = aa[N].split(",");
      var X = mapviewer.map.toxy(Q[0], Q[1]);
      ab[0] = X.x;
      ab[1] = X.y;
      z.coursecoords[N] = ab.join(",");
    }
    var Z = z.courseinfo;
    z.courseinfo = W.courseinfo;
    if (z.courseinfo) {
      for (var M in Z) {
        if (!z.courseinfo.hasOwnProperty(M)) {
          z.courseinfo[M] = Z[M];
        }
      }
    }
    if (xc) {
      z.courseinfo.routewidthfactor = 0.3;
      z.courseinfo.neednewsnap = 1;
      z.settings.alwaysshowcourse = 1;
      z.settings.showcourse = 2;
      var O = z.courseinfo.numlaps;
      if (!z.courseeditor_data) {
        O = 1;
        var V = new Object();
        V.coursecoords = z.coursecoords;
        var T = jQuery.extend(true, {}, V);
        z.courseeditor_data = new Object();
        z.courseeditor_data.courseinfo = jQuery.extend(true, {}, z.courseinfo);
        z.courseeditor_data.coursecoords = T.coursecoords;
      }
      var U = z.courseeditor_data.courseinfo.hillsegments.length - 1;
      var S = z.courseeditor_data.coursecoords.length - 1;
      z.courseeditor_data.courseinfo.hillsegments[U].endind = S;
      var R = z.coursecoords[S].split(",");
      var Y =
        z.coursecoords[
          z.courseeditor_data.courseinfo.hillsegments[U].startind
        ].split(",");
      z.courseeditor_data.courseinfo.hillsegments[U].thelength = R[3] - Y[3];
      var V = new Object();
      V.coursecoords = z.courseeditor_data.coursecoords;
      var T = jQuery.extend(true, {}, V);
      z.coursecoords = T.coursecoords;
      z.courseinfo = jQuery.extend(true, {}, z.courseeditor_data.courseinfo);
      z.courseinfo.numlaps = O;
      z.hillsegments_combine_segments(z.courseinfo.numlaps);
      z.snaproutestocourse();
    } else {
      z.settings.showcourse = 1;
    }
    z.request_redraw();
  };
  this.loadotherrw = function () {
    z.loadcomments();
    $("#" + z.routemenudiv).html(
      '<center><p>Loading routes<p><img src="loading.gif"><p>Be patient<center>'
    );
    $("#" + z.routedescdiv).html("<br>");
    z.colorcounter = 0;
    if (z.settings.orunningwild.equal_percent >= 0) {
      var M =
        '<div  id="rwrouteideal"  onclick="mapviewer.toggledrawrw(\'ideal\')" class="colorbox" style="background:#' +
        z.getnextcolor() +
        '"></div>';
      $("#" + z.routedescdiv).append(
        '<div class="drawrw">' +
          M +
          "<b>" +
          z.settings.orunningwild.equal_cmpname +
          ": </b> (ideal)</div>"
      );
    }
    var N = z.settings.orunningwild.anid;
    $.ajax({
      type: "POST",
      url: "loadsavedata.php",
      dataType: "json",
      data: { rwload: 1, anid: N },
      error: function (Q, R, O) {
        $("#" + z.routemenudiv).html(
          "Could not find any other routes to compare with. Maybe you are the first..?"
        );
        return;
      },
      success: function (O) {
        if (O.status == "OK") {
          z.settings.orunningwild.rwroutedata = O.routes.split(/:/);
          z.settings.orunningwild.rwroutes = new Array();
          z.settings.orunningwild.rwprocessed = 0;
          setTimeout("mapviewer.load_nextrwroute()", 0);
        } else {
          $("#" + z.routemenudiv).html(
            "Could not find any other routes to compare with. Maybe you are the first?"
          );
        }
      },
    });
  };
  this.load_nextrwroute = function () {
    if (
      z.settings.orunningwild.rwroutedata.length >
      z.settings.orunningwild.rwprocessed + 1
    ) {
      var W = z.settings.orunningwild.rwprocessed;
      var V = z.settings.orunningwild.rwroutedata[W];
      var S = V.split(";");
      var M = S[0];
      var X = S[1];
      var Q = S[2];
      var U = S[3];
      var Z = S[4];
      var Y = S[5];
      var R = S[6];
      var T = new Rwroute(W, M, X, Q, U, Z, Y, R);
      z.settings.orunningwild.rwroutes[W] = T;
      z.settings.orunningwild.rwprocessed++;
      setTimeout("mapviewer.load_nextrwroute()", 0);
    } else {
      if (z.coursecoords.length > 1) {
        var O = "";
        for (var N = 1; N < z.coursecoords.length; N++) {
          kkstr =
            "<button id='rwleg-" +
            N +
            "' onclick='mapviewer.processrwleg(" +
            N +
            ");return(false);'>" +
            N +
            "</button> ";
          O = O + kkstr;
        }
        if (z.coursecoords.length > 1) {
          O =
            O +
            "<button id='rwleg-0' onclick='mapviewer.processrwleg(\"complete\");return(false);'>C</button>";
        }
        $("#" + z.routemenudiv).html(
          '<div id="rwroutesdiv" style="padding-bottom:8px;border-bottom:1px solid black;"><b>Analyze routes by leg</b><br>' +
            O +
            '</div><div id="commentsleg" style="margin-top:4px;padding-bottom:4px;border-bottom:1px solid black;"></div><div id="analyzeleg"></div>'
        );
      } else {
        $("#" + z.routemenudiv).html("");
      }
      $("#" + z.routedescdiv).append(
        '<p><a href="javascript:void(0);" onclick="mapviewer.showrw_selected(\'all\');return(false);">Show all</a> / <a href="javascript:void(0);" onclick="mapviewer.showrw_selected(\'none\');return(false);">none</a>'
      );
      $("#" + z.routedescdiv).append(
        '<p><hr><p><button onclick="if (mapviewer.settings.showtagmode==0) {mapviewer.settings.showtagmode=1;mapviewer.settings.tagmode=3;} else {mapviewer.settings.showtagmode=0;mapviewer.settings.tagmode=0;};return(false);">Toggle pre-drawn routes</button>'
      );
    }
  };
  this.showrw_selected = function (M) {
    if (M == "all") {
      val = 1;
      z.settings.orunningwild.ideal_show = 1;
    } else {
      val = 0;
      z.settings.orunningwild.ideal_show = 0;
    }
    for (var N = 0; N < z.settings.orunningwild.rwroutes.length; N++) {
      thisroute = z.settings.orunningwild.rwroutes[N];
      thisroute.show = val;
      if (val == 1) {
        thiscol = thisroute.color;
      } else {
        thiscol = "ffffff";
      }
      $("#rwroute" + N).css("background", "#" + thiscol);
    }
  };
  this.showrwvariants_selected = function (M) {
    if (M == "all") {
      val = 2;
    } else {
      if (M == "oneeach") {
        val = 1;
      } else {
        val = 0;
      }
    }
    for (var N = 0; N < z.settings.orunningwild.variants.length; N++) {
      thisvar = z.settings.orunningwild.variants[N];
      if (M == "popular") {
        if (
          thisvar.members.length >=
          z.settings.orunningwild.rwroutes.length / 6
        ) {
          thisvar.show = 2;
        } else {
          thisvar.show = 0;
        }
      } else {
        thisvar.show = val;
      }
      if (thisvar.show == 1) {
        thiscol = z.linecolors[N];
        thisopacity = 0.5;
      } else {
        if (thisvar.show == 2) {
          thiscol = z.linecolors[N];
          thisopacity = 1;
        } else {
          thiscol = "ffffff";
          thisopacity = 1;
        }
      }
      $("#rwvariant" + N).css("background", "#" + thiscol);
      $("#rwvariant" + N).css("opacity", thisopacity);
      $("#rwvariant" + N).css(
        "filter",
        "alpha(opacity=" + thisopacity * 100 + ")"
      );
    }
  };
  this.processrwleg = function (Q) {
    z.settings.mode = z.settings.modes.AnalysisMode;
    if (Q > 0 && Q <= z.coursecoords.length) {
      z.showtags_control(Q);
      z.settings.centerlegnum = Q;
      z.settings.analyzecourse = 1;
    } else {
      z.settings.analyzecourse = 0;
    }
    for (var N = 0; N < z.coursecoords.length; N++) {
      $("#rwleg-" + N).prop("disabled", false);
    }
    if (Q > 0) {
      $("#rwleg-" + Q).prop("disabled", true);
    } else {
      if (Q == "C") {
        $("#rwleg-0").prop("disabled", true);
      }
    }
    if (z.settings.orunningwild.diffroutes) {
      z.settings.orunningwild.diffroutes = null;
    }
    $("#" + z.routedescdiv).show();
    z.settings.orunningwild.variants = null;
    if (Q == "complete") {
      for (var O = 0; O < z.settings.orunningwild.rwroutes.length; O++) {
        thisroute = z.settings.orunningwild.rwroutes[O];
        thisroute.drawpoints = thisroute.points;
        thisroute.writelength(0);
      }
      $("#analyzeleg").html("<b>Showing complete course</b>");
      $("#commentsleg").html("");
    } else {
      if (Q < z.coursecoords.length) {
        for (var O = 0; O < z.settings.orunningwild.rwroutes.length; O++) {
          thisroute = z.settings.orunningwild.rwroutes[O];
          thisroute.writelength(Q);
          if (thisroute.splits.length > 0) {
            points = thisroute.points.split(" ");
            if (Q == 1) {
              from = 0;
            } else {
              from = thisroute.splits[Q - 1] - 1;
            }
            to = thisroute.splits[Q];
            if (!from || from < 0) {
              from = 0;
            }
            if (!to || to >= points.length) {
              to = points.length - 1;
            }
            drawpoints = "";
            for (var N = from; N < to; N++) {
              drawpoints = drawpoints + points[N] + " ";
            }
            thisroute.drawpoints = drawpoints;
          }
        }
        z.centerleg(Q - 1, 0.2);
      }
      $("#analyzeleg").html(
        '<button onclick="mapviewer.analyze_rw(' +
          Q +
          ')">Analyze variants leg ' +
          Q +
          "</button>"
      );
      numcomments = 0;
      comments = "";
      yourname = "";
      if (!z.settings.orunningwild.playername) {
        yourname = '<br>Your name: <input id="commentform_name" size=8>';
      }
      var M =
        '<div id="comments_holder" style="display:none;"><div id="comments">' +
        comments +
        '</div><div id="commentform_holder"><b>Add comment</b><br><textarea cols=19 rows=5 id="commentform"></textarea>' +
        yourname +
        '<button onclick="mapviewer.postcomment();">Add comment</button></div><input type=hidden id="commentform_leg" value="' +
        Q +
        '"></div>';
      $("#commentsleg").html(
        "<a href=\"javascript:void(0);\" onclick=\"if ($('#comments_holder').css('display') == 'block') {$('#comments_holder').hide();} else {$('#comments_holder').show();}\"><div id=\"comments_linktxt\">&raquo; Comments for leg " +
          Q +
          "</div></a>" +
          M
      );
    }
    z.populatecomments();
  };
  this.postcomment = function () {
    var M = new Object();
    var N = z.settings.orunningwild.anid;
    M.comment = $("#commentform").val();
    if (N && M.comment) {
      if (!z.settings.orunningwild.playername) {
        z.settings.orunningwild.playername = $("#commentform_name").val();
      }
      M.name = z.settings.orunningwild.playername;
      M.leg = $("#commentform_leg").val();
      if (!M.name) {
        M.name = "";
      }
      data = JSON.stringify(M);
      $.ajax({
        type: "POST",
        url: "postcomment.php",
        dataType: "json",
        data: { data: data, anid: N },
        error: function (Q, R, O) {
          z.close_dialog();
          z.open_dialog(
            "Unexpexted error",
            "Could not add comment! " + R + " " + O,
            1
          );
          return;
        },
        success: function (O) {
          z.close_dialog();
          if (O.status == "OK") {
            $("#commentform_holder").hide("");
            var Q = new Object();
            Q.leg = M.leg;
            Q.comment = M.comment;
            Q.name = M.name;
            Q.date = "Now";
            if (!Q.name) {
              Q.name = "You";
            }
            z.comments.push(Q);
            z.populatecomments();
          } else {
            z.open_dialog("Error! Could not add comment!", O.status, 1);
          }
        },
      });
    } else {
      alert("Could not add comments - something wrong!!");
    }
  };
  this.loadcomments = function () {
    z.comments = new Array();
    var M = z.settings.orunningwild.anid;
    $.ajax({
      type: "POST",
      url: "getcomments.php",
      dataType: "json",
      data: { anid: M },
      error: function (O, Q, N) {
        z.comments_loaded = 1;
        return;
      },
      success: function (R) {
        if (R.comments) {
          var Q = R.comments.split("|");
          for (var O = 0; O < Q.length; O++) {
            var N = Q[O].split(";");
            var S = new Object();
            S.leg = N[0];
            S.comment = N[4];
            S.name = N[1];
            S.date = N[3];
            z.comments.push(S);
          }
        }
        z.comments_loaded = 1;
      },
    });
  };
  this.populatecomments = function () {
    if (z.comments_loaded) {
      var Q = $("#commentform_leg").val();
      var M = 0;
      var R = "";
      for (var O = 0; O < z.comments.length; O++) {
        var N = z.comments[O];
        if (N.leg == Q) {
          M++;
          R =
            R +
            '<div class="comment"><div class="commentbody">' +
            N.comment +
            '</div><div class="commentname" title="Added on ' +
            N.date +
            '">Posted by ' +
            N.name +
            " @ " +
            N.date +
            "</div></div>";
        }
      }
      if (!M) {
        $("#comments_linktxt").html("&raquo; Add comments for leg " + Q);
      } else {
        $("#comments_linktxt").html("&raquo; " + M + " comments for leg " + Q);
      }
      $("#comments").html(R);
    } else {
      str =
        'Could not load comments. <a href="javascript:void(0);" onclick="mapviewer.populatecomments();">Click here to retry</a>';
    }
  };
  this.analyze_rw = function (W, Z) {
    if (Z == 2) {
      z.settings.orunningwild.sameroutechoice_distance = parseInt(
        $("#vardist").val()
      );
      z.settings.orunningwild.sameroutechoice_percent = parseInt(
        $("#varpercent").val()
      );
      Z = 0;
    }
    if (!Z) {
      $("#analyzeleg").html(
        '<center>Analyzing variants<p><img src="loading.gif"><p>Be patient</center>'
      );
      $("#" + z.routedescdiv).hide();
      setTimeout("mapviewer.analyze_rw(" + W + ",1);", 200);
      return;
    }
    var aa = new Date();
    var ae = new Array();
    var S = 0;
    var N = z.settings.orunningwild.rwroutes.length - 1;
    z.settings.orunningwild.rwroutes[N].variant = S;
    varobj = new Object();
    varobj.members = [N];
    varobj.show = 2;
    varobj.names = z.settings.orunningwild.rwroutes[N].name;
    varobj.lengths = z.settings.orunningwild.rwroutes[N].lengths[W];
    ae.push(varobj);
    var X = 0;
    var Y = "";
    for (var U = z.settings.orunningwild.rwroutes.length - 2; U >= 0; U--) {
      var O = z.settings.orunningwild.rwroutes[U];
      O.variant = NaN;
      for (var ag = 0; ag < ae.length; ag++) {
        var T = z.settings.orunningwild.rwroutes[ae[ag].members[0]];
        isvariant = z.check_if_same_routechoice_xy(O.drawpoints, T.drawpoints);
        if (isvariant) {
          O.variant = T.variant;
          ae[ag].names = ae[ag].names + ", " + O.name;
          ae[ag].lengths = ae[ag].lengths + " " + O.lengths[W];
          ae[ag].members.push(U);
          ag = ae.length + 1;
        }
      }
      if (!isFinite(O.variant)) {
        S++;
        O.variant = S;
        varobj = new Object();
        varobj.members = [U];
        varobj.show = 2;
        varobj.names = O.name;
        varobj.lengths = O.lengths[W];
        ae.push(varobj);
      }
      X++;
      var R = (new Date() - aa) / 1000;
      if (R > 10) {
        Y =
          "<p><font color=#f00 size=1>Note! Only included the first " +
          X +
          " drawn routes in the analysis due to long analysis time!</font>";
        U = 0;
      }
    }
    var ac = "";
    for (var ag = 0; ag < ae.length; ag++) {
      var T = z.settings.orunningwild.rwroutes[ae[ag].members[0]];
      lengthinfo = "";
      if (ae[ag].lengths) {
        all_lengths = ae[ag].lengths.split(" ");
        for (var af = 0; af < all_lengths.length; af++) {
          all_lengths[af] = parseFloat(all_lengths[af]);
        }
        var ab = all_lengths.min();
        var V = all_lengths.max();
        var ad = T.lengths[W];
        if (ab != V) {
          ad = ab + "-" + V;
        }
        if (ad) {
          lengthinfo = " (" + ad + " m)";
        }
      } else {
        lengthinfo = "";
      }
      var M = z.linecolors[ag];
      var Q =
        '<div id="rwvariant' +
        ag +
        '" onclick="mapviewer.toggledrawrwvariant(' +
        ag +
        ')" class="colorbox" style="background:#' +
        M +
        '"></div>';
      ac =
        ac +
        Q +
        "<b>Variant " +
        String.fromCharCode(65 + ag) +
        lengthinfo +
        "</b><br><font size=1>" +
        ae[ag].names +
        "</font><br>";
    }
    ac =
      ac +
      '<font size=1><a href="javascript:void(0);" onclick="mapviewer.showrwvariants_selected(\'all\');return(false);">Show all</a> / <a href="javascript:void(0);" onclick="mapviewer.showrwvariants_selected(\'popular\');return(false);">popular</a> / <a href="javascript:void(0);" onclick="mapviewer.showrwvariants_selected(\'oneeach\');return(false);">one each</a> /  <a href="javascript:void(0);" onclick="mapviewer.showrwvariants_selected(\'none\');return(false);">none</a></font>';
    ac =
      ac +
      '<div style="height:5px;border-bottom:1px solid black;"></div><font size=1>A variant is defined by at least</font><select id="varpercent"><option value="' +
      z.settings.orunningwild.sameroutechoice_percent +
      '">' +
      z.settings.orunningwild.sameroutechoice_percent +
      ' % of route closer than</option><option value="20">20 % of route closer than</option><option value="30">30 % of route closer than</option><option value="40">40 % of route closer than</option><option value="50">50 % of route closer than</option><option value="60">60 % of route closer than</option><option value="70">70 % of route closer than</option><option value="80">80 % of route closer than</option><option value="90">90 % of route closer than</option></select><select id="vardist"><option value="' +
      z.settings.orunningwild.sameroutechoice_distance +
      '">' +
      z.settings.orunningwild.sameroutechoice_distance +
      ' pixels</option><option value="5">5 pixels</option><option value="10">10 pixels</option><option value="20">20 pixels</option><option value="30">30 pixels</option><option value="40">40 pixels</option><option value="50">50 pixels</option><option value="60">60 pixels</option><option value="70">70 pixels</option><option value="100">100 pixels</option><option value="150">150 pixels</option><option value="200">200 pixels</option></select><button onclick="mapviewer.analyze_rw(' +
      W +
      ',2);">Re-analyze variants</button>';
    if (Y) {
      ac = ac + Y;
    }
    $("#analyzeleg").html(ac);
    z.settings.orunningwild.variants = ae;
  };
  this.toggledrawrwvariant = function (M) {
    var N = z.settings.orunningwild.variants[M];
    if (N.show == 2) {
      N.show = 1;
      thiscol = z.linecolors[M];
      thisopacity = 0.5;
    } else {
      if (N.show == 1) {
        N.show = 0;
        thiscol = "ffffff";
        thisopacity = 1;
      } else {
        if (N.show == 0) {
          N.show = 2;
          thiscol = z.linecolors[M];
          thisopacity = 1;
        }
      }
    }
    $("#rwvariant" + M).css("background", "#" + thiscol);
    $("#rwvariant" + M).css("opacity", thisopacity);
    $("#rwvariant" + M).css(
      "filter",
      "alpha(opacity=" + thisopacity * 100 + ")"
    );
  };
  this.interproute_rw = function (Y, O, N) {
    if (!O) {
      O = 10;
    }
    if (!N) {
      N = 100;
    }
    points = Y.split(" ");
    ipoints = new Array();
    var S = null;
    var Q = null;
    for (count = 0; count < points.length - 1; count++) {
      var V = points[count].split(",");
      var U = parseFloat(V[0]);
      var T = parseFloat(V[1]);
      if (count > 0) {
        var ab = U - S;
        var Z = T - Q;
        var aa = Math.sqrt((U - S) * (U - S) + (T - Q) * (T - Q));
        if (aa == 0) {
          aa = 1;
        }
        var R = Math.ceil(aa / O);
        if (R > N) {
          R = N;
        }
        for (var M = 1; M < R; M++) {
          var X = S + (ab / R) * M;
          var W = Q + (Z / R) * M;
          ipoints.push(parseInt(X) + "," + parseInt(W));
        }
      }
      S = U;
      Q = T;
      ipoints.push(U + "," + T);
    }
    ipointsstr = ipoints.join(" ") + " ";
    return ipointsstr;
  };
  this.check_if_same_routechoice_xy = function (U, T) {
    if (!z.settings.orunningwild.sameroutechoice_percent) {
      z.settings.orunningwild.sameroutechoice_distance = 20;
      z.settings.orunningwild.sameroutechoice_percent = 70;
    }
    sameroutechoice_distance = z.settings.orunningwild.sameroutechoice_distance;
    sameroutechoice_percent = z.settings.orunningwild.sameroutechoice_percent;
    var R = 0;
    var M = 0;
    var Q = 0;
    d1str = z.interproute_rw(U);
    d2str = z.interproute_rw(T);
    d1 = d1str.split(" ");
    d2 = d2str.split(" ");
    for (var O = 0; O < d1.length; O++) {
      xy1 = d1[O].split(",");
      x1 = xy1[0];
      y1 = xy1[1];
      var S = 0;
      for (var N = 0; N < d2.length; N++) {
        xy2 = d2[N].split(",");
        x2 = xy2[0];
        y2 = xy2[1];
        dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        if (dist < sameroutechoice_distance * sameroutechoice_distance) {
          S = 1;
          N = d2.length;
        }
      }
      if (S) {
        M++;
      } else {
        Q++;
      }
    }
    if ((Q / (M + Q)) * 100 > 100 - sameroutechoice_percent) {
      return 0;
    } else {
      return 1;
    }
  };
  this.check_which_variant = function (O) {
    for (rnr = 0; rnr < z.routes.length; rnr++) {
      var W = null;
      var S = z.routes[rnr];
      var R = S.splits[O];
      var U = S.splits[O - 1];
      if (R && U) {
        var X = R.index;
        var N = U.index;
        var V = X - U.index;
        routepointsxy = [];
        for (var M = N; M < X; M++) {
          thislat = S.latarray[M];
          thislng = S.lngarray[M];
          var Q = z.map.toxy(thislat, thislng);
          routepointsxy.push(Q.x + "," + Q.y);
        }
        thisvarnr = -1;
        foundvarnr = -1;
        foundvarind = -1;
        for (var M = 0; M < z.tags.length; M++) {
          var T = z.tags[M];
          if (T.type == "route" && T.show) {
            thisvarnr++;
            W = z.tags[M].pointsxy;
            if (
              z.check_if_same_routechoice_xy(
                routepointsxy.join(" "),
                W.join(" ")
              )
            ) {
              foundvarnr = thisvarnr;
              foundvarind = M;
              M = z.tags.length + 1;
            }
          }
        }
        if (foundvarnr >= 0) {
          thistag = z.tags[foundvarind];
          thisname = thistag.name;
          S.variants[O] = foundvarind;
        } else {
        }
      }
    }
  };
  this.check_if_routechoice_is_variant = function (N, U) {
    sameroutechoice_distance = z.settings.sameroutechoice_distance;
    sameroutechoice_percent = z.settings.sameroutechoice_percent;
    var S = 0;
    var M = 0;
    var R = 0;
    d1str = z.interproute_rw(drawpoints1);
    d2str = z.interproute_rw(drawpoints2);
    d1 = d1str.split(" ");
    d2 = d2str.split(" ");
    for (var Q = 0; Q < d1.length; Q++) {
      xy1 = d1[Q].split(",");
      x1 = xy1[0];
      y1 = xy1[1];
      var T = 0;
      for (var O = 0; O < d2.length; O++) {
        xy2 = d2[O].split(",");
        x2 = xy2[0];
        y2 = xy2[1];
        dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        if (dist < sameroutechoice_distance * sameroutechoice_distance) {
          T = 1;
          O = d2.length;
        }
      }
      if (T) {
        M++;
      } else {
        R++;
      }
    }
    if ((R / (M + R)) * 100 > 100 - sameroutechoice_percent) {
      return 0;
    } else {
      return 1;
    }
  };
  this.toggledrawrw = function (M) {
    if (M == "ideal") {
      if (z.settings.orunningwild.ideal_show) {
        z.settings.orunningwild.ideal_show = 0;
        thiscol = "ffffff";
      } else {
        z.settings.orunningwild.ideal_show = 1;
        thiscol = z.settings.orunningwild.ideal_color;
      }
    } else {
      if (z.settings.orunningwild.diffroutes) {
        z.settings.orunningwild.diffroutes = null;
      }
      var N = z.settings.orunningwild.rwroutes[M];
      if (N.show) {
        N.show = 0;
        thiscol = "ffffff";
      } else {
        N.show = 1;
        thiscol = N.color;
      }
    }
    $("#rwroute" + M).css("background", "#" + thiscol);
  };
  this.startsaverw = function () {
    if (!z.checklogin()) {
      z.open_dialog(
        "You must log in",
        'You need to log in first! Please log in in a different window using <a target=_blank href="http://3drerun.worldofo.com/login.php">this link</a>, then close this message window, and reopen this message window!</a>).'
      );
    } else {
      if (z.map.id == null || z.map.id == "localimage") {
        z.open_dialog(
          "Map not in database",
          "This map is not yet in the database, and must therefore be saved in the database. Please wait while the map is saved in the database .... "
        );
        id = z.savemapdb();
        if (!id) {
          z.open_dialog(
            "Could not upload map",
            "Sorry! Could not upload map, and therefore not make RunningWild for this map. Please try another map!",
            1
          );
        } else {
          z.map.id = id;
          z.open_dialog("savestaterw", null);
        }
      } else {
        z.open_dialog("savestaterw", null);
      }
    }
  };
  this.saverw = function () {
    var M = new Object();
    var O = z.settings.orunningwild.anid;
    if (O) {
      M.equal_percent = z.settings.orunningwild.equal_percent;
      M.time = z.settings.orunningwild.time;
      M.overtime = Math.floor(z.settings.orunningwild.overtime * 100) / 100;
      M.playername = z.settings.orunningwild.playername;
      if (!M.playername) {
        M.playername = "Guest";
      }
      var S = "";
      for (var T = 0; T < z.settings.orunningwild.allpoints.length; T++) {
        var N = z.settings.orunningwild.allpoints[T].split(",");
        var R = parseInt(N[0]);
        var Q = parseInt(N[1]);
        S += R + "," + Q + " ";
      }
      M.points = S;
      M.splits = z.settings.orunningwild.splits.join(" ");
      M.lengths = z.settings.orunningwild.lengths.join(" ");
      data = JSON.stringify(M);
      $.ajax({
        type: "POST",
        url: "loadsavedata.php",
        dataType: "json",
        data: { data: data, rwsave: 1, anid: O },
        error: function (V, W, U) {
          z.close_dialog();
          z.open_dialog(
            "Unexpexted error",
            "Could not save data! " + W + " " + U,
            1
          );
          return;
        },
        success: function (U) {
          z.close_dialog();
          if (U.status == "OK") {
            if (!z.settings.orunningwild.equal_cmpname) {
              z.settings.orunningwild.equal_cmpname = "course creator";
            }
            if (z.settings.orunningwild.equal_percent >= 0) {
              z.open_dialog(
                "Finished RunningWild!",
                "RunningWild Result:<p><b> " +
                  z.settings.orunningwild.equal_percent +
                  "% equal to " +
                  z.settings.orunningwild.equal_cmpname +
                  " in " +
                  z.settings.orunningwild.time +
                  " + " +
                  Math.floor(z.settings.orunningwild.overtime * 100) / 100 +
                  " seconds.</b><p>Use the menu to the right to compare to other RunningWild routes and look at the analysis leg by leg.",
                1
              );
            } else {
              z.open_dialog(
                "Finished RunningWild!",
                "RunningWild Result: <p>Time: " +
                  z.settings.orunningwild.time +
                  " + " +
                  Math.floor(z.settings.orunningwild.overtime * 100) / 100 +
                  " seconds.</b><p>Click OK to continue. No route to compare with!",
                1
              );
            }
            z.loadotherrw();
          } else {
            z.open_dialog("Error! Could not save data!", U.status, 1);
          }
        },
      });
    } else {
      alert("Could not save data for this RunningWild - is it not saved?");
    }
  };
  this.loadState = function (M) {
    $.ajax({
      type: "GET",
      url: "loadsavedata.php?load=1&id=" + M,
      dataType: "json",
      error: function (O, Q, N) {
        alert("Unexpected error: Could not load data! " + Q + " " + N);
        return;
      },
      success: function (S) {
        z.loadStatedata = S;
        if (z.loadStatedata.savedata.settings.runningwild) {
          if (globrunningwild) {
            z.loadStatedata.savedata.settings.orunningwild.anid = M;
            z.loadStatedata.savedata.settings.orunningwild.playername =
              globrunningwild.playername;
          } else {
            z.open_dialog(
              "Error",
              "Error - could not load this RunningWild - it looks like you got an outdated link. Please check the link!<p><a href='http://3drerun.worldofo.com'>Go to 3DRerun main page</a>",
              0
            );
            return;
          }
        }
        if (S.error) {
          z.open_dialog(
            "Error",
            "Error - could not load this analysis! Please check the link!<p><a href='http://3drerun.worldofo.com'>Go to 3DRerun main page</a>",
            0
          );
          return;
        }
        var Q = new Array();
        var R = new Array();
        var T = new Array();
        for (var O = 0; O < S.savedata.maps.length; O++) {
          var N = S.savedata.maps[O].id;
          if (N == undefined) {
          } else {
            Q.push(N);
            R.push(1);
            T.push(0);
          }
        }
        for (var O = 0; O < S.savedata.routes.length; O++) {
          Q.push(S.savedata.routes[O].id);
          R.push(0);
          T.push(1);
        }
        z.load3DRerun(Q, R, T);
      },
    });
  };
  this.loadState_analysis = function (M) {
    $.ajax({
      type: "GET",
      url: "loadsavedata.php?load=1&id=" + M,
      dataType: "json",
      error: function (O, Q, N) {
        alert("Unexpected error: Could not load data! " + Q + " " + N);
        return;
      },
      success: function (N) {
        z.loadStatedata = N;
        if (N.error) {
          z.open_dialog(
            "Error",
            "Error - could not load this analysis! Please check the link!<p><a href='http://3drerun.worldofo.com'>Go to 3DRerun main page</a>",
            0
          );
          return;
        } else {
          setTimeout("mapviewer.applyloadState_analysis()", 2500);
        }
      },
    });
  };
  this.applyloadState_analysis = function () {
    var O = z.loadStatedata.savedata;
    z.playtime = O.playtime;
    z.zerotime = O.zerotime;
    z.canvas.cx = O.cx;
    z.canvas.cy = O.cy;
    z.canvas.zoomfactor = O.zoomfactor;
    z.tags = O.tags;
    var Q = z.settings;
    z.settings = O.settings;
    if (
      z.settings.mode == z.settings.modes.AnalysisMode &&
      z.settings.showdrawdots == 0 &&
      z.settings.autoanalysis == 0
    ) {
      $("#selectmode").val("analysis");
      $("#selectmode").change();
    } else {
      if (
        z.settings.mode == z.settings.modes.AnalysisMode &&
        z.settings.showdrawdots == 1
      ) {
        $("#selectmode").val("dotanalysis");
        $("#selectmode").change();
      } else {
        if (
          z.settings.mode == z.settings.modes.AnalysisMode &&
          z.settings.autoanalysis == 1
        ) {
          $("#selectmode").val("autoanalysis");
          $("#selectmode").change();
        } else {
          if (
            z.settings.mode == z.settings.modes.DrawCourseMode &&
            z.settings.analyzecourse == 0
          ) {
            $("#selectmode").val("drawcourse");
            $("#selectmode").change();
          } else {
            if (
              z.settings.mode == z.settings.modes.DrawCourseMode &&
              z.settings.analyzecourse == 1
            ) {
              $("#selectmode").val("analyzecourse");
              $("#selectmode").change();
            }
          }
        }
      }
    }
    z.settings = O.settings;
    for (var R in Q) {
      if (!z.settings.hasOwnProperty(R)) {
        z.settings[R] = Q[R];
      }
    }
    $("#autoanalysis_adjust_ch").val(
      z.settings.autoanalysis_adjusted.toString()
    );
    for (var M = 0; M < O.routes.length; M++) {
      for (var N = 0; N < z.routes.length; N++) {
        if (O.routes[M].runnername == z.routes[N].runnername) {
          z.routes[N].offset = O.routes[M].offset;
          z.routes[N].color = O.routes[M].color;
          z.routes[N].orgcolor = O.routes[M].orgcolor;
          z.routes[N].runnername = O.routes[M].runnername;
          z.routes[N].show = O.routes[M].show;
          z.routes[N].segmentlength = O.routes[M].segmentlength;
          z.routes[N].segmentpace = O.routes[M].segmentpace;
          z.routes[N].taillength = O.routes[M].taillength;
          z.routes[N].splits = O.routes[M].splits;
          z.routes[N].variants = O.routes[M].variants;
        }
      }
    }
    z.segments = O.segments;
    z.numsegments = O.numsegments;
    if (z.segments) {
    }
    z.coursecoords = O.coursecoords;
    z.update_routediv(false);
    z.request_redraw();
    this.loadStatedata = null;
  };
  this.applyloadState = function () {
    var N = z.loadStatedata.savedata;
    var Q = z.courseinfo;
    z.playtime = N.playtime;
    z.zerotime = N.zerotime;
    z.canvas.cx = N.cx;
    z.canvas.cy = N.cy;
    z.canvas.zoomfactor = N.zoomfactor;
    z.tags = N.tags;
    var O = z.settings;
    z.settings = N.settings;
    if (
      z.settings.mode == z.settings.modes.AnalysisMode &&
      z.settings.showdrawdots == 0 &&
      z.settings.autoanalysis == 0
    ) {
      $("#selectmode").val("analysis");
      $("#selectmode").change();
    } else {
      if (
        z.settings.mode == z.settings.modes.AnalysisMode &&
        z.settings.showdrawdots == 1
      ) {
        $("#selectmode").val("dotanalysis");
        $("#selectmode").change();
      } else {
        if (
          z.settings.mode == z.settings.modes.AnalysisMode &&
          z.settings.autoanalysis == 1
        ) {
          $("#selectmode").val("autoanalysis");
          $("#selectmode").change();
        } else {
          if (
            z.settings.mode == z.settings.modes.DrawCourseMode &&
            z.settings.analyzecourse == 0
          ) {
            $("#selectmode").val("drawcourse");
            $("#selectmode").change();
          } else {
            if (
              z.settings.mode == z.settings.modes.DrawCourseMode &&
              z.settings.analyzecourse == 1
            ) {
              $("#selectmode").val("analyzecourse");
              $("#selectmode").change();
            }
          }
        }
      }
    }
    z.settings = N.settings;
    for (var R in O) {
      if (!z.settings.hasOwnProperty(R)) {
        z.settings[R] = O[R];
      }
    }
    $("#autoanalysis_adjust_ch").val(
      z.settings.autoanalysis_adjusted.toString()
    );
    for (var M = 0; M < N.routes.length; M++) {
      z.routes[M].offset = N.routes[M].offset;
      z.routes[M].color = N.routes[M].color;
      z.routes[M].orgcolor = N.routes[M].orgcolor;
      z.routes[M].runnername = N.routes[M].runnername;
      z.routes[M].show = N.routes[M].show;
      z.routes[M].segmentlength = N.routes[M].segmentlength;
      z.routes[M].segmentpace = N.routes[M].segmentpace;
      z.routes[M].taillength = N.routes[M].taillength;
      z.routes[M].splits = N.routes[M].splits;
      z.routes[M].variants = N.routes[M].variants;
    }
    z.segments = N.segments;
    z.numsegments = N.numsegments;
    if (z.segments) {
    }
    z.coursecoords = N.coursecoords;
    var Q = z.courseinfo;
    z.courseinfo = N.courseinfo;
    if (z.courseinfo) {
      for (var R in Q) {
        if (!z.courseinfo.hasOwnProperty(R)) {
          z.courseinfo[R] = Q[R];
        }
      }
    } else {
      z.courseinfo = Q;
    }
    z.courseinfo.usegradedelevation = 0;
    z.settings.pacecoloring.thinlinewidth = 1;
    z.settings.pacecoloring.type = 1;
    z.update_routediv(false);
    z.request_redraw();
    this.loadStatedata = null;
  };
  this.doloadsplits = function (R, V) {
    if (!z.coursecoords) {
      alert("No course defined -!");
    } else {
      if (z.coursecoords.length < 1) {
        alert("No course defined --!");
      } else {
        if (R == 0) {
          for (var M = 0; M < z.routes.length; M++) {
            z.routes[M].runnername = z.routes[M].runnername.replace(
              /^\d+ /,
              ""
            );
          }
          if (!V) {
            V = $("#addsplitstext").val();
          }
          var ab = V;
          if (ab) {
            var aa = ab.split("\n");
            text = 'Add splits to runners<form id="addsplits">';
            text =
              '<input type="hidden" id="splitant" value="' +
              z.routes.length +
              '">';
            text = text + "<table cellpadding=3>";
            for (var M = 0; M < z.routes.length; M++) {
              name = z.routes[M].runnername;
              tname = name;
              tname = tname.replace(/,/g, "");
              tname = tname.replace(/\s+/, "");
              tname = tname.replace(/\(.*?\)/, "");
              tname = tname.replace(/ $/, "");
              text =
                text +
                '<tr><td title="' +
                tname +
                '"><b>' +
                name +
                "</b></td><td> --> </td><td>";
              text =
                text +
                '<select id="route_' +
                M +
                '"><option value="-1">------------</option>';
              for (var ac = 0; ac < aa.length; ac++) {
                var U = aa[ac];
                if (U) {
                  var S = "";
                  var X = U.split(";");
                  var O = X[0];
                  var Y = X[0].split(/ /);
                  var W = Y[1] + " " + Y[0];
                  W = W.replace(/\s+/, "");
                  O = O.replace(/\s+/, "");
                  if (O.toLowerCase() == tname.toLowerCase()) {
                    S = "selected";
                  }
                  if (W.toLowerCase() == tname.toLowerCase()) {
                    S = "selected";
                  }
                  text =
                    text +
                    "<option " +
                    S +
                    ' value="' +
                    U +
                    '">' +
                    X[0] +
                    "</option>";
                }
              }
            }
            text = text + "</table><p>";
            text =
              text +
              '<button onclick="mapviewer.doloadsplits(1);return false;">Load splits</button><p></form>';
            z.open_dialog("doloadsplits", text);
          } else {
            alert("No splits found!");
          }
        } else {
          for (var M = 0; M < z.routes.length; M++) {
            z.routes[M].manualsplits = 0;
          }
          z.calculate_autosplits();
          var Z = parseInt($("#splitant").val());
          controlnu = 1;
          if (Z >= 0) {
            for (var ac = 0; ac < Z; ac++) {
              var aa = $("#route_" + ac).val();
              if (aa && aa != -1) {
                var N = aa.split(";");
                aa = "";
                for (var M = 1; M < N.length; M++) {
                  aa = aa + N[M] + ";";
                }
                aa = aa.substr(0, aa.length - 1);
                z.routes[ac].addsplits(4, aa, controlnu);
              }
            }
            for (var M = 0; M < z.routes.length; M++) {
              if (!z.routes[M].manualsplits) {
                z.routes[M].show = 0;
              } else {
                z.routes[M].show = 1;
              }
            }
            z.settings.mode = z.settings.modes.AnalysisMode;
            z.settings.analyzecourse = 1;
            z.settings.showdrawdots = 0;
            z.settings.autoanalysis = 0;
            if (z.playing) {
              z.toggleplay();
            }
            z.request_redraw();
            z.close_dialog();
          } else {
            z.close_dialog();
            alert("No split times loaded!");
          }
          var T = new Array();
          for (var Q = 0; Q < z.coursecoords.length - 1; Q++) {
            T[Q] = new Object();
            T[Q].index = Q * 10000;
          }
          for (var M = 0; M < z.routes.length; M++) {
            if (z.routes[M].manualsplits == 0) {
              z.routes[M].manualsplits = 1;
              z.routes[M].splits = T;
            }
          }
        }
      }
    }
  };
  this.open_fulldialog = function (N, M) {
    $("#fulldialog").html("<h1>" + N + "</h1>" + M);
    $("#fulldialog_outer").slideDown();
  };
  this.close_fulldialog = function (M) {
    $("#fulldialog_outer").hide();
  };
  this.open_dialog = function (am, ag, V) {
    var S = 0;
    var av = 0;
    var T = "bottom";
    var Z = true;
    var ad = 650;
    var aq = 300;
    if (am == "savestate") {
      ag =
        'Save an analysis state to be able to open it up later or share them with your trainer/friends.<p><font size=1>Warning! This is a very experimental feature, and analysis states you save now may be broken in later versions of 2DRerun. It will not work if you are not logged in (<a target=_blank href="http://3drerun.worldofo.com/login.php">Log in here in another window, close this message window, and click "s" again to save if you are not logged in</a>). Saved analyses are not always listed - remember to copy the link!</font><p><form id="savestate"><table><tr><td><b>Analysis name</b></td><td><input type="hidden" id="savestatetype" value=""><input id="savestatename" type="text" onkeypress="return noenter(\'saveState\')" name="name"></td></tr><tr><td valign=top><b>Description</b></td><td><textarea id="savestatedesc" cols=40 rows=3></textarea></td></tr></table></form><button onclick="mapviewer.saveState();return false;">Save state</button>';
      am = "Save analysis state";
    } else {
      if (am == "eleprofile") {
        am = "Elevation Profile";
        aq = getBrowserHeight() - 100;
        ad = getBrowserWidth() - 30;
        Z = false;
      } else {
        if (am == "savestaterw") {
          var ad = 650;
          var M = "";
          if (z.coursecoords.length <= 1) {
            am = "Error";
            ag = "You need to define a course before saving a RunningWild!";
            V = 1;
          } else {
            aq = getBrowserHeight() - 100;
            ag =
              "Save a RunningWild setup!<br><font size=1>" +
              M +
              '<p>RunningWilds may/may not be listed - remember to copy the link!</font><p><form id="savestate"><table> <tr><td><b>RunningWild name</b></td><td><input type="hidden" id="savestatetype" value="runningwild"><input id="savestatename" type="text" onkeypress="return noenter(\'saveState\')" name="name"></td></tr> <tr><td valign=top><b>Description</b></td><td><textarea id="savestatedesc" cols=40 rows=3></textarea></td></tr> <tr><td><b>Meters away for different route</b></td><td><select id="rwmetersaway" name="metersaway"><option value="5">5</option><option value="15">15</option><option value="20">20</option><option value="25">25</option><option value="30" selected>30</option><option value="50">50</option><option value="100">100</option><option value="10">10</option></select></td></tr> <tr><td><b>Show course</b></td><td><select id="rwshowcourse" name="showcourse"><option value="1">Yes</option><option value="0">No</option></select></td></tr> <tr><td><b>Compare with ideal/GPS route (if available)</b></td><td><select id="rwcompareideal" name="compareideal"><option value="1">Yes</option><option value="0">No</option></select></td></tr> <tr><td><b>Speed</b></td><td><select id="rwspeed" name="speed"><option value="3">3 - Slow</option><option value="6">6 - Normal</option><option value="9">9 - Fast</option><option value="1">1 - Very slow</option></select></td></tr><tr><td><b>Require password to draw route (empty = no password)</b></td><td><input id="passworddraw" type="text" onkeypress="return noenter(\'saveState\')" name="passworddraw"></td></tr> <tr><td><b>Password to show routes/analysis (empty = no password)</b></td><td><input id="password" type="text" onkeypress="return noenter(\'saveState\')" name="password"></td></tr> </table></form><button onclick="mapviewer.saveState();return false;">Save state</button>';
            am = "Save RunningWild";
          }
        } else {
          if (am == "savecourse") {
            if (z.coursecoords.length < 2) {
              alert("Too few points/controls in this course - can not save!");
              return;
            }
            routenames = "";
            for (var aG = 0; aG < z.routes.length; aG++) {
              if (z.routes[aG].show) {
                routenames += z.routes[aG].runnername + ", ";
              }
            }
            if (routenames) {
              routenames =
                "<ul><li>" +
                routenames.substr(0, routenames.length - 2) +
                "</li></ul>";
            }
            aq = getBrowserHeight() - 100;
            if (xc) {
              ag =
                'Make course-file which may later be loaded into XCViewer by drag-and-drop.<p><button onclick="mapviewer.saveCourse();return false;">Save course</button>';
            } else {
              ag =
                "You are now about to save a course and <b>add all currently shown routes</b> to the course, i.e. the routes:" +
                routenames +
                '<font size=1>Note that the routes will only be added to the course if they do not already belong to another GPS course. You may, however, manually add the routes to the course using the link which you get here after saving the course.</font><p><form id="savecourse"><table><tr><td><b>Course name</b></td><td><input id="savecoursename" type="text" onkeypress="return noenter(\'saveCourse\')" name="name"></td></tr><!--<tr><td valign=top><b>Description</b></td><td><textarea id="savecoursedesc" cols=40 rows=2></textarea></td></tr>--></table></form><button onclick="mapviewer.saveCourse();return false;">Save course</button><p><font size=1>Note! Saving will only work if you are logged in (<a target=_blank href="http://3drerun.worldofo.com/login.php">Log in here in another window, close this message window, and try again if you are not logged in</a>).</font>';
            }
            am = "Save course";
          } else {
            if (am == "loadcourseserver") {
              ag = '<div id="xcservertable"><img src="loading.gif"></div>';
              $.ajax({
                type: "POST",
                url: "listxcserver.php",
                dataType: "text",
                error: function (aK, aL, aJ) {
                  z.close_dialog();
                  z.open_dialog(
                    "Unexpexted error",
                    "Could not load from server! " + aL + " " + aJ,
                    1
                  );
                  return;
                },
                success: function (aJ) {
                  $("#xcservertable")[0].innerHTML = aJ;
                },
              });
            } else {
              if (am == "savecourseserver") {
                if (z.coursecoords.length < 2) {
                  alert(
                    "Too few points/controls in this course - can not save!"
                  );
                  return;
                }
                routenames = "";
                for (var aG = 0; aG < z.routes.length; aG++) {
                  if (z.routes[aG].show) {
                    routenames += z.routes[aG].runnernameshort + ", ";
                  }
                }
                if (routenames) {
                  routenames =
                    "<ul><li>" +
                    routenames.substr(0, routenames.length - 2) +
                    "</li></ul>";
                }
                aq = getBrowserHeight() - 100;
                ag =
                  '<h3>Save session to server</h3><table>Note! This session will be accessible by all users of XCviewer light.<p><tr><td><b>Place (e.g. Holmenkollen)</b></td><td><input size=30 name="save_place" id="save_place"></td></td><tr><td><b>Course name (e.g. 5 km)</b></td><td><input size=30 name="save_coursename" id="save_coursename"></td></td><tr><td><b>Session name (e.g. I3-intervaller)</b></td><td><input size=30 name="save_sessionname" id="save_sessionname"></td></td><tr><td><b>Group (e.g. Rekrutt herrer)</b></td><td><input size=30 name="save_groupname" id="save_groupname"></td></td></table><p><button onclick="mapviewer.saveCourse(\'XCserverform\');return false;">Save to server</button>';
              } else {
                if (am == "saveroutesandcourse") {
                  aq = getBrowserHeight() - 100;
                  if (xc) {
                    ag =
                      'Make file with routes and courses which may later be loaded into XCViewer by drag-and-drop.<p><button onclick="mapviewer.saveCourse(null,null,1);return false;">Save routes and course</button>';
                  } else {
                    ag =
                      'Make file with routes and courses which may later be loaded by drag-and-drop if this functionality is included in your account.<p><button onclick="mapviewer.saveCourse(null,null,1);return false;">Save routes and course</button>';
                  }
                  am = "Save routes and course";
                } else {
                  if (am == "Elevation profile") {
                    Z = false;
                    ad = 750;
                    aq = 270;
                  } else {
                    if (am == "Compare elevation profiles") {
                      Z = false;
                      ad = getBrowserWidth() - 30;
                      aq = getBrowserHeight() / 2;
                      if (z.dialogbox.dialog("isOpen")) {
                        $("#plotdialog").remove();
                      }
                    } else {
                      if (am == "tag") {
                        Z = false;
                        t = z.currenttag.time;
                        t_pretty = tominsec(t);
                        at_pos = z.currenttag.length;
                        N =
                          "<tr><td><b>Position</b></td><td>" +
                          tominsec(t) +
                          " minutes / " +
                          Math.round(at_pos) +
                          " meter</td></tr>";
                        if (z.currenttag.type == "segment") {
                          ad = 650;
                          aq = 330;
                          dt_pretty = tominsec(z.currenttag.totime - t);
                          to_pos = z.currenttag.tolength;
                          aa = to_pos - at_pos;
                          pace = tominsec(
                            Math.round(((z.currenttag.totime - t) / aa) * 1000)
                          );
                          z.currenttag.pace = pace;
                          z.currenttag.dt =
                            z.currenttag.totime - z.currenttag.time;
                          N =
                            N +
                            "<tr><td><b>Length</b></td><td>" +
                            Math.round(aa) +
                            " meter / " +
                            dt_pretty +
                            " minutes</td></tr>";
                          N =
                            N +
                            "<tr><td><b>Pace</b></td><td>" +
                            pace +
                            " min/km</td></tr>";
                          z.currenttag.timeinfo =
                            Math.round(aa) + "m / " + pace + " min/km";
                        } else {
                          ad = 650;
                          aq = 300;
                          z.currenttag.pace = null;
                          z.currenttag.dt = null;
                          z.currenttag.timeinfo = tominsec(t);
                        }
                        aD = "<option>-</option>";
                        for (
                          var aG = 0;
                          aG < z.settings.tagcategories.length;
                          aG++
                        ) {
                          aD =
                            aD +
                            "<option>" +
                            z.settings.tagcategories[aG] +
                            "</option>";
                        }
                        tagtype =
                          '<tr><td><b>Type</b></td><td><select name="tagcategory" id="tagcategory">' +
                          aD +
                          '</select> or new type: <input id="newtagtype" type="text" onkeypress="return noenter(\'addTag\')" name="newtagtype"></td></tr>';
                        ag =
                          "Annotate " +
                          z.currenttag.type +
                          " on route of " +
                          ag +
                          '.<p><form id="savetag"><table>' +
                          N +
                          '<tr><td><b>Name</b></td><td><input id="savetagname" type="text" onkeypress="return noenter(\'addTag\')" name="name"></td></tr><tr><td valign=top><b>Description</b></td><td><textarea id="savetagdesc" cols=40 rows=3></textarea></td></tr>' +
                          tagtype +
                          '</table></form><button onclick="mapviewer.addTag();return false;">Add tag</button>';
                        am = "Annotate " + z.currenttag.type;
                      } else {
                        if (am == "routetag") {
                          Z = false;
                          var aA = new Array(
                            "ff0000|Red",
                            "005500|Green",
                            "0000ff|Blue",
                            "555555|Gray",
                            "00CC00|LGreen",
                            "993399|Purple",
                            "0099FF|LightBlue"
                          );
                          var aD = "";
                          for (var aE = 0; aE < aA.length; aE++) {
                            var af = "";
                            var X = aA[aE].split("|");
                            if (aE == z.settings.tagging_lastcolorindex) {
                              af = "selected ";
                            }
                            aD =
                              aD +
                              "<option " +
                              af +
                              "value='" +
                              X[0] +
                              "'>" +
                              X[1] +
                              "</option>";
                          }
                          z.settings.tagging_lastcolorindex++;
                          if (
                            z.settings.tagging_lastcolorindex >=
                            aA.length - 1
                          ) {
                            z.settings.tagging_lastcolorindex = 0;
                          }
                          tagcolor =
                            '<tr><td><b>Color</b></td><td><select name="tagcolor" id="tagcolor">' +
                            aD +
                            "</select></td></tr>";
                          ad = 650;
                          aq = 330;
                          var aa = z.currenttag.length;
                          var N =
                            "<tr><td><b>Length</b></td><td>" +
                            Math.round(aa) +
                            " meter</td></tr>";
                          ag =
                            'Annotate drawn route<p><form id="savetag"><table>' +
                            N +
                            '<tr><td><b>Name</b></td><td><input id="savetagname" type="text" onkeypress="return noenter(\'addrouteTag\')" name="name"></td></tr><tr><td valign=top><b>Description</b></td><td><textarea id="savetagdesc" cols=40 rows=3></textarea></td></tr>' +
                            tagcolor +
                            '</table></form><button onclick="mapviewer.addrouteTag();return false;">Add tag</button>';
                          am = "Annotate drawn route";
                        } else {
                          if (am == "pacechart") {
                            Z = false;
                            ag = '<div id="pacechart"></div>';
                            am = "Pace chart";
                            ad = getBrowserWidth() - 30;
                            aq = 300;
                          } else {
                            if (am == "xcchart") {
                              Z = false;
                              ag = '<div id="pacechart"></div>';
                              am = "XC chart";
                              ad = getBrowserWidth() - 30;
                              aq = getBrowserHeight() / 2;
                            } else {
                              if (am.substr(0, 7) == "Compare") {
                                ad = getBrowserWidth() - 30;
                                aq = getBrowserHeight() / 2;
                              } else {
                                if (am.substr(0, 7) == "Segment") {
                                  ad = getBrowserWidth() / 2;
                                  aq = getBrowserHeight() - 30;
                                } else {
                                  if (am == "Password required") {
                                    Z = true;
                                    ag =
                                      'The one making this RunningWild wants you to draw your choice before seeing what others have drawn. Therefore a password is needed in order to view all drawn routes.<p><b>Password:</b> <input id="password"><p><button onclick="mapviewer.showrwroutes_direct(\'password\');">View all routes</button>';
                                  } else {
                                    if (am == "tagtable") {
                                      Z = false;
                                      ag = '<div id="tagtable"></div>';
                                      am = "Annotation overview";
                                      ad = getBrowserWidth() - 30;
                                      aq = 400;
                                    } else {
                                      if (am == "splitstable") {
                                        Z = false;
                                        ag =
                                          '<div id="splitstable"></div><p><textarea id="splitsexport"></textarea>';
                                        am = "Splits analysis";
                                        ad = getBrowserWidth() - 30;
                                        aq = 400;
                                      } else {
                                        if (am == "Advanced Options") {
                                          Z = false;
                                          ad = 600;
                                          aq = 500;
                                          var aF = "Pace/pulse";
                                          var az = "Pace";
                                          if (
                                            !z.settings.pacecoloringslider
                                              .minsec
                                          ) {
                                            aF = "Temperature";
                                            az = "Temperature";
                                          }
                                          ag =
                                            'Various advanced options for 2DRerun.<hr><form id="settings"><span class="formtitle">Settings: Color by ' +
                                            aF +
                                            '</span><br><span class="formlabel">' +
                                            az +
                                            ' smoothing - pace range for coloring: <span class="formvalue" id="slider-range-pace-range-val"></span></span><p><div id="slider-range-pace-range"></div><p><span class="formlabel">Pace smoothing - number of seconds: <span class="formvalue" id="slider-range-pace-smoothing-dt-val"></span></span><p><div id="slider-range-pace-smoothing-dt"></div><p><span class="formlabel">Pace smoothing - width-of-thin-line: <span class="formvalue" id="slider-range-pace-thinlinewidth-val"></span></span><p><div id="slider-range-pace-thinlinewidth"></div><p><span class="formlabel">Pulse smoothing - pulse range for coloring: <span class="formvalue" id="slider-range-pulse-range-val"></span></span><p><div id="slider-range-pulse-range"></div><p><span class="formtitle">Settings: Pacegraph</span><br><span class="formlabel">Pace range to be shown: <span class="formvalue" id="slider-range-pace-graph-val"></span></span><p><div id="slider-range-pace-graph"></div><p><span class="formlabel">Pace graph interval (seconds): <span class="formvalue" id="slider-range-pace-graph-dt-val"></span></span><p><div id="slider-range-pace-graph-dt"></div><p><span class="formtitle">Settings: In/out of control</span><br><span class="formlabel">Distance to calculate in/out of control (meters): <span class="formvalue" id="slider-range-in-out-control-val"></span></span><p><div id="slider-range-in-out-control"></div><p><span class="formtitle">Settings: Radius to click to get runner (m)</span><br><span class="formlabel">Radius (meters): <span class="formvalue" id="slider-rad-val"></span></span><p><div id="slider-rad"></div><p><span class="formtitle">Settings: Find distinct routechoices</span><br><span class="formlabel">Distance D apart to be defined as different routechoice (meters): <span class="formvalue" id="slider-dist-route-val"></span></span><p><div id="slider-dist-route"></div><p><span class="formlabel">Minimum percentage of route which is D meters away: <span class="formvalue" id="slider-perc-route-val"></span></span><p><div id="slider-perc-route"></div><p><span class="formtitle">Settings: AutOanalysis</span><br><span class="formlabel">Distance apart to be defined as same routechoice:<span class="formvalue" id="slider-auto-dist-val"></span></span><p><div id="slider-auto-dist"></div><p><span class="formlabel">Shortest autOsplit for same routechoice:<span class="formvalue" id="slider-auto-shortest-val"></span></span><p><div id="slider-auto-shortest"></div><p><span class="formlabel">Number of seconds to search forward in time:<span class="formvalue" id="slider-auto-search-val"></span></span><p><div id="slider-auto-search"></div><p><span class="formtitle">Settings: Save video (ctrl-Q to start/stop video)</span><br><span class="formlabel">Maximum number of frames <span class="formvalue" id="slider-save-maxframes-val"></span></span><p><div id="slider-save-maxframes"></div><p><span class="formlabel">Frames per seconds <span class="formvalue" id="slider-save-framespersec-val"></span></span><p><div id="slider-save-framespersec"></div><p><span class="formlabel">Speed <span class="formvalue" id="slider-save-speed-val"></span></span><p><div id="slider-save-speed"></div><p><span class="formlabel">Format (0=GIF, 1=webM) <span class="formvalue" id="slider-save-format-val"></span></span><p><div id="slider-save-format"></div><p></form><!--<button onclick="mapviewer.applySettings();return false;">Apply settings</button>--><div id="slider-savelink"></div>';
                                        } else {
                                          if (am == "Add splits manually") {
                                            Z = true;
                                            ad = 600;
                                            aq = 440;
                                            routenumber = ag;
                                            var ap =
                                              z.routes[routenumber].splits;
                                            if (ap == null) {
                                              ap = new Array();
                                            }
                                            if (ap.length != 0) {
                                              var aw = ap[0].index;
                                              var ax = aw;
                                              nowsplits = "";
                                              nowpassings = "";
                                              for (
                                                var aG = 1;
                                                aG < ap.length;
                                                aG++
                                              ) {
                                                this_passing = ap[aG].index;
                                                this_split = this_passing - aw;
                                                aw = this_passing;
                                                nowsplits =
                                                  nowsplits +
                                                  tominsec(this_split) +
                                                  " ";
                                                nowpassings =
                                                  nowpassings +
                                                  tominsec(this_passing - ax) +
                                                  " ";
                                              }
                                              nowsplits = nowsplits.substr(
                                                0,
                                                nowsplits.length - 1
                                              );
                                              nowpassings = nowpassings.substr(
                                                0,
                                                nowpassings.length - 1
                                              );
                                              ag =
                                                'Add splits manually for runner. Format: 2:00 2:23 1:23 3:56<hr><form id="addsplits"><textarea cols=50 rows=3 id="addsplitstext">' +
                                                nowsplits +
                                                '</textarea><button onclick="mapviewer.routes[' +
                                                routenumber +
                                                '].addsplits(1);mapviewer.close_dialog();return false;">Apply splits</button><p><b>or control passing times</b><textarea cols=50 rows=3 id="addpassingstext">' +
                                                nowpassings +
                                                '</textarea><button onclick="mapviewer.routes[' +
                                                routenumber +
                                                '].addsplits(2);mapviewer.close_dialog();return false;">Apply passings</button><p><b>or reset to automatic calculated splits:</b><br><button onclick="mapviewer.routes[' +
                                                routenumber +
                                                '].addsplits(3);mapviewer.close_dialog();return false;">Reset to automatic splits for runner</button><p></form>';
                                            } else {
                                              ag = "No course defined";
                                            }
                                            var ab = 0;
                                            for (
                                              var aG = 0;
                                              aG < z.routes.length;
                                              aG++
                                            ) {
                                              if (z.routes[aG].variants) {
                                                ab = 1;
                                              }
                                            }
                                            ab = 0;
                                            var ar = routenumber;
                                            if (
                                              z.settings.analyzecourse == 1 &&
                                              ab
                                            ) {
                                              var at = z.lastcontrol;
                                              if (
                                                z.routes[ar].variants[at] !=
                                                null
                                              ) {
                                                variantname =
                                                  z.tags[
                                                    z.routes[ar].variants[at]
                                                  ].name;
                                              }
                                              var U = new Array(
                                                "A",
                                                "B",
                                                "C",
                                                "D",
                                                "E",
                                                "F",
                                                "G",
                                                "H"
                                              );
                                              var O =
                                                '<select id="choosevariant">';
                                              for (
                                                var aG = 0;
                                                aG < U.length;
                                                aG++
                                              ) {
                                                ag = ag + "<br>Variant " + O;
                                              }
                                            }
                                            if (
                                              z.routes[routenumber].maxpulse
                                            ) {
                                              setmaxpulse =
                                                '<tr><td><b>Max pulse</b></td><td><input id="changeinfo_maxpulse" value="' +
                                                z.routes[routenumber].maxpulse +
                                                '" type="text" onkeypress="return noenter()" name="changeinfo_maxpulse"></td></tr>';
                                            } else {
                                              setmaxpulse =
                                                '<input type="hidden" id="changeinfo_maxpulse" value="' +
                                                z.routes[routenumber].maxpulse +
                                                '">';
                                            }
                                            ag =
                                              ag +
                                              '<h3>Change basis information</h3><form id="changerunnerinfo"><table><tr><td><b>Name</b></td><td><input id="changeinfo_name" value="' +
                                              z.routes[routenumber].runnername +
                                              '" type="text" onkeypress="return noenter()" name="changeinfo_name"></td></tr><tr><td><b>Color</b></td><td><input id="changeinfo_color" value="#' +
                                              z.routes[routenumber].color +
                                              '" type="text" onkeypress="return noenter()" name="changeinfo_color"></td></tr>' +
                                              setmaxpulse +
                                              '</table><button onclick="mapviewer.routes[' +
                                              routenumber +
                                              '].dochangenameinfo();mapviewer.close_dialog();return false;">Apply</button><p><button onclick="mapviewer.removeroute(' +
                                              routenumber +
                                              ');mapviewer.close_dialog();return false;">Delete this route (can not be undone)</button><p><button onclick="mapviewer.routes[' +
                                              routenumber +
                                              '].trim_shown();mapviewer.request_redraw();return false;">Delete shown part of route (can not be undone)</button><p>';
                                          } else {
                                            if (am == "Change name/info") {
                                              Z = true;
                                              ad = 600;
                                              aq = 440;
                                              routenumber = ag;
                                              var au =
                                                z.routes[routenumber]
                                                  .runnername;
                                              var aj =
                                                z.routes[routenumber].lapdata;
                                              var ak = "";
                                              if (aj.length) {
                                                ak =
                                                  '<select name="changeinfo_lapstart" id="changeinfo_lapstart">';
                                                ak +=
                                                  '<option value="-1">No change</option>';
                                                for (
                                                  var an = 0;
                                                  an <
                                                  z.routes[routenumber].lapdata
                                                    .length;
                                                  an++
                                                ) {
                                                  ak +=
                                                    '<option value="' +
                                                    an +
                                                    '">' +
                                                    (an + 1) +
                                                    " - start of loop</option>";
                                                }
                                                ak += "</select>";
                                                ak =
                                                  "<tr><td><b>Start position for replay</b></td><td>" +
                                                  ak +
                                                  "</td>";
                                              }
                                              if (1) {
                                                setmaxpulse =
                                                  '<tr><td><b>Max pulse</b></td><td><input id="changeinfo_maxpulse" value="' +
                                                  z.routes[routenumber]
                                                    .maxpulse +
                                                  '" type="text" onkeypress="return noenter()" name="changeinfo_maxpulse"></td></tr>';
                                              } else {
                                                setmaxpulse =
                                                  '<input type="hidden" id="changeinfo_maxpulse" value="' +
                                                  z.routes[routenumber]
                                                    .maxpulse +
                                                  '">';
                                              }
                                              ag =
                                                "Change information for " +
                                                z.routes[routenumber]
                                                  .runnername +
                                                '<hr><form id="changerunnerinfo"><table><tr><td><b>Name</b></td><td><input id="changeinfo_name" value="' +
                                                z.routes[routenumber]
                                                  .runnername +
                                                '" type="text" onkeypress="return noenter()" name="changeinfo_name"></td></tr><tr><td><b>Color</b></td><td><input id="changeinfo_color" value="#' +
                                                z.routes[routenumber].color +
                                                '" type="text" onkeypress="return noenter()" name="changeinfo_color"></td></tr>' +
                                                setmaxpulse +
                                                ak +
                                                '</table><button onclick="mapviewer.routes[' +
                                                routenumber +
                                                '].dochangenameinfo();mapviewer.close_dialog();return false;">Apply</button><p><button onclick="mapviewer.removeroute(' +
                                                routenumber +
                                                ');mapviewer.close_dialog();return false;">Delete this route (can not be undone)</button><p><button onclick="mapviewer.routes[' +
                                                routenumber +
                                                '].trim_shown();mapviewer.request_redraw();return false;">Delete shown part of route (can not be undone)</button><p>';
                                            } else {
                                              if (am == "graphsettings") {
                                                S = am;
                                                T = "center";
                                                nr = ag;
                                                Z = true;
                                                am =
                                                  "Advanced graph settings: Graph " +
                                                  (nr + 1);
                                                ad = 600;
                                                aq = 440;
                                                var aC = "";
                                                for (
                                                  var aG = -40;
                                                  aG < 41;
                                                  aG++
                                                ) {
                                                  aC +=
                                                    "<option value=" +
                                                    aG +
                                                    ">" +
                                                    aG +
                                                    "</option>";
                                                }
                                                var aI = "";
                                                for (
                                                  var aG = 10;
                                                  aG < 90;
                                                  aG = aG + 10
                                                ) {
                                                  aI +=
                                                    "<option value=" +
                                                    aG +
                                                    ">" +
                                                    aG +
                                                    "</option>";
                                                }
                                                var ai =
                                                  z.settings.graphs[nr]
                                                    .plottype;
                                                var ae;
                                                var ao = "";
                                                if (ai == 0) {
                                                  ae =
                                                    "<tr><td colspan=2><i>No plot type selected</i><hr></td></tr>";
                                                }
                                                if (ai == 1) {
                                                  ae =
                                                    "<tr><td colspan=2><i>Averaging of time plot taken from global settings</i><hr></td></tr>";
                                                } else {
                                                  var aH = 0;
                                                  if (ai != 0) {
                                                    if (ai >= 1 && ai < 5) {
                                                      aH =
                                                        z
                                                          .datafieldtypes_basic_avpoints[
                                                          ai
                                                        ];
                                                    } else {
                                                      if (ai >= 5 && ai < 99) {
                                                        aH =
                                                          z
                                                            .datafieldtypes_avpoints[
                                                            ai - 5
                                                          ];
                                                        avtype =
                                                          z
                                                            .datafieldtypes_avtypes[
                                                            ai - 5
                                                          ];
                                                      } else {
                                                        if (ai >= 101) {
                                                          aH =
                                                            z
                                                              .datafieldtypes_avpoints_o[
                                                              ai
                                                            ];
                                                          avtype =
                                                            z
                                                              .datafieldtypes_avtypes_o[
                                                              ai
                                                            ];
                                                        }
                                                      }
                                                    }
                                                    z.settings.graphs[
                                                      nr
                                                    ].avpoints = parseInt(aH);
                                                    var ay =
                                                      "<option value=" +
                                                      aH +
                                                      ">Use current (" +
                                                      aH +
                                                      ")</option>";
                                                    for (
                                                      var aG = 0;
                                                      aG <= 20;
                                                      aG = aG + 1
                                                    ) {
                                                      ay +=
                                                        "<option value=" +
                                                        aG +
                                                        ">" +
                                                        aG +
                                                        "</option>";
                                                    }
                                                    ae =
                                                      '<tr><td>Averaging number of points</td><td><select id="avpoints" name="avpoints">' +
                                                      ay +
                                                      "</select></td></tr><tr><td colspan=2><hr></td></tr>";
                                                  }
                                                }
                                                if (ai == 1 || ai == 5) {
                                                  var Q =
                                                    mapviewer.courseinfo.segmenttypes.slice();
                                                  Q.push("Complete");
                                                  if (ai == 1) {
                                                    Q.push(
                                                      "Mixed_Stack;Time stacked by segment"
                                                    );
                                                    Q.push(
                                                      "Mixed_Stack_Diff;Timeloss stacked by segment"
                                                    );
                                                  }
                                                  var W =
                                                    z.settings.graphs[nr]
                                                      .aggregate_hillsegments_type;
                                                  var ah = "";
                                                  var Y = "";
                                                  if (
                                                    !z.settings.graphs[nr]
                                                      .aggregate_hillsegments
                                                  ) {
                                                    Y = " selected";
                                                  }
                                                  ah +=
                                                    '<option value="0">No aggregation</option>';
                                                  for (
                                                    var al = 0;
                                                    al < Q.length;
                                                    al++
                                                  ) {
                                                    var Y = "";
                                                    var ac = Q[al].split(";");
                                                    var R = ac[1];
                                                    if (!R) {
                                                      R = ac[0];
                                                    }
                                                    if (
                                                      W == ac[0] &&
                                                      z.settings.graphs[nr]
                                                        .aggregate_hillsegments
                                                    ) {
                                                      Y = " selected";
                                                    }
                                                    ah +=
                                                      '<option value="' +
                                                      ac[0] +
                                                      '"' +
                                                      Y +
                                                      ">" +
                                                      R +
                                                      "</option>";
                                                  }
                                                  var ao =
                                                    "<tr><td colspan=2><b>Use bar plots over segments (uphill/downhill etc.)</b></td></tr>";
                                                  ao +=
                                                    '<tr><td>Aggregate data</td><td><select id="aggregate_hillsegments" name="aggregate_hillsegments">' +
                                                    ah +
                                                    "</select></td></tr>";
                                                }
                                                ag =
                                                  '<hr><form id="graphsettings"><table>' +
                                                  ae +
                                                  ao +
                                                  '</table><hr><button onclick="mapviewer.graphsettings(' +
                                                  nr +
                                                  ',\'change\');return false;">Apply settings</button><hr><table><tr><td><b><font size=4 color="#800">Experimental settings</font></b></td><td></td></tr><tr><td><b>Settings for averaging over hill segments</b></td><td></td></tr><tr><td>Plot as comparison with other athlete</td><td><select id="plotdiff" name="plotdiff"><option value=1>Yes</option><option value=0>No</option></select></td></tr> <tr><td>Average over hill segments</td><td><select id="plot_average_segments" name="plot_average_segments"><option value=1>Yes</option><option value=0>No</option></select></td></tr><tr><td colspan=2><hr></td></tr> <tr><td><b>Settings for averaging over hill segments</b></td><td></td></tr> <tr><td>Include only segments steeper than </td><td><select id="includeele_percent_min" name="includeele_percent_min">' +
                                                  aC +
                                                  '</select>%</td></tr> <tr><td>Include only segments less steep than </td><td><select id="includeele_percent_max" name="includeele_percent_max">' +
                                                  aC +
                                                  '</select>%</td></tr> <tr><td colspan=2><hr></td></tr>  <tr><td><b>Settings for averaging AND comparison</b></td><td></td></tr> <tr><td colspan=2>Ignore segments where more than <select id="fraction_for_zero" name="fraction_for_zero">' +
                                                  aI +
                                                  '</select>% of either is zero</td></tr> </table><button onclick="mapviewer.graphsettings(' +
                                                  nr +
                                                  ",'change-exp');return false;\">Apply experimental settings</button><p>";
                                              } else {
                                                if (am == "loadsplits") {
                                                  Z = true;
                                                  ad = 600;
                                                  aq = 440;
                                                  ag =
                                                    'Upload splits file. Format: <pre>Name\\t2:00\\t2:23\\t1:23\\t3:56\nName2\\t2:00\\t2:23\\t1:23\\t3:56</pre><br>or<br><pre>Name;2:00;2:23;1:23;3:56\nName2;2:00;2:23;1:23;3:56</pre><form id="addsplits"><textarea cols=50 rows=10 name="addsplitstext" id="addsplitstext"></textarea><button onclick="mapviewer.doloadsplits(0);return false;">Load splits</button><p></form>';
                                                } else {
                                                  if (am == "doloadsplits") {
                                                    Z = true;
                                                    ad = getBrowserWidth() - 30;
                                                    aq =
                                                      getBrowserHeight() - 100;
                                                  } else {
                                                    if (
                                                      am ==
                                                      "Add entry to AnalysisLog"
                                                    ) {
                                                      ad =
                                                        (getBrowserWidth() *
                                                          2) /
                                                        3;
                                                      aq =
                                                        getBrowserHeight() -
                                                        100;
                                                      Z = true;
                                                      T = "center";
                                                    } else {
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (ad > (getBrowserWidth() * 2) / 3) {
      ad = (getBrowserWidth() * 2) / 3;
    }
    if (av) {
      z.dialogbox.dialog("open");
    } else {
      z.dialogbox.html(ag);
      var aB = 1;
      z.dialogbox.dialog();
      if (am == "Pace chart" || am == "Annotation overview") {
        aB = 1;
      }
      if (z.dialogbox.dialog("isOpen")) {
        aB = 0;
      } else {
        z.dialogbox.dialog("option", "modal", Z);
        z.dialogbox.dialog("option", "height", aq);
        z.dialogbox.dialog("option", "title", am);
        if (aB) {
          z.dialogbox.dialog("option", "position", T);
        }
        z.dialogbox.dialog("option", "width", ad);
      }
      if (xc) {
        aq = getBrowserHeight() - 100;
        ad = getBrowserWidth() - 30;
        z.dialogbox.dialog("option", "height", aq);
        z.dialogbox.dialog("option", "width", ad);
        T = "center";
        z.dialogbox.dialog("option", "position", T);
      }
      if (V) {
        z.dialogbox.dialog("option", {
          buttons: {
            Ok: function () {
              $(this).dialog("close");
            },
          },
        });
      } else {
        z.dialogbox.dialog("option", { buttons: {} });
      }
      z.dialogbox.dialog("open");
      if (am == "Advanced Options") {
        z.SetupSettings();
      }
      if (S == "graphsettings") {
        $("#plot_average_segments").val(
          z.settings.graphs[nr].plot_average_segments
        );
        $("#plotdiff").val(z.settings.graphs[nr].plotdiff);
        $("#includeele_percent_min").val(
          z.settings.graphs[nr].includeele_percent_min
        );
        $("#includeele_percent_max").val(
          z.settings.graphs[nr].includeele_percent_max
        );
        $("#fraction_for_zero").val(
          z.settings.graphs[nr].fraction_for_zero * 100
        );
      }
    }
  };
  this.open_xdialog = function (S, R, M) {
    var Q = false;
    var N = 500;
    var O = 500;
    N = (getBrowserWidth() * 5) / 6;
    O = getBrowserHeight() - 100;
    z.xdialogbox.dialog("option", "position", "left");
    z.xdialogbox.html(R);
    z.xdialogbox.dialog();
    z.xdialogbox.dialog("option", "modal", Q);
    z.xdialogbox.dialog("option", "height", O);
    z.xdialogbox.dialog("option", "width", N);
    z.xdialogbox.dialog("option", "title", S);
    z.xdialogbox.dialog("open");
    if (M) {
      z.dialogbox.dialog("option", {
        buttons: {
          Ok: function () {
            $(this).dialog("close");
          },
        },
      });
    } else {
      z.dialogbox.dialog("option", { buttons: {} });
    }
  };
  this.open_videodialog = function () {
    var Q = false;
    var N = 500;
    var O = 500;
    var T = "Open video";
    var S;
    if (!(mapviewer.videodialogbox.dialog("option", "title") == T)) {
      z.videosyncroute = 0;
      var M = "";
      for (var R = 0; R < z.routes.length; R++) {
        if (z.routes[R].show) {
          z.videosyncroute = R;
          R = z.routes.length + 1;
        }
      }
      M =
        'Video will be synchronized with <span title="The first runner which is shown is chosen for synchronization"><b>' +
        z.routes[z.videosyncroute].runnername +
        "</b></span>.<br>";
      M =
        M +
        'Video starts <b><span name="videooffset" id="videooffset">0</span></b> seconds after GPS<br><button onclick="mapviewer.syncvideo();return false;">Synchronize video and GPS at current position</button>';
      videospeedinfo =
        '<div style="font-size:11px"><button onclick="mapviewer.controlvideo(\'PlayStop\')">Play/Stop</button> <b>Speed:</b> <button onclick="mapviewer.controlvideo(\'-\')"> -0.1 </button><b><span name="videospeed" id="videospeed">' +
        z.videospeed +
        "</span>x</b><button onclick=\"mapviewer.controlvideo('+')\"> +0.1 </button> <b>Position:</b> <button onclick=\"mapviewer.controlvideo('<<')\"><<</button><button onclick=\"mapviewer.controlvideo('<')\"><</button><button onclick=\"mapviewer.controlvideo('>')\">></button><button onclick=\"mapviewer.controlvideo('>>')\">>></button></div> <p>";
      forgetvideo =
        "<button onclick=\"if (mapviewer.video) {mapviewer.video.src=''};mapviewer.videodialogbox.dialog('option','title','');mapviewer.videodialogbox.dialog('close');\">Forget this video</button><button onclick=\"alert('This HeadCam-analysis functionality is only for local video-files - without uploading to the internet. Choose a file from your local hard drive, synchronize GPS-route and video by positioning video and GPS-position in the same place and clicking the synchronize-button. Then start video - navigate by using the video position slider. Tip! Use Google Chrome for maximum number of video formats (e.g. GoPro Hero2 footage works well in Google Chrome ; use Handbrake to convert your video if your video format is not supported). For long/big videos, you need a computer with a lot of memory.')\">Help</button>";
      S =
        '<video style="width:100%" controls id="videodiv"></video><p><div id="message"></div><div id="choosevideodiv"><input onChange="mapviewer.playvideo();return false;" name="videofileselector" id="videofileselector" type="file" accept="video/*"/><p></div>' +
        videospeedinfo +
        M +
        forgetvideo;
      z.videodialogbox.html(S);
      z.videodialogbox.dialog();
      z.videodialogbox.dialog("option", "modal", Q);
      z.videodialogbox.dialog("option", "height", O);
      z.videodialogbox.dialog("option", "width", N);
      z.videodialogbox.dialog("option", "title", T);
      z.videodialogbox.dialog("option", "position", "bottom");
      z.videodialogbox.dialog("option", { buttons: {} });
      $("#videodiv").bind("timeupdate", function () {
        mapviewer.controlvideo();
      });
      $("#videodiv").bind("play", function () {
        mapviewer.controlvideo("Play");
      });
      $("#videodiv").bind("pause", function () {
        mapviewer.controlvideo("Pause");
      });
    }
    z.videodialogbox.dialog("open");
  };
  this.controlvideo = function (N) {
    if (N == "+") {
      z.videospeed = z.videospeed + 0.1;
    } else {
      if (N == "-") {
        z.videospeed = z.videospeed - 0.1;
        if (z.videospeed < 0.1) {
          z.videospeed = 0.1;
        }
      }
    }
    if (N == "+" || N == "-") {
      $("#videospeed").html(parseInt(z.videospeed * 10) / 10);
      if (z.video) {
        z.video.playbackRate = z.videospeed;
      }
      z.play_speed = z.videospeed;
      if (isNaN(z.play_speed)) {
        z.play_speed = 1;
      }
    }
    if (N == "PlayStop") {
      if (z.video) {
        if (z.video.paused) {
          z.video.play();
          N = "Play";
        } else {
          z.video.pause();
          N = "Pause";
        }
      } else {
        alert("Could not find video");
      }
    }
    if (N == "Pauseb") {
      N = "Pause";
      if (z.video) {
        z.video.pause();
      } else {
        alert("Could not find video");
      }
    }
    if (N == ">") {
      z.video.currentTime = z.video.currentTime + 1;
    }
    if (N == ">>") {
      z.video.currentTime = z.video.currentTime + 10;
    }
    if (N == "<") {
      z.video.currentTime = z.video.currentTime - 1;
    }
    if (N == "<<") {
      z.video.currentTime = z.video.currentTime - 10;
    }
    var M = z.video.currentTime;
    gpstime = z.routes[z.videosyncroute].currenttime(z.playtime);
    var O = gpstime - M;
    if (z.video.paused) {
      z.playtime = z.playtime - (O - z.videooffset);
      z.request_redraw();
    } else {
      if (Math.abs(O - z.videooffset) > 2) {
        if (z.playing) {
          z.toggleplay();
        }
        z.playtime = z.playtime - (O - z.videooffset);
        z.request_redraw();
        z.toggleplay();
      }
    }
    if (N == "Play") {
      $("#playspeedr").val("1x");
      z.video.playbackRate = z.videospeed;
      z.play_speed = z.videospeed;
      if (isNaN(z.play_speed)) {
        z.play_speed = 1;
      }
      if (!z.playing) {
        z.toggleplay();
      }
    } else {
      if (N == "Pause") {
        if (z.playing) {
          z.toggleplay();
        }
      }
    }
  };
  this.syncvideo = function () {
    if (z.video) {
      var M = 0;
      gpstime = z.routes[z.videosyncroute].currenttime(z.playtime);
      if (z.video.currentTime >= 0) {
        videotime = z.video.currentTime;
        z.videooffset = gpstime - videotime;
        M = 1;
        $("#videooffset").html(parseInt(z.videooffset));
      }
      if (!M) {
        alert("Could not access video!");
      }
    } else {
      alert("No video loaded!");
    }
  };
  this.playvideo = function () {
    var O = $("#videofileselector")[0].files[0];
    var R = O.type;
    var T = $("#videodiv")[0];
    var N = T.canPlayType(R);
    N = N === "" ? "no" : N;
    var S = 'Can play type "' + R + '": ' + N;
    var Q = N === "no";
    if (Q) {
      $("#message").html(S);
    } else {
      $("#choosevideodiv").hide();
      var M = URL.createObjectURL(O);
      T.src = M;
      z.video = T;
      z.videooffset = 0;
    }
  };
  this.close_dialog = function () {
    z.dialogbox.dialog("close");
    this.visualize_point = null;
  };
  this.SetupSettings = function () {
    $("#slider-range-pace-range").slider({
      range: true,
      min: z.settings.pacecoloringslider.minpace,
      max: z.settings.pacecoloringslider.maxpace,
      step: 0.01,
      values: [
        mapviewer.settings.pacecoloring.minpace,
        mapviewer.settings.pacecoloring.maxpace,
      ],
      slide: function (M, N) {
        if (z.settings.pacecoloringslider.minsec) {
          $("#slider-range-pace-range-val").html(
            "" + tominsec(N.values[0] * 60) + " - " + tominsec(N.values[1] * 60)
          );
        } else {
          $("#slider-range-pace-range-val").html(
            "" + N.values[0] + " to " + N.values[1]
          );
        }
        mapviewer.settings.pacecoloring.minpace = N.values[0];
        mapviewer.settings.pacecoloring.maxpace = N.values[1];
        mapviewer.request_redraw();
      },
    });
    if (z.settings.pacecoloringslider.minsec) {
      $("#slider-range-pace-range-val").html(
        "" +
          tominsec(mapviewer.settings.pacecoloring.minpace * 60) +
          " - " +
          tominsec(mapviewer.settings.pacecoloring.maxpace * 60)
      );
    } else {
      $("#slider-range-pace-range-val").html(
        "" +
          mapviewer.settings.pacecoloring.minpace +
          " to " +
          mapviewer.settings.pacecoloring.maxpace
      );
    }
    $("#slider-range-pace-smoothing-dt").slider({
      range: false,
      min: 3,
      max: 60,
      values: [mapviewer.settings.pacecoloring.dt],
      slide: function (M, N) {
        $("#slider-range-pace-smoothing-dt-val").html("" + N.values[0]);
        mapviewer.settings.pacecoloring.dt = N.values[0];
        for (j = 0; j < mapviewer.routes.length; j++) {
          mapviewer.routes[j].pace = new Array();
        }
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-pace-smoothing-dt-val").html(
      "" + mapviewer.settings.pacecoloring.dt
    );
    $("#slider-range-pace-thinlinewidth").slider({
      range: false,
      min: 1,
      max: 10,
      values: [mapviewer.settings.pacecoloring.thinlinewidth],
      slide: function (M, N) {
        $("#slider-range-pace-thinlinewidth-val").html("" + N.values[0]);
        mapviewer.settings.pacecoloring.thinlinewidth = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-pace-thinlinewidth-val").html(
      "" + mapviewer.settings.pacecoloring.thinlinewidth
    );
    $("#slider-range-pulse-range").slider({
      range: true,
      min: 0,
      max: 100,
      step: 1,
      values: [
        mapviewer.settings.pulsecoloring.minpulse,
        mapviewer.settings.pulsecoloring.maxpulse,
      ],
      slide: function (M, N) {
        $("#slider-range-pulse-range-val").html(
          "" + parseInt(N.values[0]) + " % - " + parseInt(N.values[1]) + " %"
        );
        mapviewer.settings.pulsecoloring.minpulse = N.values[0];
        mapviewer.settings.pulsecoloring.maxpulse = N.values[1];
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-pulse-range-val").html(
      "" +
        parseInt(mapviewer.settings.pulsecoloring.minpulse) +
        " % - " +
        parseInt(mapviewer.settings.pulsecoloring.maxpulse) +
        " %"
    );
    $("#slider-range-pace-graph").slider({
      range: true,
      min: 2,
      max: 30,
      step: 0.01,
      values: [
        mapviewer.settings.pacegraph.minpace,
        mapviewer.settings.pacegraph.maxpace,
      ],
      slide: function (M, N) {
        $("#slider-range-pace-graph-val").html(
          "" + tominsec(N.values[0] * 60) + " - " + tominsec(N.values[1] * 60)
        );
        mapviewer.settings.pacegraph.minpace = N.values[0];
        mapviewer.settings.pacegraph.maxpace = N.values[1];
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-pace-graph-val").html(
      "" +
        tominsec(mapviewer.settings.pacegraph.minpace * 60) +
        " - " +
        tominsec(mapviewer.settings.pacegraph.maxpace * 60)
    );
    $("#slider-range-pace-graph-dt").slider({
      range: false,
      min: 3,
      max: 60,
      values: [mapviewer.settings.pacegraph.dt],
      slide: function (M, N) {
        $("#slider-range-pace-graph-dt-val").html("" + N.values[0]);
        mapviewer.settings.pacegraph.dt = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-pace-graph-dt-val").html(
      "" + mapviewer.settings.pacegraph.dt
    );
    $("#slider-range-in-out-control").slider({
      range: false,
      min: 20,
      max: 100,
      values: [mapviewer.settings.calc_inout_ringrad],
      slide: function (M, N) {
        $("#slider-range-in-out-control-val").html("" + N.values[0]);
        mapviewer.settings.calc_inout_ringrad = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-range-in-out-control-val").html(
      "" + mapviewer.settings.calc_inout_ringrad
    );
    $("#slider-rad").slider({
      range: false,
      min: 20,
      max: 1000,
      values: [mapviewer.min_moveto_distance],
      slide: function (M, N) {
        $("#slider-rad-val").html("" + N.values[0]);
        mapviewer.min_moveto_distance = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-rad-val").html("" + mapviewer.min_moveto_distance);
    $("#slider-perc-route").slider({
      range: false,
      min: 5,
      max: 95,
      values: [mapviewer.settings.sameroutechoice_percent],
      slide: function (M, N) {
        $("#slider-perc-route-val").html("" + N.values[0]);
        mapviewer.settings.sameroutechoice_percent = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-perc-route-val").html(
      "" + mapviewer.settings.sameroutechoice_percent
    );
    $("#slider-dist-route").slider({
      range: false,
      min: 10,
      max: 200,
      values: [mapviewer.settings.sameroutechoice_distance],
      slide: function (M, N) {
        $("#slider-dist-route-val").html("" + N.values[0]);
        mapviewer.settings.sameroutechoice_distance = N.values[0];
        mapviewer.request_redraw();
      },
    });
    $("#slider-dist-route-val").html(
      "" + mapviewer.settings.sameroutechoice_distance
    );
    $("#slider-auto-dist").slider({
      range: false,
      min: 5,
      max: 200,
      values: [mapviewer.settings.autoanalysis_withindistance],
      slide: function (M, N) {
        $("#slider-auto-dist-val").html("" + N.values[0]);
        mapviewer.settings.autoanalysis_withindistance = N.values[0];
      },
    });
    $("#slider-auto-dist-val").html(
      "" + mapviewer.settings.autoanalysis_withindistance
    );
    $("#slider-auto-shortest").slider({
      range: false,
      min: 10,
      max: 180,
      values: [mapviewer.settings.autoanalysis_maxsamesegmentlength],
      slide: function (M, N) {
        $("#slider-auto-shortest-val").html("" + N.values[0]);
        mapviewer.settings.autoanalysis_maxsamesegmentlength = N.values[0];
      },
    });
    $("#slider-auto-shortest-val").html(
      "" + mapviewer.settings.autoanalysis_maxsamesegmentlength
    );
    $("#slider-auto-search").slider({
      range: false,
      min: 5,
      max: 90,
      values: [mapviewer.settings.autoanalysis_withinseconds_samesegment],
      slide: function (M, N) {
        $("#slider-auto-search-val").html("" + N.values[0]);
        mapviewer.settings.autoanalysis_withinseconds_samesegment = N.values[0];
      },
    });
    $("#slider-auto-search-val").html(
      "" + mapviewer.settings.autoanalysis_withinseconds_samesegment
    );
    $("#slider-save-maxframes").slider({
      range: false,
      min: 25,
      max: 10000,
      values: [mapviewer.settings.savevideo.maxframes],
      slide: function (M, N) {
        $("#slider-save-maxframes-val").html("" + N.values[0]);
        mapviewer.settings.savevideo.maxframes = N.values[0];
      },
    });
    $("#slider-save-maxframes-val").html(
      "" + mapviewer.settings.savevideo.maxframes
    );
    $("#slider-save-framespersec").slider({
      range: false,
      min: 1,
      max: 30,
      values: [mapviewer.settings.savevideo.framespersec],
      slide: function (M, N) {
        $("#slider-save-framespersec-val").html("" + N.values[0]);
        mapviewer.settings.savevideo.framespersec = N.values[0];
      },
    });
    $("#slider-save-framespersec-val").html(
      "" + mapviewer.settings.savevideo.framespersec
    );
    $("#slider-save-speed").slider({
      range: false,
      min: 1,
      max: 100,
      values: [mapviewer.settings.savevideo.speed],
      slide: function (M, N) {
        $("#slider-save-speed-val").html("" + N.values[0]);
        mapviewer.settings.savevideo.speed = N.values[0];
      },
    });
    $("#slider-save-speed-val").html("" + mapviewer.settings.savevideo.speed);
    $("#slider-save-format").slider({
      range: false,
      min: 0,
      max: 1,
      values: [mapviewer.settings.savevideo.format],
      slide: function (M, N) {
        $("#slider-save-format-val").html("" + N.values[0]);
        mapviewer.settings.savevideo.format = N.values[0];
      },
    });
    $("#slider-save-format-val").html("" + mapviewer.settings.savevideo.format);
  };
  this.initLive = function (M) {
    var N = z.liveformat;
    if (z.liveprovider == "gpsseuranta") {
      N = "text";
    } else {
      if (N == "text") {
        N = "json";
      }
    }
    if (z.liveprovider == "tractrac") {
      url = z.liveiniturl;
      if (window.location.host == "localhost") {
        url = "x.php?url=" + encodeURIComponent(url);
      }
    } else {
      if (z.liveprovider == "gpsseuranta") {
        url = z.liveiniturl;
      } else {
        url = z.liveserver + "/init.php?id=" + z.liveid;
        if (N == "json") {
          url = url + "&format=json";
        } else {
          if (N == "jsonp") {
            url = url + "&format=json&jsoncallback=?";
          }
        }
      }
    }
    if (1) {
      $.ajax({
        type: "GET",
        url: url,
        dataType: N,
        error: function (Q, O) {
          if (M) {
            alert("No map found - aborting!");
            return;
          } else {
            z.startLive();
          }
        },
        success: function (T, Q, U) {
          loadstatus = T.status;
          if (loadstatus != "OK") {
            if (z.liveprovider == "gpsseuranta") {
              z.handle_gpsseuranta_init(T, z.liveserver + z.liveid);
            } else {
              if (M) {
                alert("No map found - aborting!");
                return;
              }
            }
          } else {
            if (M) {
              if (z.liveprovider == "tractrac") {
                var S = T.calibration;
                calstring =
                  S[0][0] +
                  "|" +
                  S[0][1] +
                  "|" +
                  S[0][2] +
                  "|" +
                  S[0][3] +
                  "|" +
                  S[1][0] +
                  "|" +
                  S[1][1] +
                  "|" +
                  S[1][2] +
                  "|" +
                  S[1][3] +
                  "|" +
                  S[2][0] +
                  "|" +
                  S[2][1] +
                  "|" +
                  S[2][2] +
                  "|" +
                  S[2][3];
              } else {
                calstring = T.calibration;
              }
              mapurl = T.mapurl;
              mapwidth = parseInt(T.mapw);
              mapheight = parseInt(T.maph);
              if (calstring && mapurl && mapwidth && mapheight) {
                calstring = calstring.replace(/;/g, "|");
                caltype = T.caltype;
                z.loadmap(
                  mapurl,
                  mapwidth,
                  mapheight,
                  calstring,
                  caltype,
                  null,
                  "Nomap"
                );
                if (T.coursecoords) {
                  z.coursecoords = T.coursecoords.split(" ");
                  z.coursecoords.pop();
                  z.settings.showcourse = 1;
                }
                z.redraw();
              } else {
                alert("Could not load map information! Aborting");
              }
            }
            if (z.liveprovider == "tractrac") {
              competitorstr = "";
              var W = T.competitors;
              for (var O = 0; O < W.length; O++) {
                tunit = W[O][0];
                tname = W[O][1];
                tstart = new Date(W[O][2]).getTime();
                competitorstr =
                  competitorstr + (tunit + ";" + tstart + ";" + tname);
                if (O < W.length - 1) {
                  competitorstr = competitorstr + ":";
                }
              }
            } else {
              competitorstr = T.competitors;
            }
            if (competitorstr) {
              var R = competitorstr.split(":");
              for (var V = 0; V < R.length; V++) {
                var aa = R[V].split(";");
                var Z = aa[0];
                var Y = aa[1];
                var X = aa[2];
                thisliveunit = new Object();
                thisliveunit.rnr = null;
                thisliveunit.runnername = X;
                thisliveunit.starttime = Y;
                z.liveunits[Z] = thisliveunit;
              }
            }
          }
          z.startLive();
        },
      });
    } else {
      z.startLive();
    }
  };
  this.handle_gpsseuranta_init = function (U, Q) {
    var O = U.split("\n");
    var Z = 0;
    for (i = 0; i < O.length; i++) {
      var ad = O[i].split(":");
      if (ad[0] == "CALIBRATION") {
        calstring = ad[1];
      } else {
        if (ad[0] == "TIMEZONE") {
          timedifference = ad[1] * 60;
        } else {
          if (ad[0] == "GRABINTERVAL") {
            livegrabinterval = ad[1] * 1;
          } else {
            if (ad[0] == "LIVEBUFFER") {
              livebuffer = ad[1] * 1;
            } else {
              if (ad[0] == "LIVE") {
                Z = ad[1] == "1";
                if (Z) {
                  replaymode = false;
                }
              } else {
                if (ad[0] == "DASHLIMIT") {
                  dashlimit = ad[1] * 1;
                } else {
                  if (ad[0] == "MINBEFORESTART") {
                    showbeforestart = ad[1] * 60;
                  } else {
                    if (ad[0] == "COMMONSTARTTIME") {
                      commonstarttime = ad[1];
                    } else {
                      if (ad[0] == "COMPETITOR") {
                        var T = ad[1].split("|");
                        var aa = T[0];
                        var ac = "000000";
                        switch (T[2].length) {
                          case 3:
                            ac = "0" + T[2] + "00";
                            break;
                          case 4:
                            ac = T[2] + "00";
                            break;
                          case 5:
                            ac = "0" + T[2];
                            break;
                          case 6:
                            ac = T[2];
                            break;
                          default:
                            break;
                        }
                        var R = T[1].substring(0, 4);
                        var M = T[1].substring(4, 6) - 1;
                        var V = T[1].substring(6, 8);
                        var ab = ac.substring(0, 2);
                        var N = ac.substring(2, 4);
                        var S = ac.substring(4, 6);
                        var Y =
                          Date.UTC(R, M, V, ab, N, S) - timedifference * 1000;
                        starttime = T[1];
                        var W = T[3];
                        var X = T[4];
                        thisliveunit = new Object();
                        thisliveunit.rnr = null;
                        thisliveunit.runnername = W;
                        thisliveunit.starttime = starttime;
                        z.liveunits[aa] = thisliveunit;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mapurl = Q + "/map";
    if (mapviewer.livedatamapurloverride) {
      mapurl = mapviewer.livedatamapurloverride;
    }
    caltype = "3point";
    z.loadmap(mapurl, null, null, calstring, caltype, null, "Nomap");
    if (Z) {
      z.gpsseurantaislive = 1;
      if (livegrabinterval) {
        z.liveupdate = livegrabinterval;
      }
    } else {
      z.liveupdate = 100000000;
      z.gpsseurantaislive = 0;
    }
  };
  this.handle_gpsseuranta_data = function (Q) {
    var O = new Array();
    var S = Q.split("\n");
    var M = 1;
    for (M = S.length - 1; M > -1; M--) {
      if (S[M].length > 10) {
        lastline = S[M];
        break;
      }
    }
    if (lastline.length > 30) {
      lastline = lastline.substring(0, 29);
    }
    if (lastline.length < 10) {
      lastline = "undef";
    }
    for (M = 0; M < S.length; M++) {
      var R = S[M].split(".");
      var N = z.decode_gpsseuranta(S[M]);
      if (N != null) {
        O = O.concat(N);
      }
    }
    return O;
  };
  this.decode_gpsseuranta = function (aa) {
    var Q = new Array();
    var O = aa.split(".");
    var X = O[0];
    if (O.length < 2) {
      return null;
    }
    var Z = O[1].split("_");
    var M = Z[1] / 50000;
    var U = Z[2] / 100000;
    var R = Z[0] / 1;
    if (isNaN(U) || isNaN(M)) {
      U = 0;
      M = 0;
    }
    if (M != 0 && U != 0) {
      var W = X + ";" + R.toFixed().pad(12, "0") + ";" + U + ";" + M + "\n";
      Q.push(W);
      var T = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      var V = U;
      var N = M;
      var S = parseInt(R);
      for (k = 2; k < O.length; k++) {
        if (O[k].length < 3) {
          k = O.length + 1;
        } else {
          var Y = O[k].split("_");
          if (Y.length < 3) {
            R = S + T.indexOf(O[k].substring(0, 1)) - 31;
            M = (N * 50000 + T.indexOf(O[k].substring(1, 2)) - 31) / 50000;
            U = (V * 100000 + T.indexOf(O[k].substring(2, 3)) - 31) / 100000;
          } else {
            R = S + Y[0] / 1;
            M = N + Y[1] / 50000;
            U = V + Y[2] / 100000;
          }
          var W;
          if (isNaN(U) || isNaN(M)) {
          } else {
            W = X + ";" + R.toFixed().pad(12, "0") + ";" + U + ";" + M + "\n";
            Q.push(W);
            V = U;
            N = M;
            S = R;
          }
        }
      }
    }
    return Q;
  };
  this.startLive = function () {
    z.play_speed = 1;
    if (!this.livedatapos) {
      this.livedatapos = 0;
    }
    z.getliveservertime();
  };
  this.getliveservertime = function () {
    if (z.liveprovider == "tractrac") {
      url = z.liveserver + "/time.php";
    } else {
      if (z.liveprovider == "gpsseuranta") {
        url = z.liveserver + "time.php";
      } else {
        if (z.liveserver == "http://localhost/ge/liverg/") {
          url = z.liveserver + "time.php";
        } else {
          url = "http://3drerun.worldofo.com/live/time.php";
        }
      }
    }
    var M = z.liveformat;
    if (M == "text" && z.liveprovider != "gpsseuranta") {
      M = "json";
    }
    if (M == "json") {
      url = url + "?format=json";
    } else {
      if (M == "jsonp") {
        url = url + "?format=json&jsoncallback=?";
      }
    }
    $.ajax({
      type: "get",
      url: url,
      dataType: M,
      error: function () {
        alert(
          "Fatal live error: Can not find current server time! Live server is down or wrong live server address given"
        );
      },
      success: function (R, S, Q) {
        if (M == "json" || M == "jsonp") {
          thistime = R.time;
        } else {
          thistime = R;
        }
        var N = parseInt(thistime) * 1000;
        if (N < 707055816000) {
          N = N + 1136070000000;
        }
        console.log("Got time " + N);
        z.replaystarttime_localtime_ms = N;
        z.replaystarttime_competitiontime_ms = N - z.livedelay * 1000;
        z.previousdrawstarttime_ms = null;
        z.playtime =
          ((N - z.replaystarttime_localtime_ms) / 1000) * z.play_speed +
          z.replaystarttime_competitiontime_ms / 1000;
        z.settings.colormode = z.settings.modes.colorbyorg;
        z.reset_taillengths();
        z.playing = 1;
        z.reset_replaystarttime();
        z.recolorbyorg();
        z.IsLive = 1;
        if (z.liveprovider == "tractrac" || z.liveprovider == "dseuranta") {
          if (getURLParameter("dolive")) {
          } else {
            z.realtime = 0;
            z.IsLive = 0;
          }
        }
        for (var O = 0; O < z.routes.length; O++) {
          z.routes[O].offset = 0;
        }
        z.getlivedata();
      },
    });
  };
  this.getlivedata = function () {
    if (!z.IsLive && z.liveprovider != "tractrac") {
      return;
    }
    var M = z.liveformat;
    if (z.liveprovider == "tractrac") {
      url = z.livedataurl + "&p=" + z.livedatapos;
      if (window.location.host == "localhost") {
        url = "x.php?url=" + encodeURIComponent(url);
      }
    } else {
      if (z.liveprovider == "gpsseuranta") {
        if (!z.gpsseurantaislive) {
          url = z.livedataurl + "data.lst";
          z.gpsseurantaislive = 0;
          z.IsLive = 0;
          z.playing = 0;
        } else {
          url =
            z.livedataurl +
            "data.php?offset=" +
            z.livedatapos +
            "&reset=" +
            z.livedatareset;
          if (getURLParameter("dolive")) {
          } else {
            z.IsLive = 0;
            z.playing = 0;
            alert(
              "This event is still LIVE! Note that the GPS-data will not be updated live in 2DRerun."
            );
          }
        }
      } else {
        url = z.liveserver + "/?id=" + z.liveid + "&p=" + z.livedatapos;
        if (M == "json") {
          url = url + "&format=json";
        } else {
          if (M == "jsonp") {
            url = url + "&format=json&jsoncallback=?";
          }
        }
      }
    }
    $.ajax({
      type: "get",
      url: url,
      dataType: M,
      error: function (O, N) {
        z.livetimer = setTimeout(function () {
          z.getlivedata();
        }, z.liveupdate * 1000);
      },
      success: function (R, T, Q) {
        var S = z.liveformat;
        var N;
        var O = R.status;
        if (S == "text") {
          if (R.length > 0) {
            if (R.substring(6, 0) == "<HTML>") {
              O = "NODATA";
            } else {
              O = "OK";
            }
          }
        }
        containslastpos = 0;
        if (O == "OK") {
          if (S == "json" || S == "jsonp") {
            N = R.lastpos;
            containslastpos = R.containslastpos;
          } else {
            N = Q.getResponseHeader("X-GPS-Server-Filesize");
            resetvalue = Q.getResponseHeader("X-GPS-Server-Reset");
            if (!resetvalue) {
              resetvalue = -1;
            }
            if (!N) {
              N = -1;
            }
            z.livedatareset = resetvalue;
          }
          if (!N) {
            z.livedatapos = 0;
          } else {
            z.livedatapos = N;
          }
          z.process_livedata(R);
          if (R.routegadget) {
            z.IsLive = 0;
            $("#selectmode").val("analyzecourse");
            $("#selectmode").change();
          }
        } else {
          if (O == "NOTHING") {
          }
        }
        z.livetimer = setTimeout(function () {
          z.getlivedata();
        }, z.liveupdate * 1000);
      },
    });
  };
  this.process_livedata = function (an) {
    var O;
    var aj = z.liveformat;
    if (z.liveprovider == "tractrac") {
      var ac = an.data;
      if (!ac) {
        ac = new Array();
      }
      if (ac.length) {
        $("#routemenu").html(
          "<center><p>Loading data " +
            z.livedatapos +
            '<p><img src="loading.gif"><p>Be patient<center>'
        );
        for (var R = 0; R < ac.length; R++) {
          var ae = ac[R][0];
          var T = ac[R][1];
          var ao = ac[R][2];
          var am = ac[R][3];
          var ak = new Date(ac[R][4]).getTime() / 1000;
          z.livedata_waiting.push(ae + ";" + ak + ";" + T + ";" + ao);
        }
        var V = an.containslastpos;
        if (!V) {
          z.getlivedata();
          return;
        } else {
          O = z.livedata_waiting;
        }
      } else {
        O = z.livedata_waiting;
      }
    } else {
      if (z.liveprovider == "gpsseuranta") {
        O = z.handle_gpsseuranta_data(an);
        O = O.sort();
      } else {
        if (aj == "json" || aj == "jsonp") {
          O = an.data.split(":");
        } else {
          O = an.split("\n");
        }
      }
    }
    var X = 0;
    livedata = new Array();
    for (var ab = 0; ab < O.length - 1; ab++) {
      var Z = O[ab];
      var af = Z.split(";");
      var ae = af[0];
      var W = parseInt(af[1]);
      var T = af[2];
      var ao = af[3];
      if (T && ao) {
        if (ab < 20) {
        }
        if (z.dummycalibration) {
          var U = z.map.tolatlng(T, ao);
          T = U.lat;
          ao = U.lng;
        }
        var N = z.playtime - W;
        var S = z.liveunits[ae];
        var Q = null;
        if (S) {
          Q = z.liveunits[ae].rnr;
        } else {
          S = new Object();
          S.rnr = null;
          z.liveunits[ae] = S;
        }
        if (!S.runnername && z.liveprovider == "gpsseuranta") {
        } else {
          if (Q == null) {
            var ah = z.getnextcolor();
            var al;
            if (S.runnername) {
              al = S.runnername;
            } else {
              al = ae;
            }
            var ai = "";
            var ad = "";
            var Y = "";
            al = al.replace(/-/, "");
            M = new Route(
              ai,
              ad,
              Y,
              al,
              ae,
              ah,
              1,
              z.routes.length + 1,
              null,
              null,
              null
            );
            z.routes.push(M);
            Q = z.routes.length - 1;
            S.rnr = Q;
            z.update_routediv(false);
            if (M.zerotime + M.latarray.length > z.maxtime) {
              z.maxtime = M.zerotime + M.latarray.length;
            }
          }
          var aa = 0;
          if (z.routes[Q].timearray.length > 0) {
            aa = z.routes[Q].timearray[z.routes[Q].timearray.length - 1];
          }
          if (W > aa) {
            if (!livedata[Q]) {
              livedata[Q] = new Object();
              livedata[Q].points = new Array();
            }
            var ag = new Object();
            ag.lat = T;
            ag.lng = ao;
            ag.time = W;
            livedata[Q].points.push(ag);
          } else {
          }
        }
      }
    }
    for (var Q = 0; Q < z.routes.length; Q++) {
      if (livedata[Q]) {
        livedata[Q].points.sort(sort_livedata);
        M = z.routes[Q];
        M.addlatlngs(livedata[Q].points);
        if (M.zerotime < z.zerotime) {
          z.zerotime = M.zerotime;
        }
        if (M.zerotime + M.latarray.length > z.maxtime) {
          z.maxtime = M.zerotime + M.latarray.length;
        }
      }
    }
    if (z.liveprovider == "tractrac" || z.liveprovider == "gpsseuranta") {
      if (!z.liveinitdone) {
        z.liveinitdone = 1;
        z.loadcoursesplitsidstr();
        if (getURLParameter("dolive")) {
          z.play_speed = 1;
          z.playing = 1;
        } else {
          if (z.playing) {
            z.toggleplay();
          }
        }
        z.request_redraw();
        z.playtime = z.zerotime;
        z.reset_replaystarttime();
        z.update_routediv(false);
        var M = z.routes[0];
        P1 = z.map.toxy(M.latarray[0], M.lngarray[0]);
        z.map_start_x = P1.x;
        z.map_start_y = P1.y;
        z.move_mapxy_to_center(z.map_start_x, z.map_start_y);
        z.AllRoutestoStart();
      }
    }
    console.log("Got " + (O.length - 1) + " positions");
    console.log(z.IsLive);
  };
  this.Splitsbrowseronclick = function (M, S, O) {
    var N = z.splitsbrowserlines[0].splitsbrowserx;
    var Q = 1;
    for (var R = 1; R < N.length; R++) {
      if (M >= N[R]) {
        Q = R + 1;
      }
    }
    z.splitsbrowsermarkedsegment = Q;
  };
  this.drawSplitsbrowser = function () {
    var at = z.splitsbrowserlines.length;
    if (at > 0) {
      var aa = null;
      var Z;
      var aB = new Array();
      var ah = new Array();
      var ak = 4;
      var ac = 2;
      var aA = "8pt Verdana, sans-serif";
      var au = "rgb(128,128,128)";
      var Y = "rgb(192,192,192)";
      var U = [
        "rgb(0,0,255)",
        "rgb(255,0,0)",
        "rgb(0,192,0)",
        "rgb(0,192,192)",
        "rgb(192,0,192)",
        "rgb(255,153,0)",
      ];
      var an = 40.5;
      var ae = 18.5;
      var ao = 3;
      var ax = 8;
      var aw = 8;
      var N = $("#splitsbrowser").width() - an - 80;
      var aj = $("#splitsbrowser").height() - ae - 21.5;
      var aa = z.splitsbrowserlines[0].numcontrols;
      for (var ar = 0; ar < aa; ar++) {
        aB[ar] = 1e99;
      }
      var az = 4;
      if (az == 1) {
        for (var ay = 0; ay < at; ay++) {
          for (var ar = 0; ar < aa; ar++) {
            if (z.splitsbrowserlines[ay].splits[ar] != 0) {
              aB[ar] = Math.min(aB[ar], z.splitsbrowserlines[ay].splits[ar]);
            }
          }
        }
      } else {
        if (az == 2) {
          aB = z.splitsbrowserlines[0].splits;
        } else {
          if (az == 3) {
            for (var ar = 0; ar < aa; ar++) {
              var O = new Array();
              for (var ay = 0; ay < at; ay++) {
                if (z.splitsbrowserlines[ay].splits[ar] != 0) {
                  O.push(z.splitsbrowserlines[ay].splits[ar]);
                }
              }
              O.sort(function (aF, aE) {
                return aF - aE;
              });
              var Q = 5;
              var W = Math.min(Q, z.splitsbrowserlines.length - 3);
              if (W < 1) {
                W = 1;
              }
              this_ideal = 0;
              for (j = 0; j < W; j++) {
                this_ideal += O[j];
              }
              this_ideal = this_ideal / W;
              aB[ar] = Math.round(this_ideal);
            }
          } else {
            if (az == 4) {
              for (var ar = 0; ar < aa; ar++) {
                aB[ar] = 1e99;
              }
              for (var ar = 0; ar < aa; ar++) {
                for (var ay = 0; ay < at; ay++) {
                  if (z.splitsbrowserlines[ay].splits[ar] != 0) {
                    aB[ar] = Math.min(
                      aB[ar],
                      z.splitsbrowserlines[ay].splits_tot[ar]
                    );
                  }
                }
              }
              for (var ar = aa - 1; ar > 0; ar--) {
                aB[ar] = aB[ar] - aB[ar - 1];
              }
            }
          }
        }
      }
      for (var ar = 0; ar < aa; ar++) {
        if (aB[ar] > 1e90 || aB[ar] < -1e90) {
          aB[ar] = 0;
        }
      }
      ah[0] = aB[0];
      for (var ar = 1; ar < aa; ar++) {
        ah[ar] = ah[ar - 1] + aB[ar];
      }
      Z = ah[ah.length - 1];
      $("#splitsbrowser").clearCanvas().drawRect({
        strokeStyle: "#000",
        strokeWidth: ac,
        x: an,
        y: ae,
        width: N,
        height: aj,
        fromCenter: false,
      });
      var X = 0;
      var aq = 0;
      var S = 0;
      for (var ay = 0; ay < at; ay++) {
        if (z.splitsbrowserlines[ay].show) {
          S++;
          var af = 0;
          for (var ar = 0; ar < aa; ar++) {
            if (z.splitsbrowserlines[ay].splits_tot[ar] != 0) {
              var T = z.splitsbrowserlines[ay].splits_tot[ar] - ah[ar];
              aq = Math.max(aq, T);
              X = Math.min(X, T);
            }
          }
        }
      }
      var R = aq - X;
      X -= R * 0.05;
      aq += R * 0.05;
      R = aq - X;
      var ap = R / 10;
      var ag = 1;
      if (20 < ap) {
        ag = 60;
      }
      while (ag < ap) {
        if (ag * 5 < ap) {
          ag *= 10;
          continue;
        }
        if (ag * 2 < ap) {
          ag *= 5;
          continue;
        }
        ag *= 2;
      }
      for (var ad = Math.ceil(X / ag) * ag; ad <= aq; ad += ag) {
        var al = ae + (aj * (ad - X)) / R;
        $("#splitsbrowser")
          .drawLine({
            strokeStyle: "#000",
            strokeWidth: 0.5,
            x1: an - ao,
            y1: al,
            x2: an + N,
            y2: al,
          })
          .drawText({
            x: an - ax,
            y: al,
            text: ag < 60 ? ad.toString() : (ad / 60).toString(),
            fillStyle: au,
            align: "right",
            baseline: "middle",
            font: aA,
          });
      }
      $("#splitsbrowser")
        .drawText({
          x: an - ax,
          y: ae - 10,
          text: ag < 60 ? "sec" : "min",
          fillStyle: au,
          align: "right",
          baseline: "middle",
          font: aA,
        })
        .drawText({
          x: an,
          y: ae + aj + aw,
          text: "S",
          fillStyle: au,
          align: "center",
          baseline: "top",
          font: aA,
        })
        .drawText({
          x: an + N,
          y: ae + aj + aw,
          text: "F",
          fillStyle: au,
          align: "center",
          baseline: "top",
          font: aA,
        });
      var ai = an;
      var aD = 0;
      z.splitsbrowserlines[0].splitsbrowserx[0] = an;
      for (var ar = 0; ar < aa; ar++) {
        var am = an + (N * ah[ar]) / Z;
        if (am > ai) {
          $("#splitsbrowser").drawLine({
            strokeStyle: "#000",
            strokeWidth: 0.5,
            x1: am,
            y1: ae + 1,
            x2: am,
            y2: ae + aj + ao,
          });
          if ((am - ai > 12 || aD) && an + N - am > 12) {
            $("#splitsbrowser").drawText({
              x: am,
              y: ae + aj + aw,
              text: (ar + 1).toString(),
              fillStyle: au,
              align: "center",
              baseline: "top",
              font: aA,
            });
            aD = 0;
          } else {
            aD = 1;
          }
          ai = am;
        }
        z.splitsbrowserlines[0].splitsbrowserx[ar + 1] = am;
      }
      var av = S - 1;
      for (var ay = at - 1; ay >= 0; ay--) {
        if (z.splitsbrowserlines[ay].show) {
          var ai = an;
          var ab = ae + (aj * -X) / R;
          var M = 0;
          for (var ar = 0; ar < aa; ar++) {
            if (z.splitsbrowserlines[ay].splits_tot[ar] != 0) {
              var T = z.splitsbrowserlines[ay].splits_tot[ar] - ah[ar] - X;
              var am = an + (N * ah[ar]) / Z;
              var al = ae + (aj * T) / R;
              var aC = U[av % 6];
              if (M) {
                aC = Y;
                M = 0;
              }
              $("#splitsbrowser").drawLine({
                strokeStyle: aC,
                strokeWidth: ak,
                x1: ai,
                y1: ab,
                x2: am,
                y2: al,
              });
              ai = am;
              ab = al;
            } else {
              if (aB[ar] > 0) {
                M = 1;
              }
            }
          }
          var V = (ay + 1)
            .toString()
            .concat(" ")
            .concat(z.splitsbrowserlines[ay].name);
          $("#splitsbrowser").drawText({
            x: an + N + ax,
            y: al,
            text: V,
            fillStyle: U[av % 6],
            align: "left",
            baseline: "middle",
            font: aA,
          });
          av--;
        }
      }
    }
  };
}
function add_pacecolorslider() {
  ttext =
    '<br><br>Pace coloring: <span class="formvalue" id="slider-range-pace-range-val-2"></span></span><p><div id="slider-range-pace-range-2"></div><br><br>';
  $("#" + mapviewer.infobottomdiv).append(ttext);
  $("#slider-range-pace-range-2").slider({
    range: true,
    min: mapviewer.settings.pacecoloringslider.minpace,
    max: mapviewer.settings.pacecoloringslider.maxpace,
    step: 0.01,
    values: [
      mapviewer.settings.pacecoloring.minpace,
      mapviewer.settings.pacecoloring.maxpace,
    ],
    slide: function (f, g) {
      if (mapviewer.settings.pacecoloringslider.minsec) {
        $("#slider-range-pace-range-val-2").html(
          "" + tominsec(g.values[0] * 60) + " - " + tominsec(g.values[1] * 60)
        );
      } else {
        $("#slider-range-pace-range-val-2").html(
          "" + g.values[0] + " to " + g.values[1]
        );
      }
      mapviewer.settings.pacecoloring.minpace = g.values[0];
      mapviewer.settings.pacecoloring.maxpace = g.values[1];
      mapviewer.request_redraw();
    },
  });
}
function calcdistance(j, A, g, v) {
  var o = 1;
  var m = 6371;
  j = (j * Math.PI) / 180;
  g = (g * Math.PI) / 180;
  A = (A * Math.PI) / 180;
  v = (v * Math.PI) / 180;
  var q = g - j;
  var f = v - A;
  var z =
    Math.sin(q / 2) * Math.sin(q / 2) +
    Math.cos(j) * Math.cos(g) * Math.sin(f / 2) * Math.sin(f / 2);
  var u = 2 * Math.atan2(Math.sqrt(z), Math.sqrt(1 - z));
  var p = m * u * 1000;
  if (mapviewer.multfactor) {
    p = p * mapviewer.multfactor;
  }
  return p;
}
function interpolate_path_regular_distance(G, g) {
  var A = g;
  var v = [0];
  var z = [G[0].lat];
  var p = [G[0].lng];
  var u = [0];
  thisdist = 0;
  for (var q = 1; q < G.length; q++) {
    var f = G[q - 1];
    var F = G[q];
    var o = f.lat;
    var j = F.lat;
    var D = f.lng;
    var B = F.lng;
    Lreal = calcdistance(o, D, j, B);
    thisdist = thisdist + Lreal;
    v.push(thisdist);
    z.push(j);
    p.push(B);
    u.push(q);
  }
  new_distance = range(0, thisdist, A);
  new_lats = evaluateLinear(new_distance, v, z);
  new_lngs = evaluateLinear(new_distance, v, p);
  new_index = evaluateLinear(new_distance, v, u);
  interp_path = new Array();
  interp_path_str = new Array();
  interp_path_index = new Array();
  interp_path.push(G[0]);
  interp_path[0].dist = 0;
  interp_path_index.push(0);
  interp_path_str.push(
    parseInt(G[0].lat * 100000) / 100000 +
      "," +
      parseInt(G[0].lng * 100000) / 100000
  );
  for (var q = 0; q < new_distance.length; q++) {
    var E = new Object();
    E.lat = new_lats[q];
    E.lng = new_lngs[q];
    E.dist = new_distance[q];
    interp_path.push(E);
    interp_path_str.push(
      parseInt(E.lat * 100000) / 100000 +
        "," +
        parseInt(E.lng * 100000) / 100000
    );
    interp_path_index.push(Math.round(new_index[q]));
  }
  var m = new Object();
  m.distance = new_distance;
  m.interp_path = interp_path;
  m.routelength = thisdist;
  m.interp_path_index = interp_path_index;
  m.interp_path_string = interp_path_str.join(";");
  return m;
}
function interpolate_path_regular_distance_old(G, j) {
  var z = j;
  interp_path = new Array();
  interp_path_str = new Array();
  interp_path_index = new Array();
  interp_path.push(G[0]);
  interp_path[0].dist = 0;
  interp_path_index.push(0);
  interp_path_str.push(
    parseInt(G[0].lat * 100000) / 100000 +
      "," +
      parseInt(G[0].lng * 100000) / 100000
  );
  var H = 0;
  for (var v = 0; v < G.length - 1; v++) {
    var f = G[v];
    var F = G[v + 1];
    var p = f.lat;
    var m = F.lat;
    var D = f.lng;
    var A = F.lng;
    Lreal = calcdistance(p, D, m, A);
    lastlat = f.lat;
    lastlng = f.lng;
    var B = Math.round(Lreal / z);
    console.log(Lreal + ": divide into " + B);
    if (B == 0) {
      interp_path_index.push(interp_path.length - 1);
      var E = new Object();
      E = F;
      currdist = calcdistance(lastlat, lastlng, E.lat, E.lng);
      H = H + currdist;
      E.dist = H;
      interp_path.push(E);
      interp_path_str.push(
        parseInt(E.lat * 100000) / 100000 +
          "," +
          parseInt(E.lng * 100000) / 100000
      );
      lastlat = E.lat;
      lastlng = E.lng;
    } else {
      for (var g = 1; g <= B; g++) {
        var u = g / B;
        var q = interpolate(p, D, m, A, u);
        var E = new Object();
        E.lat = q.xn;
        E.lng = q.yn;
        currdist = calcdistance(lastlat, lastlng, E.lat, E.lng);
        H = H + currdist;
        E.dist = H;
        interp_path.push(E);
        interp_path_str.push(
          parseInt(E.lat * 100000) / 100000 +
            "," +
            parseInt(E.lng * 100000) / 100000
        );
        lastlat = E.lat;
        lastlng = E.lng;
      }
    }
    interp_path_index.push(interp_path.length - 1);
  }
  var o = new Object();
  o.interp_path = interp_path;
  o.routelength = H;
  o.interp_path_index = interp_path_index;
  o.interp_path_string = interp_path_str.join(";");
  return o;
}
function SplitLine(g, o, f, j, m) {
  this.runnername = g;
  this.time = o;
  this.rnr = f;
  this.fromind = j;
  this.toind = m;
}
function Segment(o, m, g, j, f) {
  this.pos1start = o;
  this.pos2start = m;
  this.segmenttype = g;
  this.newpos2 = -1;
  this.newpos1 = -1;
  this.pos1end = -1;
  this.pos2end = -1;
  this.length1 = -1;
  this.length2 = -1;
  this.rnr1 = j;
  this.rnr2 = f;
}
Date.prototype.toString = function () {
  var p = this.getFullYear();
  var o = this.getMonth() + 1;
  var f = this.getDate();
  var m = this.getHours();
  var j = this.getMinutes();
  var g = this.getSeconds();
  if (f < 10) {
    f = "0" + f;
  }
  if (o < 10) {
    o = "0" + o;
  }
  if (m < 10) {
    m = "0" + m;
  }
  if (j < 10) {
    j = "0" + j;
  }
  if (g < 10) {
    g = "0" + g;
  }
  return p + "-" + o + "-" + f + " " + m + ":" + j + ":" + g;
};
Date.parseIso = function (j) {
  var g = j.split(" ");
  var o = g[0].split("-");
  var f = g[1].split(":");
  var m = new Date();
  m.setFullYear(o[0]);
  m.setMonth(o[1] + 1);
  m.setDate(o[2]);
  m.setHours(f[0]);
  m.setMinutes(f[1]);
  m.setSeconds(f[2]);
  m.setMilliseconds(0);
  return m;
};
Date.prototype.localToUtc = function () {
  var g = this.getTimezoneOffset() * 60000;
  var f = new Date(this.getTime() + g);
  return f;
};
Date.prototype.utcToLocal = function () {
  var g = this.getTimezoneOffset() * 60000;
  var f = new Date(this.getTime() - g);
  return f;
};
String.prototype.pad = function (f, g) {
  return (f -= this.length) > 0
    ? (g = new Array(Math.ceil(f / g.length) + 1).join(g)).substr(0, g.length) +
        this +
        g.substr(0, f - g.length)
    : this;
};
Array.prototype.sum = function () {
  for (var g = 0, f = this.length, j = 0; g < f; j += this[g++]) {}
  return j;
};
Array.prototype.max = function () {
  var g = this[0];
  var f = this.length;
  for (var j = 1; j < f; j++) {
    if (g == undefined) {
      g = this[j];
    } else {
      if (this[j] > g) {
        g = this[j];
      }
    }
  }
  return g;
};
function keys(j) {
  var g = [];
  for (var f in j) {
    if (j.hasOwnProperty(f)) {
      g.push(f);
    }
  }
  return g;
}
function encode_utf8(f) {
  return unescape(encodeURIComponent(f));
}
function decode_utf8(f) {
  return decodeURIComponent(escape(f));
}
function sortWithIndeces(g) {
  for (var m = 0; m < g.length; m++) {
    g[m] = [parseFloat(g[m]), m];
  }
  g.sort(function (o, j) {
    return o[0] < j[0] ? -1 : 1;
  });
  g.sortIndices = [];
  for (var f = 0; f < g.length; f++) {
    g.sortIndices.push(g[f][1]);
    g[f] = g[f][0];
  }
  return g;
}
function asortWithIndeces(g) {
  for (var m = 0; m < g.length; m++) {
    g[m] = [parseFloat(g[m]), m];
  }
  g.sort(function (o, j) {
    return o[0] > j[0] ? -1 : 1;
  });
  g.sortIndices = [];
  for (var f = 0; f < g.length; f++) {
    g.sortIndices.push(g[f][1]);
    g[f] = g[f][0];
  }
  return g;
}
Array.prototype.min = function () {
  var j = this[0];
  var f = this.length;
  for (var g = 1; g < f; g++) {
    if (j == undefined) {
      j = this[g];
    } else {
      if (this[g] < j) {
        j = this[g];
      }
    }
  }
  return j;
};
function average_array(f, u, j) {
  if (u == 0) {
    return f;
  }
  var m = new Array();
  if (j == "normal") {
    for (var o = 0; o < f.length; o++) {
      starteind = o - u;
      if (starteind < 0) {
        starteind = 0;
      }
      stopeind = o + u;
      if (stopeind > f.length - 1) {
        stopeind = f.length - 1;
      }
      var q = 0;
      for (var p = starteind; p <= stopeind; p++) {
        q = q + f[p];
      }
      m[o] = q / (stopeind - starteind + 1);
    }
  } else {
    if (j == "nozero") {
      for (var o = 0; o < f.length; o++) {
        starteind = o - u;
        p = o;
        if (f[p] == 0) {
          if (starteind < 0) {
            starteind = 0;
          }
          while (p >= starteind && f[p] == 0) {
            p--;
          }
          f[o] = f[p];
        }
        m[o] = f[p];
      }
    } else {
      if (j == "avnozero") {
        for (var o = 0; o < f.length; o++) {
          var g = 0;
          starteind = o - u;
          if (starteind < 0) {
            starteind = 0;
          }
          stopeind = o + u;
          if (stopeind > f.length - 1) {
            stopeind = f.length - 1;
          }
          var q = 0;
          for (var p = starteind; p <= stopeind; p++) {
            if (f[p] != 0) {
              g++;
              q = q + f[p];
            }
          }
          if (g > 0) {
            m[o] = q / g;
          } else {
            m[o] = 0;
          }
        }
      }
    }
  }
  return m;
}
function average_line(q, v, j) {
  if (v == 0) {
    return q;
  }
  if (j == "startzero") {
    j = "normal";
    for (var E = 1; E < q.length; E++) {
      q[E][1] = q[E][1] - q[0][1];
    }
  }
  var p = new Array();
  if (j == "normal") {
    for (var E = 0; E < q.length; E++) {
      starteind = E - v;
      if (starteind < 0) {
        starteind = 0;
      }
      stopeind = E + v;
      if (stopeind > q.length - 1) {
        stopeind = q.length - 1;
      }
      var G = 0;
      for (var u = starteind; u <= stopeind; u++) {
        G = G + q[u][1];
      }
      p[E] = [q[E][0], G / (stopeind - starteind + 1)];
    }
  } else {
    if (j == "normal-separator") {
      var m = mapviewer.courseinfo.hillsegments;
      var o = new Array();
      for (var f = 0; f < m.length; f++) {
        if (m[f].thetypeint == 2) {
          o.push(m[f].startind);
        }
      }
      o.push(q.length);
      var D = 0;
      var B = null;
      var z = new Array();
      for (var F = 0; F < o.length; F++) {
        B = o[F];
        for (var E = D; E < B; E++) {
          starteind = E - v;
          if (starteind < 0) {
            starteind = 0;
          }
          stopeind = E + v;
          if (stopeind > q.length - 1) {
            stopeind = q.length - 1;
          }
          var G = 0;
          for (var u = starteind; u <= stopeind; u++) {
            G = G + q[u][1];
          }
          p[E] = [q[E][0], G / (stopeind - starteind + 1)];
        }
        if (F < o.length) {
          if (q[B]) {
            z.push([B, q[B][1]]);
          }
          if (q[B + 1]) {
            z.push([B + 1, q[B + 1][1]]);
          }
        }
        D = B;
      }
      for (var f = 0; f < z.length; f++) {
        p[z[f][0]][1] = z[f][1];
      }
    } else {
      if (j == "nozero") {
        for (var E = 0; E < q.length; E++) {
          starteind = E - v;
          var g;
          u = E;
          if (q[u][1] == 0) {
            if (starteind < 0) {
              starteind = 0;
            }
            while (u >= 1 && u >= starteind && q[u][1] == 0) {
              u--;
            }
            g = q[u][1];
          } else {
            g = q[u][1];
          }
          p[E] = [q[E][0], g];
        }
      } else {
        if (j == "avnozero") {
          for (var E = 0; E < q.length; E++) {
            var A = 0;
            starteind = E - v;
            if (starteind < 0) {
              starteind = 0;
            }
            stopeind = E + v;
            if (stopeind > q.length - 1) {
              stopeind = q.length - 1;
            }
            var G = 0;
            for (var u = starteind; u <= stopeind; u++) {
              if (q[u][1] != 0) {
                G = G + q[u][1];
                A++;
              }
            }
            if (A > 2) {
              p[E] = [q[E][0], G / A];
            } else {
              p[E] = [q[E][0], 0];
            }
          }
        }
      }
    }
  }
  return p;
}
function average_line_segments(q, z) {
  var o = new Array();
  var p = mapviewer.courseinfo.hillsegments;
  var E = z.fraction_for_zero;
  var u = z.includeele_percent_min;
  var F = z.includeele_percent_max;
  var m = z.plottype;
  if (m != 1) {
    for (var g = 0; g < p.length; g++) {
      var f = p[g].startind;
      var A = p[g].endind;
      var v = p[g].percent;
      var j = 0;
      var B = 0;
      for (var D = f; D < A; D++) {
        if (q[D][1] != 0) {
          B++;
          j = j + q[D][1];
        }
      }
      if (B > (A - f) * E) {
        j = j / B;
      } else {
        j = 0;
      }
      if (v < u || v > F) {
        j = 0;
      }
      for (var D = f; D < A; D++) {
        o[D] = [q[D][0], j];
      }
    }
  } else {
    for (var g = 0; g < p.length; g++) {
      var f = p[g].startind;
      var A = p[g].endind;
      var v = p[g].percent;
      for (var D = f; D < A; D++) {
        j = q[A][1] - q[f][1];
        o[D] = [q[D][0], j];
      }
    }
  }
  return o;
}
function average_segments(u, z) {
  fraction_for_zero = 0.3;
  var p = new Array();
  var q = mapviewer.courseinfo.hillsegments;
  if (z == 0) {
    for (var j = 0; j < q.length; j++) {
      var g = q[j].startind;
      var B = q[j].endind;
      var o = 0;
      var D = 0;
      for (var E = g; E < B; E++) {
        if (u[E][1] != 0) {
          D++;
          o = o + u[E][1];
        }
      }
      if (D > (B - g) * fraction_for_zero) {
        o = o / D;
      } else {
        o = 0;
      }
      p[j] = o;
    }
  } else {
    if (z == 2) {
      var v = u[0];
      var A = u[1];
      if (A) {
        for (var j = 0; j < q.length; j++) {
          var m = parseInt(q[j].startind);
          var f = parseInt(q[j].endind);
          var g = Math.round(v[m]);
          var B = Math.round(v[f]);
          if (B > A.length) {
            B = A.length;
          }
          var o = 0;
          var D = 0;
          for (var E = g; E < B; E++) {
            if (A[E] != 0) {
              D++;
              o = o + A[E];
            }
          }
          if (D > (B - g) * fraction_for_zero) {
            o = o / D;
          } else {
            o = 0;
          }
          p[j] = o;
        }
      } else {
        p = [];
      }
    } else {
      for (var j = 0; j < q.length; j++) {
        var g = q[j].startind;
        var B = q[j].endind;
        if (u[B] && u[g]) {
          o = u[B][1] - u[g][1];
        } else {
          o = 0;
        }
        p[j] = o;
      }
    }
  }
  return p;
}
function tominsec(f) {
  sign = "";
  if (f < 0) {
    sign = "-";
  }
  f = Math.abs(Math.floor(f));
  return sign + Math.floor(f / 60) + ":" + (f % 60).toFixed().pad(2, "0");
}
function tominsecpad(f) {
  f = Math.floor(f);
  return (
    Math.floor(f / 60)
      .toFixed()
      .pad(2, "0") +
    ":" +
    (f % 60).toFixed().pad(2, "0")
  );
}
function deg2rad(f) {
  return (f * 3.1415926) / 180;
}
function interpolate(g, m, f, j, o) {
  var p = new Object();
  p.xn = g + (f - g) * o;
  p.yn = m + (j - m) * o;
  return p;
}
function interpolate1(g, f, j) {
  xn = g + (f - g) * j;
  return xn;
}
function interpolate_arr(m, g) {
  var f = new Array();
  for (var j = 0; j < g.length; j++) {
    ind = g[j];
    startind = Math.floor(ind);
    dind = ind - startind;
    stopind = startind + 1;
    if (dind != 0) {
      f[j] = m[startind] + (m[stopind] - m[startind]) * dind;
    } else {
      f[j] = m[startind];
    }
  }
  return f;
}
function interpolate_xyarr(f, g) {
  var o = new Array();
  for (var z = 0; z < g.length; z++) {
    ind = g[z];
    startind = Math.floor(ind);
    dind = ind - startind;
    stopind = startind + 1;
    if (dind != 0) {
      if (f[startind]) {
        xy0 = f[startind].split(",");
        var m = parseFloat(xy0[0]);
        var A = parseFloat(xy0[1]);
        var u = f[stopind].split(",");
        var j = parseFloat(u[0]);
        var v = parseFloat(u[1]);
        var q = m + (j - m) * dind;
        var p = A + (v - A) * dind;
        o[z] = q + "," + p;
      } else {
        o[z] = "0,0";
      }
    } else {
      o[z] = f[startind];
    }
  }
  return o;
}
function sort_corridor_result(j, f) {
  var m = 0;
  var g = 0;
  if (j.results) {
    if (j.results.corridor_overall) {
      m = j.results.corridor_overall;
    }
  }
  if (f.results) {
    if (f.results.corridor_overall) {
      g = f.results.corridor_overall;
    }
  }
  if (isNaN(m)) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (isNaN(g)) {
    g = 10000000 + f.indexnumber / 1000;
  }
  if (m <= 0) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000000 + f.indexnumber / 1000;
  }
  return g + f.indexnumber / 1000 - (m + j.indexnumber / 1000);
}
function sort_compass_result(j, f) {
  var m = 0;
  var g = 0;
  if (j.results) {
    if (j.results.compass_overall) {
      m = j.results.compass_overall;
    }
  }
  if (f.results) {
    if (f.results.compass_overall) {
      g = f.results.compass_overall;
    }
  }
  if (isNaN(m)) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (isNaN(g)) {
    g = 10000000 + f.indexnumber / 1000;
  }
  if (m <= 0) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000000 + f.indexnumber / 1000;
  }
  return g + f.indexnumber / 1000 - (m + j.indexnumber / 1000);
}
function sort_segmenttimelength(j, f) {
  var m;
  var g;
  if (
    mapviewer.settings.corridoranalysis == 1 &&
    mapviewer.settings.otechanalysis == 1
  ) {
    return sort_corridor_result(j, f);
  }
  if (
    mapviewer.settings.compassanalysis == 1 &&
    mapviewer.settings.otechanalysis == 1
  ) {
    return sort_compass_result(j, f);
  }
  if (mapviewer.settings.colormode == mapviewer.settings.modes.colorbylength) {
    m = j.segmentlength;
    g = f.segmentlength;
  } else {
    m = j.segmenttime;
    g = f.segmenttime;
  }
  if (
    isNaN(m) ||
    (mapviewer.settings.colormode == mapviewer.settings.modes.colorbylength &&
      j.segmenttime < 0)
  ) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (
    isNaN(g) ||
    (mapviewer.settings.colormode == mapviewer.settings.modes.colorbylength &&
      f.segmenttime < 0)
  ) {
    g = 10000000 + f.indexnumber / 1000;
  }
  if (m <= 0) {
    m = 10000000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000000 + f.indexnumber / 1000;
  }
  return m + j.indexnumber / 1000 - (g + f.indexnumber / 1000);
}
function sort_segmentlength(j, f) {
  var m = j.segmentlength;
  var g = f.segmentlength;
  if (m <= 0) {
    m = 10000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000 + f.indexnumber / 1000;
  }
  return m + j.indexnumber / 1000 - (g + f.indexnumber / 1000);
}
function sort_xctime(j, f) {
  var m = j.time;
  var g = f.time;
  if (m <= 0) {
    m = 10000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000 + f.indexnumber / 1000;
  }
  return m + j.indexnumber / 1000 - (g + f.indexnumber / 1000);
}
function sort_xcstart(j, f) {
  var m = j.zerotime;
  var g = f.zerotime;
  if (m <= 0) {
    m = 10000 + j.indexnumber / 1000;
  }
  if (g <= 0) {
    g = 10000 + f.indexnumber / 1000;
  }
  return m + j.indexnumber / 1000 - (g + f.indexnumber / 1000);
}
function sort_xcname(j, f) {
  var m = j.runnername.toLowerCase();
  var g = f.runnername.toLowerCase();
  if (m < g) {
    return -1;
  }
  if (m > g) {
    return 1;
  }
  return 0;
}
function findsort(f) {
  var j = new Array();
  for (var g = 0; g < f.length; g++) {
    var m = new Object();
    m.orgind = g;
    m.index = f[g][1];
    j[g] = m;
  }
  j.sort(sort_index);
  ret = new Array();
  for (var g = 0; g < f.length; g++) {
    ret[g] = j[g].orgind;
  }
  return ret;
}
function sortline(f, g) {
  ret = new Array();
  for (var j = 0; j < f.length; j++) {
    ret[j] = f[g[j]];
  }
  return ret;
}
function sort_livedata(j, f) {
  var m = j.time;
  var g = f.time;
  return m - g;
}
function sort_index(j, f) {
  var m = j.index;
  var g = f.index;
  return m - g;
}
function getBrowserWidth() {
  if (typeof document.body.clientWidth == "number") {
    myWidth = document.body.clientWidth;
  } else {
    if (typeof window.innerWidth == "number") {
      myWidth = window.innerWidth;
    } else {
      if (
        document.documentElement &&
        (document.documentElement.clientWidth ||
          document.documentElement.clientHeight)
      ) {
        myWidth = document.documentElement.clientWidth;
      } else {
        if (
          document.body &&
          (document.body.clientWidth || document.body.clientHeight)
        ) {
          myWidth = document.body.clientWidth;
        }
      }
    }
  }
  return myWidth;
}
function getBrowserHeight() {
  var f = 0;
  if (0) {
    f = document.body.clientHeight;
  } else {
    if (typeof window.innerWidth == "number") {
      f = window.innerHeight;
    } else {
      if (
        document.documentElement &&
        (document.documentElement.clientWidth ||
          document.documentElement.clientHeight)
      ) {
        f = document.documentElement.clientHeight;
      } else {
        if (
          document.body &&
          (document.body.clientWidth || document.body.clientHeight)
        ) {
          f = document.body.clientHeight;
        }
      }
    }
  }
  return f;
}
function resizeCanvas() {
  if (new Date() - rtime < delta) {
    setTimeout(resizeCanvas, delta);
  } else {
    timeout = false;
    var f = setTimeout("mapviewer.redraw()", 500);
  }
}
var slines;
function Segment_to_SplitsBrowser() {
  self = mapviewer;
  if (self.splitsbrowserlines[0] && self.splitsbrowserlines[1]) {
    self.drawSplitsbrowser();
    self.request_redraw();
    return 1;
  } else {
    return 0;
  }
}
function bindEvent(m, f, g, j) {
  if (m.addEventListener) {
    m.addEventListener(f, g, j);
  } else {
    if (m.attachEvent) {
      m.attachEvent("on" + f, g);
    }
  }
}
function noenter(f) {
  if (window.event.keyCode == 13) {
    if (f == "addTag") {
      mapviewer.addTag();
    } else {
      if (f == "addrouteTag") {
        mapviewer.addrouteTag();
      } else {
        if (f == "saveState") {
          mapviewer.saveState();
        }
      }
    }
  }
  return !(window.event && window.event.keyCode == 13);
}
function median(f) {
  f.sort(function (m, j) {
    return m - j;
  });
  var g = Math.floor(f.length / 2);
  if (f.length % 2) {
    return f[g];
  } else {
    return (f[g - 1] + f[g]) / 2;
  }
}
function SplitsbrowserLine(f, g) {
  this.splits_tot = g;
  this.splits = new Array();
  this.splits[0] = this.splits_tot[0];
  for (var j = 1; j < this.splits_tot.length; j++) {
    this.splits[j] = this.splits_tot[j] - this.splits_tot[j - 1];
    if (this.splits[j] < 0) {
      this.splits[j] = 0;
    }
  }
  this.name = f;
  this.show = true;
  this.numcontrols = this.splits.length;
  this.splitsbrowserx = new Array();
}
function parseXml(f) {
  if (jQuery.browser.msie) {
    var g = new ActiveXObject("Microsoft.XMLDOM");
    g.loadXML(f);
    f = g;
  }
  return f;
}
function convert_datetime_tosec(f) {
  var g = new Date(
    f.substr(0, 4),
    f.substr(5, 2) - 1,
    f.substr(8, 2),
    f.substr(11, 2),
    f.substr(14, 2),
    f.substr(17, 2)
  );
  return g.getTime() / 1000;
}
function parse_gpx_fromform(f) {
  txt = $("#" + f).val();
  parse_gpx_fromtxt(txt);
}
function parse_fit_fromdata(j) {
  var u = new Object();
  var m = new Array();
  var v = new Array();
  var f = new Array();
  var z = new Array();
  var q = 0;
  var g;
  var o;
  var p;
  tmptmp2 = j;
}
function parse_gpx_fromtxt(o) {
  var A = new Object();
  var p = new Array();
  var D = new Array();
  var g = new Array();
  var E = new Array();
  var z = 0;
  var j;
  var u;
  var v;
  o = o.replace(/tp1:/gi, "tp1");
  o = o.replace(/ns3:/gi, "tp1");
  o = o.replace(/gpxtpx:/gi, "tp1");
  var f = mapviewer.datafieldtypes;
  var m = new Object();
  for (var B = 0; B < f.length; B++) {
    m[f[B]] = new Array();
  }
  var q = new Array();
  $(parseXml(o))
    .find("trkpt")
    .each(function () {
      u = parseFloat($(this).attr("lat"));
      v = parseFloat($(this).attr("lon"));
      j = convert_datetime_tosec($(this).find("time").text());
      if (u != 0 && v != 0) {
        for (var F = 0; F < f.length; F++) {
          fieldtype = f[F];
          var G = fieldtype;
          if (fieldtype == "elevation") {
            G = "ele";
          }
          val = parseFloat($(this).find(G).text());
          if (fieldtype == "pulse" && (!val || isNaN(val))) {
            val = parseFloat(
              $(this)
                .find("extensions")
                .find("tp1TrackPointExtension")
                .find("tp1hr")
                .text()
            );
          }
          if (isNaN(val)) {
            val = 0;
          }
          m[fieldtype].push(val);
          if (val) {
            q[fieldtype] = 1;
          }
        }
        p.push(u);
        D.push(v);
        g.push(j);
      }
    });
  A.lats = p.join(";");
  A.lngs = D.join(";");
  A.times = g.join(";");
  for (var B = 0; B < f.length; B++) {
    fieldtype = f[B];
    if (q[fieldtype]) {
      A[fieldtype] = m[fieldtype].join(";");
    }
  }
  return A;
}
function getURLParameter(f) {
  return (
    decodeURIComponent(
      (new RegExp("[?|&]" + f + "=([^&;]+?)(&|#|;|$)").exec(
        location.search
      ) || [, ""])[1].replace(/\+/g, "%20")
    ) || null
  );
}
String.prototype.capitalize = function () {
  return this.charAt(0).toUpperCase() + this.slice(1);
};
function barplot(m, o, u, f, q, g, j) {
  thelabels = [];
  if (xclight) {
    for (var p = 0; p < u[0].length; p++) {
      thelabels[p] = tominsec(u[0][p][1]);
    }
  } else {
    for (var p = 0; p < u[0].length; p++) {
      thelabels[p] = u[0][p][1];
    }
  }
  canvasplot = $.jqplot(m, u, {
    title: o,
    axesDefaults: {
      tickRenderer: $.jqplot.CanvasAxisTickRenderer,
      tickOptions: {
        angle: mapviewer.settings.graphsettings.barplotangle,
        fontSize: mapviewer.settings.graphsettings.barplotfontsize,
        formatString: "%d",
      },
    },
    seriesDefaults: {
      renderer: $.jqplot.BarRenderer,
      color: "#00f",
      rendererOptions: {
        fillToZero: true,
        varyBarColor: true,
        useNegativeColors: false,
      },
      pointLabels: {
        show: true,
        labels: thelabels,
        formatString: (function () {
          return q;
        })(),
      },
    },
    axes: {
      xaxis: { renderer: $.jqplot.CategoryAxisRenderer },
      yaxis: { min: g, max: j },
    },
    seriesColors: f,
  });
  return canvasplot;
}
function barplot_stacked(B, p, q, u, f, m, o, A, j, z) {
  var g = $("#" + B).width();
  if (!q) {
    $("#" + B).html("No data to plot");
    return;
  }
  var v = q[0].length;
  g = g / v;
  g = (g * 50) / 100;
  canvasplot = $.jqplot(B, q, {
    title: p,
    stackSeries: true,
    series: o,
    legend: {
      renderer: $.jqplot.EnhancedLegendRenderer,
      rendererOptions: { numberColumns: o.length },
      show: true,
      location: "ne",
      placement: "insideGrid",
    },
    axesDefaults: {
      tickRenderer: $.jqplot.CanvasAxisTickRenderer,
      tickOptions: {
        angle: mapviewer.settings.graphsettings.barplotstackedangle,
        fontSize: mapviewer.settings.graphsettings.barplotstackedfontsize,
        formatString: "%d",
      },
    },
    seriesDefaults: {
      renderer: $.jqplot.BarRenderer,
      rendererOptions: {
        fillToZero: true,
        varyBarColor: true,
        useNegativeColors: false,
        barWidth: g,
        barMargin: 2,
        barPadding: 2,
        shadowOffset: 2,
        groups: m,
      },
      pointLabels: {
        show: A,
        formatString: (function () {
          return "%d";
        })(),
      },
    },
    axes: {
      xaxis: { ticks: u, renderer: $.jqplot.CategoryAxisRenderer },
      yaxis: { min: j, max: z },
    },
    seriesColors: f,
  });
  $(".jqplot-point-label").css("color", "rgba(208,208,208,1.0)");
  $(".jqplot-point-label").css(
    "font-size",
    mapviewer.settings.graphsettings.barplotstackedpointlabel
  );
}
function long2tile(g, f) {
  return Math.floor(((g + 180) / 360) * Math.pow(2, f));
}
function lat2tile(g, f) {
  return Math.floor(
    ((1 -
      Math.log(
        Math.tan((g * Math.PI) / 180) + 1 / Math.cos((g * Math.PI) / 180)
      ) /
        Math.PI) /
      2) *
      Math.pow(2, f)
  );
}
function tile2long(f, g) {
  return (f / Math.pow(2, g)) * 360 - 180;
}
function tile2lat(j, f) {
  var g = Math.PI - (2 * Math.PI * j) / Math.pow(2, f);
  return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(g) - Math.exp(-g)));
}
function plusminusr(f) {
  f = Math.round(f);
  if (f == 0) {
    f = "  -";
  } else {
    if (f > 0) {
      f = " + " + f + " s";
    } else {
      f = " - " + Math.abs(f) + " s";
    }
  }
  return f;
}
function derror() {
  alert(
    "Sorry - something went wrong. Please contact jan@kocbach.net to find out why!"
  );
}
function setCookie(f, g) {
  exeoutput.SetGlobalVariable(f, g, true);
}
function getCookie(f) {
  return exeoutput.GetGlobalVariable(f, "");
}
function localStorage_setItem(f, g) {
  if (localStorage == null) {
    setCookie(f, g);
  } else {
    localStorage.setItem(f, g);
  }
}
function localStorage_getItem(f) {
  var g;
  if (localStorage == null) {
    g = getCookie(f);
    if (g == "") {
      g = null;
    }
  } else {
    g = localStorage.getItem(f);
  }
  return g;
}
function downloadImg(g, j) {
  console.log("Saving " + j);
  var f;
  var z = atob(g.split(",")[1]);
  var m = new ArrayBuffer(z.length);
  var u = new Uint8Array(m);
  for (var o = 0; o < z.length; o++) {
    u[o] = z.charCodeAt(o) & 255;
  }
  try {
    f = new Blob([m], { type: "application/octet-stream" });
  } catch (p) {
    console.log("Fallback");
    var q = new (window.WebKitBlobBuilder || window.MozBlobBuilder)();
    q.append(m);
    f = q.getBlob("application/octet-stream");
  }
  var v = document.createElement("a");
  v.download = j;
  v.href = window.URL.createObjectURL(f);
  v.textContent = "";
  v.click();
}
function downloadTxt(j, m) {
  var g = new Blob([j], { type: "text/plain" });
  var f = document.createElement("a");
  f.download = m;
  f.href = window.URL.createObjectURL(g);
  f.textContent = "";
  f.click();
}
function hsvToRgb(z, G, E) {
  var j, A, D;
  var u;
  var B, o, m, F;
  z = Math.max(0, Math.min(360, z));
  G = Math.max(0, Math.min(100, G));
  E = Math.max(0, Math.min(100, E));
  G /= 100;
  E /= 100;
  if (G == 0) {
    j = A = D = E;
    return [Math.round(j * 255), Math.round(A * 255), Math.round(D * 255)];
  }
  z /= 60;
  u = Math.floor(z);
  B = z - u;
  o = E * (1 - G);
  m = E * (1 - G * B);
  F = E * (1 - G * (1 - B));
  switch (u) {
    case 0:
      j = E;
      A = F;
      D = o;
      break;
    case 1:
      j = m;
      A = E;
      D = o;
      break;
    case 2:
      j = o;
      A = E;
      D = F;
      break;
    case 3:
      j = o;
      A = m;
      D = E;
      break;
    case 4:
      j = F;
      A = o;
      D = E;
      break;
    default:
      j = E;
      A = o;
      D = m;
  }
  return (
    Math.round(j * 255).toString(16) +
    Math.round(A * 255).toString(16) +
    Math.round(D * 255).toString(16)
  );
}
function testAJAX() {
  exeoutput.SetGlobalVariable("postdata", "name=John&location=Boston", false);
  $.ajax({
    type: "POST",
    url: "test.php",
    data: "name=John&location=Boston",
    success: function (f) {
      alert("Data returned by Script: " + f);
    },
  });
}
function isTainted(f) {
  try {
    var g = f.getImageData(0, 0, 1, 1);
    return false;
  } catch (j) {
    return j.code === 18;
  }
}
function fillarray(g, f) {
  return Array.apply(null, Array(g)).map(Number.prototype.valueOf, f);
}
function toggle_div(f) {
  if ($("#" + f)) {
    if ($("#" + f).is(":visible")) {
      $("#" + f).hide();
    } else {
      $("#" + f).show();
    }
  }
}
function transpose(g) {
  if (g.length == 0) {
    return null;
  }
  var f = g[0].map(function (j, m) {
    return g.map(function (o) {
      return o[m];
    });
  });
  return f;
}
function DBcom(j, g, f) {
  self = this;
  this.hidemenus = function () {
    $("#infobox").hide();
    $("#rightmenu").hide();
  };
  this.showmenus = function () {
    $("#infobox").show();
    $("#rightmenu").show();
  };
  this.toggleplay = function () {
    mapviewer.toggleplay();
  };
  this.savestate = function () {
    return mapviewer.savestate();
  };
  this.replayleg = function (o, m) {
    mapviewer.replayleg(o, m);
  };
  this.savevideoleg = function (o, m) {
    mapviewer.start_save_animation();
    mapviewer.replayleg(o, m);
  };
  this.prepare_replayleg = function () {
    self.hidemenus();
    mapviewer.settings.replayleg = 0;
    mapviewer.hideallroutes();
    mapviewer.request_redraw();
  };
  this.help = function () {
    console.log("var thisstate = C.savestate();");
    console.log("C.replayleg(thisstate,{dots:1,samezoom:0,legendtype:1});");
    console.log("C.savevideoleg(thisstate,{dots:1,samezoom:0,legendtype:1});");
    console.log("C.prepare_replayleg();");
    console.log("C.hidemenus();");
    console.log("C.showmenus();");
  };
}
function closest(u, o) {
  var p = 0;
  var g = 1000000;
  var j;
  var q;
  for (p in u) {
    var f = Math.abs(o - u[p]);
    if (f < g) {
      g = f;
      j = u[p];
      q = p;
    }
  }
  return [j, q];
}
function sleep(f) {
  var g = new Date().getTime();
  while (g + f >= new Date().getTime()) {}
}
function find_where_others_better() {
  self = mapviewer;
  first = -1;
  for (var j = 0; j < self.routes.length; j++) {
    if (self.DrawnLines[j] && first < 0) {
      first = j;
      firstname = self.routes[j].runnername;
    }
  }
  finished = 0;
  self.settings.routeparts = new Array();
  var f = new Routepart(
    first,
    self.DrawnLines[first].start,
    self.DrawnLines[first].end,
    ""
  );
  self.settings.routeparts.push(f);
  for (var j = 0; j < self.routes.length; j++) {
    if (self.DrawnLines[j] && j != first && finished == 0) {
      thistime = self.DrawnLines[j].end - self.DrawnLines[j].start + 1;
      thisname = self.routes[j].runnername;
      L1 = self.DrawnLines[first];
      L2 = self.DrawnLines[j];
      self.segments = new Array();
      self.splitsbrowsermarkedsegment = null;
      self.numsegments = 0;
      self.ant_rechecks = 0;
      self.AutOanalysis_inner(first, j, L1.start, L1.end, L2.start, L2.end);
      compare_info = self.AutOanalysis_calcinfo();
      for (var g = 0; g < self.segments.length; g++) {
        thissegment = self.segments[g];
        faster_to_show = 5;
        time1 = thissegment.length1;
        time2 = thissegment.length2;
        if (time1 - time2 > faster_to_show && thissegment.segmenttype == 0) {
          var f = new Routepart(
            j,
            thissegment.pos2start,
            thissegment.pos2end,
            "-" + tominsec(time1 - time2)
          );
          self.settings.routeparts.push(f);
        }
      }
      time1 = compare_info.tot1_same;
      time2 = compare_info.tot2_same;
      percentdiff = ((time1 - time2) / time1) * 100;
      console.log(thisname + " " + tominsec(thistime));
      console.log(
        thisname +
          " vs " +
          firstname +
          ": " +
          percentdiff +
          "% time difference where both ran same route"
      );
    }
  }
  self.settings.draw_selected_routeparts = 1;
  self.request_redraw();
}
function find_where_others_better_off() {
  self.settings.draw_selected_routeparts = 0;
  self.request_redraw();
}
function findIntervalBorderIndex(f, j, p) {
  if (f < j[0]) {
    return 0;
  }
  if (f > j[j.length - 1]) {
    return j.length - 1;
  }
  var o,
    m = 0,
    g = j.length - 1;
  while (g - m !== 1) {
    o = m + Math.floor((g - m) / 2);
    f >= j[o] ? (m = o) : (g = o);
  }
  return p ? g : m;
}
function makeItArrayIfItsNot(f) {
  return Object.prototype.toString.call(f) !== "[object Array]" ? [f] : f;
}
function evaluateLinear(m, j, g) {
  var f = [];
  m = makeItArrayIfItsNot(m);
  m.forEach(function (o) {
    var p = findIntervalBorderIndex(o, j);
    if (p == j.length - 1) {
      p--;
    }
    f.push(linearInterpolation(o, j[p], g[p], j[p + 1], g[p + 1]));
  });
  return f;
}
function linearInterpolation(g, o, q, m, p) {
  var j = (p - q) / (m - o);
  var f = -j * o + q;
  return j * g + f;
}
function range(p, j, m) {
  var g = [p],
    f = p;
  while (f < j) {
    g.push((f += m || 1));
  }
  var o = f > j ? g.slice(0, -1) : g;
  if (o[o.length - 1] != j) {
    o.push(j);
  }
  return o;
}
(function (f) {
  f.fn.sizeChanged = function (j) {
    var m = this;
    var g = m.width();
    var o = m.height();
    setInterval(function () {
      if (m.is(":hidden") || (g === m.width() && o === m.height())) {
        return;
      }
      if (typeof j == "function") {
        j({ width: g, height: o }, { width: m.width(), height: m.height() });
        g = m.width();
        o = m.height();
      }
    }, 500);
    return m;
  };
})(jQuery);
var C = new DBcom();
